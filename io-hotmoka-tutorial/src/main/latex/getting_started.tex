\chapter{Getting started with Hotmoka}\label{ch:getting_started_with_hotmoka}

\section{Hotmoka in a nutshell}\label{hotmoka_in_a_nutshell}

Hotmoka is the abstract definition of a device that can store
objects (data structures) in its persistent memory
(its \emph{state}\index{state} or \emph{storage}\index{storage})
and can execute, on those objects,
code written in a subset of Java called Takamaka\index{Takamaka}. Such a device is
called a \emph{Hotmoka node} and such programs are known as
\emph{smart contracts}, taking that terminology from programs that run inside
a blockchain. It is well true that Hotmoka nodes can be different from the nodes
of a blockchain (for instance, they can be an Internet of Things device);
however, the most prominent application of Hotmoka nodes is, at the
moment, the construction of blockchains whose nodes are Hotmoka nodes.

Every Hotmoka node has its own persistent state, that contains code and
objects. Since Hotmoka nodes are made for running Java code, the code
inside their state is kept in the standard jar format used by Java, while objects
are just a collection of values for their fields, with a class tag that identifies
whose class they belong to and a reference (the \emph{classpath}\index{classpath})
to the jar where that class is defined.
While a device of an Internet of Thing network is the sole responsible
for its own state, things are different if a Hotmoka node that is part of a blockchain.
There, the state is synchronized and identical across all nodes of the blockchain.

In object-oriented programming, the units of code that can be run
on an object are called \emph{methods}.
When a method must be run on an object,
that object is identified as the \emph{receiver}\index{receiver} of the execution of the method.
The same happens in Hotmoka. That is, when one wants to run a method
on an object, that object must have been already allocated
in the state of the node and must be marked as the receiver of the execution
of the method. Assume for instance that one wants to run a method
on the object in Fig.~\ref{fig:receiver_payer}, identified as receiver.
The code of the method is contained in a jar, previously installed in the state
of the node, and referred to as \emph{classpath}. This is the jar where the class of
the receiver is defined.

\begin{figure}[t]
  \begin{center}
    \begin{tikzpicture}[scale=0.5,>=Stealth]
      \draw[rounded corners] (0,0) rectangle (21,19.5) [fill=statebackgroundcolor];

      \draw[rounded corners] (0.5,16) rectangle +(20,2.8) [fill=jarbackgroundcolor];
      \draw (1,18) node[right] {jar: classes of the Takamaka runtime,};
      \draw (1,17) node[right] {including \ldots\texttt{ExternallyOwnedAccountED25519}};
      \draw (-2,18.2) node[left] {Takamaka code};
      \draw (-2,17.1) node[left] {at \texttt{\takamakaCodeShort{}}};
      \draw[->,thick] (-2,17.5) -- +(2.5,0);

      \draw[->,thick] (6,13.3) -- +(0,2.7);
      \draw (6,14.8) node[left] {dependency};

      \draw[rounded corners] (0.5,10.8) rectangle +(11,2.8) [fill=jarbackgroundcolor];
      \draw (1,12.7) node[right] {jar: code of some classes};
      \draw (1,11.7) node[right] {including \texttt{Person}};

      \draw[->,thick] (6,8.1) -- +(0,2.7);
      \draw (6,9.5) node[left] {classpath};

      \draw[rounded corners] (0.5,5.3) rectangle +(11,2.8) [fill=objectbackgroundcolor];
      \draw (1,6.7) node[right] {class tag: \texttt{Person.class}};
      \draw (-2,6.7) node[left] {receiver};
      \draw[->,thick] (-2,6.7) -- +(2.5,0);

      \draw[rounded corners] (0.5,0.5) rectangle +(20,4.3) [fill=objectbackgroundcolor];
      \draw (1,3.9) node[right] {class tag: \texttt{\ldots ExternallyOwnedAccountED25519}};
      \draw (1,2.65) node[right] {balance: \texttt{\accountOneBalance{}}};
      \draw (1,1.3) node[right] {publicKey: \texttt{\accountOnePublicKeyBaseSixtyfourShort{}}};

      \draw[->,thick] (17,4.8) -- +(0,11.2);
      \draw (17,12) node[left] {classpath};

      \draw (-2,3) node[left] {payer (account)};
      \draw (-2,2) node[left] {at \texttt{\accountOneShort{}}};
      \draw[->,thick] (-2,2.5) -- +(2.5,0);
    \end{tikzpicture}
  \end{center}
  \caption{Receiver, payer and classpath for a method call in a Hotmoka node.}
  \label{fig:receiver_payer}
\end{figure}

The main difference with standard object-oriented programming is that Hotmoka requires one
to specify a further object, called \emph{payer}\index{payer}. This is because a Hotmoka node is
a public service, that can be used by everyone has an internet connection
that can reach the node. Therefore, that service must be paid with the
internal cryptocurrency of the node, by providing a measure of execution
effort known as \emph{gas}\index{gas}. The payer is therefore a sort of bank account, whose
balance gets decreased in order to pay for the gas needed for the execution of the method.
The payer is accessible inside the method as its \emph{caller}.

\begin{commentbox}
There are many similarities with what happens in Ethereum: the notion of
receiver, payer and gas are taken from there. There are, however, also
big differences. The first is that the code of the methods is inside
a jar \emph{referenced} by the objects, while Ethereum requires to reinstall
the code of the contracts each time a contract is instantiated.
More importantly, Hotmoka keeps an explicit class tag inside the objects
(Fig.~\ref{fig:receiver_payer}),
while contracts are untyped in Ethereum~\cite{CrafaPZ19}
and are referenced through the untyped \texttt{address} type.
\end{commentbox}

Receiver and payer have different roles but same treatment in Hotmoka:
they are objects in state, stored at their respective state locations or
\emph{storage references}\index{storage reference}. For instance, the payer
might be allocated at \texttt{\accountOne}
(Fig.~\ref{fig:receiver_payer}). A storage reference has two parts, separated
by a \texttt{\#} sign. The first part are 64 hexadecimal digits (\ie, 32 bytes)
that identify the
transaction that created the object; the second part is a progressive number
that identifies an object created during that transaction: the first object
created during the transaction has progressive zero, the second has progressive
one, and so on. When a method is called on a Hotmoka node, what is actually specified
in the call request are the storage references of the receiver and of the payer
(plus the actual arguments to the method, if any).

Each object in the state of a Hotmoka node knows its \emph{classpath}\index{classpath},
that is, it holds a reference to the jar, already installed in the node,
that contains the compiled bytecode of the class of the object. For instance,
in Fig.~\ref{fig:receiver_payer}, the payer account is a Java object whose
class \texttt{io.takamaka.code.lang.ExternallyOwnedAccountED25519}
is defined in a jar referenced by the \emph{transaction reference}\index{transaction reference}
\texttt{\takamakaCode{}}.
Namely, in Hotmoka, a transaction\index{transaction} is either
%
\begin{enumerate}
\item the installation of a jar, that modifies the state of the node, and is paid by a payer account, or
\item the execution of a constructor, that yields the storage reference of a new object, or
\item the execution of a method on a receiver, that yields a returned
  value and/or has side-effects that modify the state of the node, and is paid by a payer account.
\end{enumerate}

A Hotmoka node keeps track
of the transactions that it has executed, so that it is possible, for instance,
to recreate its state by running all the transactions executed in the past, starting from
the empty state.

It is very important to discuss at this moment a significant difference with what
happens in Bitcoin, Ethereum and most other blockchains. There, an account
is not an object, nor a contract,
but just a key in the key/value store of the blockchain, whose value is its balance.
The key used for an account is typically computed by hashing the public key derived from
the private key of the account. In some sense, accounts, in those blockchains, exist
independently from the state of the blockchain and can be computed offline: just
create a random private key, compute the associated public key and hence its hash.
Hotmoka is radically different: an account\index{account} is an object that must be allocated in
state by an explicit construction transaction (that must be paid, as every transaction).
The public key is explicitly stored inside the constructed object
(base64-encoded in its \texttt{publicKey} field, see Fig.~\ref{fig:receiver_payer}).
That public key was passed as a parameter at the creation of the payer object and
can be passed again for creating more accounts. That is, it is well possible, in Hotmoka,
to have more accounts in the state of a node, all distinct, but controlled by the same key.
It is also possible to rotate the key of an account
(that is, replace it with another key), since the
\texttt{publicKey} field is not \texttt{final}.

This has a major consequence. In Bitcoin and Ethereum, an account is identified by
twelve words and a password, by using the BIP39 encoding\index{BIP39}
(see Fig.~5 and~6 of~\cite{Antonopoulos23}). These twelve words are just
a mnemonic representation of 132 bits: 128 bits for the random entropy used to derive the
private key of the account and four bits of checksum. In Hotmoka, these 128 bits are
not enough, since they identify the key of the account but not the 32 bytes of its
storage reference (in this representation, the progressive is assumed to be zero).
As a consequence, accounts in Hotmoka are identified by
128+256 bits, plus 12 bits of checksum (and a password),
which give rise to 36 words in BIP39 encoding.
By specifying those 36 words across different clients, one can control the
same account with all such clients. As usual, those 36 words must be stored in paper
and kept in a secure place, since their lost amounts to losing access to the account.

As shown in Fig.~\ref{fig:receiver_payer}, the code of the objects (contracts) installed in
the state of a Hotmoka node consists in jars (Java archives) written in a subset of Java
known as Takamaka. This is done in a way completely different from other blockchains:

\begin{enumerate}
\item In Hotmoka, programmers code the contracts that want to install in the node and nothing more;
  they do \emph{not} program the encoding of data into the
  key/value store of the node (its \emph{keeper},
  as it is called in other blockchains); they do \emph{not} program the gas metering;
  they do \emph{not}
  program the authentication of the accounts and the verification of their credentials.
  Everything is automatic in Hotmoka, exactly as in Ethereum, and differently from other blockchains
  that use general purpose languages such as Java for their smart contracts: there, programmers
  must take care of all these details, which is difficult, boring and error-prone. If this is done
  incorrectly, those blockchains will hang.
\item In Hotmoka, the code installed in the node passes
  a preliminary verification\index{code verification}, that checks the correct
  use of some primitives, that we will introduce in the subsequent chapters, and guarantees that the
  code is deterministic. This excludes an array of errors in Hotmoka, while other blockchains
  will hang if, for instance, the code is non-deterministic.
\end{enumerate}

\section{Hotmoka clients}\label{sec:hotmoka_clients}

In order to query a Hotmoka node, handle accounts and run transactions on the node,
one needs a client application. Currently, there is a command-line client, called
moka\index{moka} and a mobile client for Android, called Mokito\index{Mokito}. Mokito provides
basic functionalities only (handling accounts, querying the state of the objects in the node,
running simple transactions), while moka is the most complete solution.

\subsection{Moka}\label{subsec:moka}

You can use the moka tool to interact with an existing Hotmoka node,
install code in the node and run transactions. There are two ways of using moka.
You can either use moka inside a docker container provided by the Hotmoka developers.
Or you can download its source code, compile it and add the moka executable to
the command path of your machine. This latter approach is more flexible but requires to have
Java JDK version 21 (or higher) installed in your
computer, along with a recent version of Maven. The former approach avoids to install
and compile software on your machine, beyond having docker installed of course.
Moreover, many operations become ackward with docker, because, for instance, files
created inside a docker container remain there, unless explicitly copied out of there.
Both alternatives are described in the following paragraphs, but
our suggested solution is to compile and install moka in your machine.

\subsubsection{Invoking moka from inside a docker container}
\label{subsubsec:moka_inside_docker}

There are a few docker containers\index{docker!Hotmoka containers} providing moka and all the machinery
for running Hotmoka nodes. They are maintained in DockerHub~\cite{hotmoka_dockerhub}.
For instance, you can query the provided version of moka as follows:
%
\input{docker_run_moka_command}
%
You should see \texttt{\hotmokaVersion{}} answered on the screen.
You do need Java nor Maven for this, nor to compile anything: docker will take care
of downloading the image of the container and run moka inside it.

You can also contact an existing Hotmoka node and query the current state of an object,
allocated at a given storage reference, such as the payer account
of Fig.~\ref{fig:receiver_payer}:
%
\input{docker_run_moka_objects_show_account1_command}
%
The output will be something like:
%
\input{docker_run_moka_objects_show_account1_output}
%
Note that the classpath (the \emph{jar installed at\ldots}) corresponds to
what reported in Fig.~\ref{fig:receiver_payer}, since it is an immutable
property of an object.

\subsubsection{Invoking moka in the local machine}
\label{subsubsec:moka_local}

In order to invoke moka directly, in the local machine, one needs to download
its code, compile it and extend the path of the shell so that it finds the compiled code.
Below, it is shown how to perform this on a Linux machine.

Let us install the code in the \verb|~/Gits| directory of our machine, with the
following sequence of commands. We assume that you have both Git and Maven
installed already:
%
\input{install_moka_command}
%
Then edit your \texttt{.bashrc} configuration file and add at its end
the following command, that expands the command path of the shell:
%
\input{export_path_moka_command}
%
Exit the terminal and spawn a new one. You should be able to run moka directly now.
For instance, you can run the same commands of Sec.~\ref{subsubsec:moka_inside_docker}, but
without the help of docker:
%
\index{moka!version@{\texttt{version}}}
\input{moka_version_command}
%
and
%
\index{moka!objects show@{\texttt{objects show}}}
\input{moka_objects_show_account1_command}

In the rest of this book, we will normally show direct invocations
of moka, outside of a docker container.
Remember, however, that you can also run it from inside its docker container if you prefer.

\subsubsection{Getting help about moka's commands}
\label{subsubsec:moka_help}

If you want help about the commands of moka, just use the \texttt{help} command.
Namely, \texttt{moka help} will print on the screen the following help lines:
%
\index{moka!help@{\texttt{help}}}
\input{moka_help_output}
%
You can see that commands are organized in groups. You can get help about a specific
group by prefixing \texttt{help} to the name of the group. For instance, the
\texttt{moka help objects} command will print:
%
\input{moka_help_objects_output}
%
You can print the help of a specific leaf command by prefixing \texttt{help} before it.
For instance, the command \texttt{moka objects help show} will show information about the
\texttt{show} subcommand of the \texttt{objects} group of commands of moka. It will print:
%
\input{moka_objects_help_show_output}

\subsection{Mokito}\label{subsec:mokito}

The moka tool allows one to perform a large variety of operations
on a Hotmoka node. However, it is a technical tool, meant for developers.
Most users will only perform simple tasks with a Hotmoka node.
For them, it is simpler to use a mobile app, with a simpler user
interface. Such an app, called Mokito\index{Mokito}, is currently available for Android only.
You can download it from Google Play and install it in your device, from~\cite{mokito_google_play}.
Its Kotlin source code is available at~\cite{mokito_github},
together with a small Android service for connecting to a remote Hotmoka node.

The first time you will use Mokito on your mobile device,
it will connect by default to a testnet Hotmoka node
and show the screen in Fig.~\ref{fig:mokito_start}. The server can be changed
in the preferences section of the app, accessible through the menu in the
top left area of the app.
%
\begin{figure}[t]
  \begin{center}
    \includegraphics[width=5cm]{pics/mokito_start}
  \end{center}
  \caption{The starting screen of the Mokito app.}
  \label{fig:mokito_start}
\end{figure}
%
You can see in Fig.~\ref{fig:mokito_start} that Mokito shows a \emph{faucet account}\index{faucet},
that only exists in test networks and that can be used for funding the creation
of new accounts. We will do this with moka in the next section, but you
can do it from Mokito as well. In Mokito, you can also create keys, pay to keys,
show the manifest of the contacted node, show and navigate  objects in the state of the node.
This should all be intuitive.

\section{Contacting a Hotmoka node}\label{sec:contacting_node}

The examples in this book must be run against a Hotmoka node,
typically part of a Hotmoka blockchain. We will show you in a later chapter how you
can install your own local
node or blockchain. However, for now, it is much simpler to experiment with a node
that is part of one of the public
test blockchains that we provide for experimentation.
Namely, we have installed two Hotmoka nodes for testing, of two distinct blockchains, at URIs
\texttt{\serverMokamint{}} and \texttt{\serverTendermint{}}, respectively.
The peculiarity of these nodes is that they include a \emph{faucet}\index{faucet}, that is,
an account that gives
away small amounts of coins, when requested. This is good for experimentation
but, of course, a real node will not include a faucet.
In a real node, people must grasp some coins because they have been earned through mining,
sent by some other user or bought from some exchange.

You can verify that you can contact the test node by typing
the command \texttt{moka nodes manifest show -{}-uri \serverMokamint}
to print the \emph{manifest}\index{manifest} of the Hotmoka node
at \texttt{\serverMokamint}. The result should be something like:
%
\input{moka_nodes_manifest_show_output}
%
The details of this information are irrelevant for now, but something must be
clarified, to better understand the following sections.
Namely, the \texttt{moka nodes manifest show} command reports information
that tells us that the node
already contains some code and some Java objects, as shown in Fig.~\ref{fig:manifest}.
%
\begin{figure}[t]
  \begin{center}
    \begin{tikzpicture}[scale=0.5,>=Stealth]
      \draw[rounded corners] (0,-4.5) rectangle (21,19.5) [fill=statebackgroundcolor];

      \draw[rounded corners] (0.5,16) rectangle +(20,2.8) [fill=jarbackgroundcolor];
      \draw (1,18) node[right] {jar: classes of the Takamaka runtime, such as};
      \draw (1,17) node[right] {\texttt{Contract}, \texttt{Storage}, \texttt{@View}, \texttt{@FromContract}\ldots};
      \draw (-2,18.2) node[left] {Takamaka code};
      \draw (-2,17.1) node[left] {at \texttt{\takamakaCodeShort{}}};
      \draw[->,thick] (-2,17.5) -- +(2.5,0);

      \draw[->,thick] (6,13.3) -- +(0,2.7);
      \draw (6,14.8) node[left] {classpath};
      \draw (-2,12.8) node[left] {manifest};
      \draw (-2,11.7) node[left] {at \texttt{\manifestShort{}}};
      \draw[->,thick] (-2,12.3) -- +(2.5,0);

      \draw[rounded corners] (0.5,10.8) rectangle +(11,2.8) [fill=objectbackgroundcolor];
      \draw (1,12.7) node[right] {chainId: \chainId{}};
      \draw (1,11.7) node[right] {signature: ed25519};

      \draw[<-,thick] (4,8.1) -- +(0,2.7);
      \draw (4,9.5) node[right] {gamete};
      \draw[->,thick] (2,10.8) .. controls (2,5) .. node[very near start,sloped,above] {\small gas station} (3,3.8);
      \draw[->,thick] (1,10.8) .. controls (1,2) .. node[near end,sloped,below] {\small validators} (1.5,-1.2);

      \draw[rounded corners] (3,5.3) rectangle +(8,2.8) [fill=objectbackgroundcolor];
      \draw (3.5,6.7) node[right] {balance: 9999\ldots};
      \draw (-2,7.2) node[left] {gamete};
      \draw (-2,6.1) node[left] {at \texttt{\gameteShort{}}};
      \draw[->,thick] (-2,6.7) -- +(5,0);
      \draw[->,thick] (10,8.1) .. controls (12,11) .. node[near end,sloped,below] {classpath} (12,16.1);

      \draw[rounded corners] (2,1) rectangle +(8,2.8) [fill=objectbackgroundcolor];
      \draw (2.5,2.5) node[right] {gasPrice: 1};
      \draw (-2,3) node[left] {gas station};
      \draw (-2,2) node[left] {at \texttt{\gasStationShort{}}};
      \draw[->,thick] (-2,2.5) -- +(4,0);
      \draw[->,thick] (9,3.8) .. controls (13,6) .. node[near end,sloped,below] {classpath} (13,16.1);

      \draw[rounded corners] (0.5,-4) rectangle +(10.5,2.8) [fill=objectbackgroundcolor];
      \draw (1,-2) node[right] {number of validators: 0};
      \draw (1,-3.1) node[right] {current supply: 1209\ldots};
      \draw (-2,-2) node[left] {validators};
      \draw (-2,-3) node[left] {at \texttt{\validatorsShort{}}};
      \draw[->,thick] (-2,-2.5) -- +(2.5,0);
      \draw[->,thick] (9.5,-1.2) .. controls (14,5) .. node[near end,sloped,below] {classpath} (14,16.1);
    \end{tikzpicture}
  \end{center}

  \caption{Manifest, gamete, gas station and validators.}
  \label{fig:manifest}
\end{figure}
%
The Takamaka code reference is the pointer to a jar, installed in blockchain, that contains
the classes of the Takamaka language runtime. All programs that we will write in Takamaka
will depend on that jar, directly or indirectly, since they will use classes such
as \texttt{io.takamaka.code.lang.Contract} or annotations such as
\texttt{io.takamaka.code.lang.View}.
The manifest reference, instead, points to a Java object that publishes
information about the node. Namely, it reports its chain identifier and
the signature algorithm that, by default, is used to sign the transactions
for the node. The manifest refers
to another object, called \emph{gamete}\index{gamete}, that is an account holding all the initial
coins, if any. Consequently, the gamete may have a rich balance property,
but also another interesting property, called \emph{max faucet}, that states how much coins
the faucet
is willing to give up for free at each transaction. In a real node, and differently from here,
that value should be zero. In this test network, instead, it is a non-zero value
that we will exploit for creating our first account, in
a moment. The manifest refers also to a gas station\index{gas station},
that it, to another Java object that provides
information about the gas\index{gas}, such as its current price. Finally, the manifest refers
to another Java object, called \emph{validators}\index{validators}, that keeps information about
the validator nodes of the network, if the network has validators:
in the case of \texttt{\serverMokamint{}} there are no validators, since that network
is based on a completely decentralized proof of space consensus, without special validator nodes.
The validators object contains, in any case, also the initial,
current and final supply of cryptocurrency
(how much cryptocurrency was minted at the beginning of the network,
has much has been minted up to now, and how much will exist eventually).

As we said before, Java objects in the Hotmoka node are identified by their
storage reference, such as \texttt{\gasStation}.
You can think at a storage reference as a machine-independent pointer inside the
memory, or state, of the node.

We have used the moka command to see the manifest of a node. You can also use the
Mokito app for that. Namely, tap on the app menu icon on the top-left corner of the screen
and select \emph{Manifest} from the menu that will appear (see Fig.~\ref{fig:mokito_menu}).
%
\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.45\linewidth]{pics/mokito_menu}
  \caption{The menu of the Mokito app.}
  \label{fig:mokito_menu}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.45\linewidth]{pics/mokito_manifest}
  \caption{The manifest of the Hotmoka node.}
  \label{fig:mokito_manifest}
\end{subfigure}
\caption{From the top-level corner menu of Mokito, it is possible to select the \emph{Manifest} item to show the manifest of the Hotmoka node.}
\end{figure}
%
After tapping on \emph{Manifest}, a new screen will appear, containing the same information
that we saw with the command \texttt{moka nodes manifest show} (see Fig.~\ref{fig:mokito_manifest}).

\section{Creation of a first account}\label{sec:creation_account}

We need an account\index{account} in the test network, that we will use later to pay for
installing code in blockchain and for running transactions. An account in Hotmoka
is something completely different from an account in other blockchains.
For instance, in Bitcoin and Ethereum, accounts do not really exist, in the sense
that they are just an address derived from a private key, that can be used to control
information in blockchain. Their creation does not trigger any operation in blockchain:
it is performed completely off-chain. Instead, in Hotmoka, an account
is a Java object, more precisely an instance of the
\texttt{io.takamaka.code.lang.ExternallyOwnedAccount}
class. That object must be allocated (\emph{created}) in the memory of the Hotmoka node,
before it can be used. Moreover, such an object is not special in any way:
for instance, as for all other objects in the storage of the node, we must pay for its creation.
Currently, we have no accounts and consequently
no coins for paying the creation of a new object. We could
earn coins by mining for the network, or as payment for some activity,
or by buying coins at an exchange.
Since this is a test network, we can more simply use the faucet\index{faucet} of the gamete instead,
that is willing
to send us up to \maxFaucet{} coins, for free. Namely, you can run the
following commands in order to create a key pair and then ask the faucet
to create your first externally owned account for that key pair,
funded with 50000000000000 coins, initially, paid by the faucet. Execute the following commands
inside a \texttt{\hotmokaTutorialDir{}} directory of your home, so that moka
will save the key pair of your account
there, which will simplify your subsequent work:
%
\index{moka!keys create@{\texttt{keys create}}}
\input{moka_keys_create_account1_command}\index{key!creation}
\input{moka_keys_create_account1_output}
%
\begin{commentbox}
  We used \texttt{chocolate} as password of the new key pair.
  You can use your preferred password instead, or just leave it blank.
  In any case, you should be consistent to use the same password later,
  when we'll use the key pair.
\end{commentbox}
%
We can now create an account that uses the key pair, letting the faucet pay for it:\index{faucet}
%
\index{moka!accounts create@{\texttt{accounts create}}}
\input{moka_accounts_create_account1_command}\index{account!creation}
\input{moka_accounts_create_account1_output}
%
Storage reference \texttt{\accountOne} refers to the newly created account object.
%
\begin{commentbox}
  This reference will be different in your machine.
\end{commentbox}
%
This storage reference is a machine-independent pointer to your account Java object, inside
the node. Moreover, a random sequence of bits, called \emph{entropy}, has been generated
and saved into a \texttt{.pem} file. From that entropy, and the chosen password, it is possible
to derive private and (hence) public key of the account. This is why we use
\emph{key pair} to refer to such \texttt{.pem} file.
You should keep the \texttt{.pem} file secret since, together with the
password of the account (in our case, we have chosen \texttt{chocolate}),
it allows its owner to control your account and spend its coins.
Note that the password is not written anywhere: if you lose it, it cannot be recovered.

Let us check that our account really exists,
by querying the node about the state of the object allocated at \texttt{\accountOne}:
%
\index{moka!objects show@{\texttt{objects show}}}
\input{moka_objects_show_account1_command}
\input{moka_objects_show_account1_output}
%
Note that the balance and the public key of the account are
fields of the account object. Moreover, note that Hotmoka knows
which is the class of the object at that address
(it is a class named \texttt{io.takamaka.code.lang.ExternallyOwnedAccountED25519})
and where that class is defined: inside the jar
at \texttt{\takamakaCode}, that is, the jar that defines
the basic Takamaka classes (Fig.~\ref{fig:manifest}).
We will call \emph{Takamaka code} that address.

\begin{commentbox}
This is completely different from what happens, for instance,
in Ethereum, where externally owned accounts and contract references and untyped at run time,
so that it is not possible to reconstruct their class in a reliable way.
Moreover, note that we have been able to create an object in blockchain
without sending the bytecode for its code: that bytecode was
already installed, at Takamaka code, and we do not
need to repeat it every time we instantiate an object. Instead, the new object
will refer to the jar that contains its bytecode.
\end{commentbox}

In the following, you can use the \texttt{moka objects show} command on any object,
not just on your own accounts, whenever you want to inspect its state
(that includes the state inherited from its superclasses).

\begin{figure}[t]
  \begin{center}
    \begin{tikzpicture}[scale=0.5,>=Stealth]
      \draw[rounded corners] (0,-9) rectangle (21,19.3) [fill=statebackgroundcolor];

      \draw[rounded corners] (0.5,16) rectangle +(20,2.8) [fill=jarbackgroundcolor];
      \draw (1,18) node[right] {jar: classes of the Takamaka runtime, such as};
      \draw (1,17) node[right] {\texttt{Contract}, \texttt{Storage}, \texttt{@View}, \texttt{@FromContract}\ldots};
      \draw (-2,18.2) node[left] {Takamaka code};
      \draw (-2,17.1) node[left] {at \texttt{\takamakaCodeShort{}}};
      \draw[->,thick] (-2,17.5) -- +(2.5,0);

      \draw[->,thick] (6,13.3) -- +(0,2.7);
      \draw (6,14.8) node[left] {classpath};
      \draw (-2,12.8) node[left] {manifest};
      \draw (-2,11.7) node[left] {at \texttt{\manifestShort{}}};
      \draw[->,thick] (-2,12.3) -- +(2.5,0);

      \draw[rounded corners] (0.5,10.8) rectangle +(11,2.8) [fill=objectbackgroundcolor];
      \draw (1,12.7) node[right] {chainId: \chainId{}};
      \draw (1,11.7) node[right] {signature: ed25519};

      \draw[<-,thick] (4,8.1) -- +(0,2.7);
      \draw (4,9.5) node[right] {gamete};
      \draw[->,thick] (2,10.8) .. controls (2,5) .. node[very near start,sloped,above] {\small gas station} (3,3.8);
      \draw[->,thick] (1,10.8) .. controls (1,2) .. node[near end,sloped,below] {\small validators} (1.5,-1.2);

      \draw[rounded corners] (3,5.3) rectangle +(8,2.8) [fill=objectbackgroundcolor];
      \draw (3.5,6.7) node[right] {balance: 9999\ldots};
      \draw (-2,7.2) node[left] {gamete};
      \draw (-2,6.1) node[left] {at \texttt{\gameteShort{}}};
      \draw[->,thick] (-2,6.7) -- +(5,0);
      \draw[->,thick] (10,8.1) .. controls (12,11) .. node[near end,sloped,below] {classpath} (12,16.1);

      \draw[rounded corners] (2,1) rectangle +(8,2.8) [fill=objectbackgroundcolor];
      \draw (2.5,2.5) node[right] {gasPrice: 1};
      \draw (-2,3) node[left] {gas station};
      \draw (-2,2) node[left] {at \texttt{\gasStationShort{}}};
      \draw[->,thick] (-2,2.5) -- +(4,0);
      \draw[->,thick] (9,3.8) .. controls (13,6) .. node[near end,sloped,below] {classpath} (13,16.1);

      \draw[rounded corners] (0.5,-4) rectangle +(10.5,2.8) [fill=objectbackgroundcolor];
      \draw (1,-2) node[right] {number of validators: 0};
      \draw (1,-3.1) node[right] {current supply: 1209\ldots};
      \draw (-2,-2) node[left] {validators};
      \draw (-2,-3) node[left] {at \texttt{\validatorsShort{}}};
      \draw[->,thick] (-2,-2.5) -- +(2.5,0);
      \draw[->,thick] (9.5,-1.2) .. controls (14,5) .. node[near end,sloped,below] {classpath} (14,16.1);

      \draw[rounded corners] (3,-8.5) rectangle +(11,2.8) [fill=objectbackgroundcolor];
      \draw (3.5,-7) node[right] {balance: \accountOneBalance};
      \draw (-2,-6.6) node[left] {account1};
      \draw (-2,-7.7) node[left] {at \texttt{\accountOneShort{}}};
      \draw[->,thick] (-2,-7) -- +(5,0);
      \draw[->,thick] (10,-5.7) .. controls (15,0) .. node[near end,sloped,below] {classpath} (15,16.1);
    \end{tikzpicture}
  \end{center}

  \caption{The state of the network nodes after the creation of our new account.}
  \label{fig:state_with_account}
\end{figure}

Fig.~\ref{fig:state_with_account}
shows the state of the network nodes after the creation of our new account.
Since out test node is part of a blockchain, it is not only its state that has been modified,
but also that of all nodes that are part of that blockchain.

Whenever your account will run out of coins, you can recharge it with the
\texttt{moka send} command, by using, again, the faucet as source of coins. Namely,
if you want to recharge your account with \accountOneRecharge{} extra coins, you can type:
%
\index{moka!accounts send@{\texttt{accounts send}}}
\input{moka_accounts_send_account1_command}
\input{moka_accounts_send_account1_output}
%
You can then use the \texttt{moka objects show} command to verify that the balance of
your account has been actually increased with \accountOneRecharge{} extra coins.

The creation of a new account from the faucet is possible from the Mokito app as well.
Namely, use the menu of the app to tap on the \emph{Accounts} item to see the
list of available accounts (Fig.~\ref{fig:mokito_start}). From there, tap on the
menu icon on the right of the \emph{Faucet} account and select \emph{Create a new account}
(see Fig.~\ref{fig:mokito_new_account}).
%
\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.45\linewidth]{pics/mokito_new_account}
  \caption{The menu for creating a new account.}
  \label{fig:mokito_new_account}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.45\linewidth]{pics/mokito_elvis_new_account}
  \caption{The form specifying a new account Elvis.}
  \label{fig:mokito_elvis_new_account}
\end{subfigure}
\caption{From the contextual menu of the faucet account in Mokito, it is possible to require the creation of a new account, by specifying its name, password and initial balance.}
\end{figure}
%
A form will appear, where you can specify the
name for the account, its password and the initial balance (that will be paid by the faucet).
For instance, you can fill it as in Fig.~\ref{fig:mokito_elvis_new_account}.
%
\begin{commentbox}
The name of the accounts is a feature of Mokito to simplify the identification
of the accounts. However, keep in mind that accounts have no name in Hotmoka: they
are just identified by their storage reference. For instance, moka currently does not
allow one to associate names to accounts.
\end{commentbox}
%
After tapping on the \emph{Create new account} button, the new account will be created and
its information will be shown, as in Fig.~\ref{fig:mokito_show_elvis}.
Note, in this screen, the storage reference of the new account
and the presence of a 36 words passphrase.
%
\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.45\linewidth]{pics/mokito_show_elvis}
  \caption{The new account Elvis.}
  \label{fig:mokito_show_account}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.45\linewidth]{pics/mokito_added_elvis}
  \caption{Elvis added to the list of accounts.}
  \label{fig:mokito_added_elvis}
\end{subfigure}
\caption{The new account is identified by its BIP39 passphrase. After its creation, it is added to the list of accounts in Mokito.}
\end{figure}
%
If you go back to the accounts screen (by using the top-left menu of Mokito),
you will see that Elvis
has been added to your accounts (see Fig.~\ref{fig:mokito_added_elvis}).

\section{Importing accounts}\label{sec:importing_accounts}\index{account!import}

We have created \texttt{\accountOneShort{}} with moka and
\texttt{\accountMokitoShort{}} with Mokito. We might want to \emph{import} the former in Mokito
and the latter in moka, so that we can operate on both accounts with both tools. In order to import
\texttt{\accountMokitoShort{}} in moka, we can use the \texttt{moka accounts import} command
and insert its 36 words passphrase from Fig.~\ref{fig:mokito_show_elvis}:
%
\index{moka!accounts import@{\texttt{accounts import}}}
\input{moka_accounts_import_account_mokito_command}
\input{moka_accounts_import_account_mokito_output}
%
After that, it is possible to control that account with moka (if we remember
its password, that is, \texttt{chocolate}).
%
\begin{figure}[t]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.45\linewidth]{pics/mokito_accounts_menu}
  \caption{The menu of the accounts screen.}
  \label{fig:mokito_accounts_menu}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.45\linewidth]{pics/mokito_insert_passphrase}
  \caption{Inserting the 36 words passphrase in Mokito.}
  \label{fig:mokito_insert_passphrase}
\end{subfigure}
\caption{In order to import an account in Mokito the top-right menu of the accounts screen allows one to insert the passphrase that identifies the account to import and its password.}
\end{figure}
%
\begin{figure}[t]
  \begin{center}
    \includegraphics[width=5cm]{pics/mokito_added_the_boss}
  \end{center}
  \caption{The new account The Boss has been imported.}
  \label{fig:mokito_added_the_boss}
\end{figure}

Vice versa, in order to import into Mokito the account that was created with moka,
first export\index{account!export} the 36 words of that account:
%
\index{moka!accounts export@{\texttt{accounts export}}}
\input{moka_accounts_export_account1_command}
\input{moka_accounts_export_account1_output}
%
Then go to the accounts page of Mokito and show the
top-right menu of the accounts page; select \emph{Import account}
(see Fig.~\ref{fig:mokito_accounts_menu}).
In the screen that will appear, insert the name that you want to give to the account,
its password and its 36 words passphrase
(Fig.~\ref{fig:mokito_insert_passphrase}).
Tap on the \emph{Import Account} button\index{account!import}.
The new account will show in the list of
available accounts (Fig.~\ref{fig:mokito_added_the_boss}). From this moment,
it will be possible to control the account from Mokito.

\begin{commentbox}
The 36 words of an account are enough for moving accounts around
different clients. Note that clients do not \emph{contain} accounts
but only the cryptographic information
needed to access the accounts. If a client is uninstalled,
the accounts that it used still exist in the remote
Hotmoka node and can still be re-imported and used
in some other client, if we have written down their 36 words.
\end{commentbox}

\section{Anonymous payments}\label{sec:anonymous_payments}

The fact that accounts in Hotmoka are not just identified by their public key, but also by their
storage reference inside the state of a node, makes it a bit more difficult, but not impossible,
to execute anonymous transactions. We do not advocate the use of anonymity here, but it is true
that, sometimes, one wants to remain anonymous and still receive a payment.\index{payment!anonymous}

\begin{commentbox}
Anonymity is often used for illegal actions such as ransomware and blackmailing.
We are against such actions. This section simply shows that anonymity can be achieved
in Hotmoka as well, although it is a bit harder than with other blockchains.
\end{commentbox}

Suppose for instance that somebody, whom we call Anonymous, wants to receive from us a payment
of $\sentToAnonymous{}$ coins,
but still wants to remain unknown. He can receive the payment in many ways:

\begin{enumerate}
\item\label{enum:anonymous_1} He could send us an anonymous email asking us to pay to a specific account, already existing
   in the state of the node. But this is not anonymous, since, in Hotmoka, an account is an object
   and there must have been a transaction that created that object, whose payer is likely to be
   Anonymous or somebody in his clique. That is, this allows one to infer something
   about the identity of Anonymous. Therefore, Anonymous would probably discard this possibility.
 \item\label{enum:anonymous_2} He could send us an anonymous email asking
   us to create a new account with a given public key, whose associated
   private key he controls, and to charge it with $\sentToAnonymous{}$ coins.
   After that, we are expected
   to send him an email where we notify him the storage reference where
   \texttt{moka accounts create} has allocated the account. But this means that we must know his
   email address, which is definitely against the idea of anonymity. Therefore,
   Anonymous discards this possibility as well.
\item He could send us an anonymous email asking us \emph{to pay to a given public key}\index{payment!to key}, whose
   associated private key he controls.
   After we pay to that key, he autonomously and anonymously recovers the storage reference of the
   resulting account, without any interaction with us. This is definitely anonymous and that is
   the technique that Anonymous will choose.
\end{enumerate}

Let us show how the third possibility works. Anonymous starts by creating a new private/public key,
exactly as we did before:
%
\index{moka!keys create@{\texttt{keys create}}}
\input{moka_keys_create_anonymous_command}
\input{moka_keys_create_anonymous_output}
%
\begin{commentbox}
  Note that there is no \texttt{-{}-uri} part in the \texttt{moka keys create} command,
  since this operation
  runs completely off-line: no object gets created in the state of any Hotmoka node for now.
\end{commentbox}
%
Anonymous pastes the new key into an anonymous email message and sends it to us:
%
\begin{center}
  {\small\begin{alltt}
    Please pay \sentToAnonymous{} coins to the key \publicKeyBaseFifthyeightAnonymous{}.    
  \end{alltt}}
\end{center}
%
Once we receive that email, we use (for instance) our previous account
to send $\sentToAnonymous{}$ coins to that key:
%
\index{moka!accounts send@{\texttt{accounts send}}}
\input{moka_accounts_send_account1_anonymous_command}\index{account!payment}\index{payment!to account}
\input{moka_accounts_send_account1_anonymous_output}
%
And that's all! No interaction is needed with Anonymous. He will check
from time to time to see if we have paid, by running the command \texttt{moka keys bind}\index{key!binding}
until it succeeds. First attempt:
%
\index{moka!keys bind@{\texttt{keys bind}}}
\input{moka_keys_bind_anonymous_command}
\input{moka_keys_bind_anonymous_not_yet_output}
%
Second attempt:
%
\input{moka_keys_bind_anonymous_command}
\input{moka_keys_bind_anonymous_not_yet_output}
%
The command finally succeds at the third attempt (for instance):
%
\input{moka_keys_bind_anonymous_command}
\input{moka_keys_bind_anonymous_output}
%
Once \texttt{moka keys bind} succeeds, Anonymous can enjoy his brand new account, that he
can control with the \texttt{kiwis} password.

So how does that work? The answer is that the \texttt{moka accounts send} command
creates the account \texttt{\accountAnonymous{}} with the public key of
Anonymous inside it, so that Anonymous will be able to control that account.
But there is more: that command
also associates the public key of the account to the account itself,
inside a hash map contained in the manifest of the node,
called \emph{accounts ledger}\index{accounts ledger}.
The \texttt{moka keys bind} command simply consults the
accounts ledger, to see if somebody has already bound an account to that public key.

\begin{commentbox}
If, inside the accounts ledger, there is an account \emph{A} already associated to the
public key chosen by Anonymous,
then the \texttt{moka accounts send} command will not create a new account but will increase the
balance of \emph{A} and the \texttt{moka keys bind} command will consequently yield \emph{A}.
This is a security measure in order
to avoid payment disruptions due to the association of dummy accounts to some keys
or to repeated payments to the same key.
In any case, the public key of \emph{A} can only be that chosen by Anonymous,
since the accounts ledger
enforces that constraint when it gets populated with accounts:
if somebody associates a key \emph{K} to an account \emph{A}, then the public key
contained inside \emph{A} must be \emph{K}.
\end{commentbox}

Anonymous payments are possible with Mokito as well. Namely, that client
allows one to create a key and pay to a key. We do not show the details here, but the
app interface should be simple enough to perform such operation.

Should one use anonymous payments, always? The answer is no, since
anonymity comes with an extra gas cost: that for modifying the accounts ledger.
If there is no explicit need for anonymity, it is cheaper to receive payments
as described in points~\ref{enum:anonymous_1}
and~\ref{enum:anonymous_2} above, probably without the need of anonymous emails.