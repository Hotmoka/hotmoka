\chapter{Getting started with Hotmoka}\label{ch:getting_started_with_hotmoka}

\section{Hotmoka in a nutshell}\label{hotmoka_in_a_nutshell}

Hotmoka is the abstract definition of a device that can store
objects (data structures) in its persistent memory (its \emph{state} or \emph{storage})
and can execute, on those objects,
code written in a subset of Java called Takamaka. Such a device is
called a \emph{Hotmoka node} and such programs are known as
\emph{smart contracts}, taking that terminology from programs that run inside
a blockchain. It is well true that Hotmoka nodes can be different from the nodes
of a blockchain (for instance, they can be an Internet of Things device);
however, the most prominent application of Hotmoka nodes is, at the
moment, the construction of blockchains whose nodes are Hotmoka nodes.

Every Hotmoka node has its own persistent state, that contains code and
objects. Since Hotmoka nodes are made for running Java code, the code
inside their state is kept in the standard jar format used by Java, while objects
are just a collection of values for their fields, with a class tag that identifies
whose class they belong to and a reference (the \emph{classpath})
to the jar where that class is defined.
While a device of an Internet of Thing network is the sole responsible
for its own state, things are different if a Hotmoka node that is part of a blockchain.
There, the state is synchronized and identical across all nodes of the blockchain.

In object-oriented programming, the units of code that can be run
on an object are called \emph{methods}.
When a method must be run on an object,
that object is identified as the \emph{receiver} of the execution of the method.
The same happens in Hotmoka. That is, when one wants to run a method
on an object, that object must have been already allocated
in the state of the node and must be marked as the receiver of the execution
of the method. Assume for instance that one wants to run a method
on the object in Fig.~\ref{fig:receiver_payer}, identified as receiver.
The code of the method is contained in a jar, previously installed in the state
of the node, and referred to as \emph{classpath}. This is the jar where the class of
the receiver is defined.

\begin{figure}
  \begin{center}
    \begin{tikzpicture}[scale=0.5,>=Stealth]
      \draw[rounded corners] (0,0) rectangle (21,19.5) [fill=statebackgroundcolor];

      \draw[rounded corners] (0.5,16) rectangle +(20,2.8) [fill=jarbackgroundcolor];
      \draw (1,18) node[right] {jar: classes of the Takamaka runtime,};
      \draw (1,17) node[right] {including \ldots\texttt{ExternallyOwnedAccountED25519}};
      \draw (-2,18.2) node[left] {Takamaka code};
      \draw (-2,17.1) node[left] {at \texttt{\takamakaCodeShort{}}};
      \draw[->,thick] (-2,17.5) -- +(2.5,0);

      \draw[->,thick] (6,13.3) -- +(0,2.7);
      \draw (6,14.8) node[left] {dependency};

      \draw[rounded corners] (0.5,10.8) rectangle +(11,2.8) [fill=jarbackgroundcolor];
      \draw (1,12.7) node[right] {jar: code of some classes};
      \draw (1,11.7) node[right] {including \texttt{Person}};

      \draw[->,thick] (6,8.1) -- +(0,2.7);
      \draw (6,9.5) node[left] {classpath};

      \draw[rounded corners] (0.5,5.3) rectangle +(11,2.8) [fill=objectbackgroundcolor];
      \draw (1,6.7) node[right] {class tag: \texttt{Person.class}};
      \draw (-2,6.7) node[left] {receiver};
      \draw[->,thick] (-2,6.7) -- +(2.5,0);

      \draw[rounded corners] (0.5,0.5) rectangle +(20,4.3) [fill=objectbackgroundcolor];
      \draw (1,3.9) node[right] {class tag: \texttt{\ldots ExternallyOwnedAccountED25519}};
      \draw (1,2.65) node[right] {balance: \texttt{\accountOneBalance{}}};
      \draw (1,1.3) node[right] {publicKey: \texttt{\accountOnePublicKeyBaseSixtyfourShort{}}};

      \draw[->,thick] (17,4.8) -- +(0,11.2);
      \draw (17,12) node[left] {classpath};

      \draw (-2,3) node[left] {payer (account)};
      \draw (-2,2) node[left] {at \texttt{\accountOneShort{}}};
      \draw[->,thick] (-2,2.5) -- +(2.5,0);

    \end{tikzpicture}
  \end{center}
  \caption{Receiver, payer and classpath for a method call in a Hotmoka node.}
  \label{fig:receiver_payer}
\end{figure}

The main difference with standard object-oriented programming is that Hotmoka requires one
to specify a further object, called \emph{payer}. This is because a Hotmoka node is
a public service, that can be used by everyone has an internet connection
that can reach the node. Therefore, that service must be paid with the
internal cryptocurrency of the node, by providing a measure of execution
effort known as \emph{gas}. The payer is therefore a sort of bank account, whose
balance gets decreased in order to pay for the gas needed for the execution of the method.
The payer is accessible inside the method as its \emph{caller}.

\begin{commentbox}
There are many similarities with what happens in Ethereum: the notion of
receiver, payer and gas are taken from there. There are, however, also
big differences. The first is that the code of the methods is inside
a jar \emph{referenced} by the objects, while Ethereum requires to reinstall
the code of the contracts each time a contract is instantiated.
More importantly, Hotmoka keeps an explicit class tag inside the objects
(Fig.~\ref{fig:receiver_payer}),
while contracts are untyped in Ethereum~\cite{CrafaPZ19}
and are referenced through the untyped \texttt{address} type.
\end{commentbox}

Receiver and payer have different roles but same treatment in Hotmoka:
they are objects in state, stored at their respective state locations or
\emph{storage references}. For instance, the payer
might be allocated at \texttt{\accountOne}\linebreak
(Fig.~\ref{fig:receiver_payer}). A storage reference has two parts, separated
by a \texttt{\#} sign. The first part are 64 hexadecimal digits (\ie, 32 bytes)
that identify the
transaction that created the object; the second part is a progressive number
that identifies an object created during that transaction: the first object
created during the transaction has progressive zero, the second has progressive
one, and so on. When a method is called on a Hotmoka node, what is actually specified
in the call request are the storage references of the receiver and of the payer
(plus the actual arguments to the method, if any).

Each object in the state of a Hotmoka node knows its \emph{classpath},
that is, it holds a reference to the jar, already installed in the node,
that contains the compiled bytecode of the class of the object. For instance,
in Fig.~\ref{fig:receiver_payer}, the payer account is a Java object whose
class \texttt{io.takamaka.code.lang.ExternallyOwnedAccountED25519}
is defined in a jar referenced by the \emph{transaction reference}
\texttt{\takamakaCode{}}.
Namely, in Hotmoka, a transaction is either
%
\begin{enumerate}
\item the installation of a jar, that modifies the state of the node, and is paid by a payer account, or
\item the execution of a constructor, that yields the storage reference of a new object, or
\item the execution of a method on a receiver, that yields a returned
  value and/or has side-effects that modify the state of the node, and is paid by a payer account.
\end{enumerate}

A Hotmoka node keeps track
of the transactions that it has executed, so that it is possible, for instance,
to recreate its state by running all the transactions executed in the past, starting from
the empty state.

It is very important to discuss at this moment a significant difference with what
happens in Bitcoin, Ethereum and most other blockchains. There, an account
is not an object, nor a contract,
but just a key in the key/value store of the blockchain, whose value is its balance.
The key used for an account is typically computed by hashing the public key derived from
the private key of the account. In some sense, accounts, in those blockchains, exist
independently from the state of the blockchain and can be computed offline: just
create a random private key, compute the associated public key and hence its hash.
Hotmoka is radically different: an account is an object that must be allocated in
state by an explicit construction transaction (that must be paid, as every transaction).
The public key is explicitly stored inside the constructed object
(base64-encoded in its \texttt{publicKey} field, see Fig.~\ref{fig:receiver_payer}).
That public key was passed as a parameter at the creation of the payer object and
can be passed again for creating more accounts. That is, it is well possible, in Hotmoka,
to have more accounts in the state of a node, all distinct, but controlled by the same key.
It is also possible to rotate the key of an account
(that is, replace it with another key), since the
\texttt{publicKey} field is not \texttt{final}.

This has a major consequence. In Bitcoin and Ethereum, an account is identified by
twelve words and a password, by using the BIP39 encoding
(see Fig.~5 and~6 of~\cite{Antonopoulos23}). These twelve words are just
a mnemonic representation of 132 bits: 128 bits for the random entropy used to derive the
private key of the account and four bits of checksum. In Hotmoka, these 128 bits are
not enough, since they identify the key of the account but not the 32 bytes of its
storage reference (in this representation, the progressive is assumed to be zero).
As a consequence, accounts in Hotmoka are identified by
128+256 bits, plus 12 bits of checksum (and a password),
which give rise to 36 words in BIP39 encoding.
By specifying those 36 words across different clients, one can control the
same account with all such clients. As usual, those 36 words must be stored in paper
and kept in a secure place, since their lost amounts to losing access to the account.

As shown in Fig.~\ref{fig:receiver_payer}, the code of the objects (contracts) installed in
the state of a Hotmoka node consists in jars (Java archives) written in a subset of Java
known as Takamaka. This is done in a way completely different from other blockchains:

\begin{enumerate}
\item In Hotmoka, programmers code the contracts that want to install in the node and nothing more;
  they do \emph{not} program the encoding of data into the
  key/value store of the node (its \emph{keeper},
  as it is called in other blockchains); they do \emph{not} program the gas metering;
  they do \emph{not}
  program the authentication of the accounts and the verification of their credentials.
  Everything is automatic in Hotmoka, exactly as in Ethereum, and differently from other blockchains
  that use general purpose languages such as Java for their smart contracts: there, programmers
  must take care of all these details, which is difficult, boring and error-prone. If this is done
  incorrectly, those blockchains will hang.
\item In Hotmoka, the code installed in the node passes
  a preliminary verification, that checks the correct
  use of some primitives, that we will introduce in the subsequent chapters, and guarantees that the
  code is deterministic. This excludes an array of errors in Hotmoka, while other blockchains
  will hang if, for instance, the code is non-deterministic.
\end{enumerate}

\section{Hotmoka clients}\label{sec:hotmoka_clients}

In order to query a Hotmoka node, handle accounts and run transactions on the node,
one needs a client application. Currently, there is a command-line client, called
moka and a mobile client for Android, called Mokito. Mokito provides
basic functionalities only (handling accounts, querying the state of the objects in the node,
running simple transactions), while moka is the most complete solution.

\subsection{Moka}\label{subsec:moka}

You can use the \texttt{moka} command to interact with an existing Hotmoka node,
install code in the node and run transactions. There are two ways of using \texttt{moka}.
You can either use \texttt{moka} inside a docker container provided by the Hotmoka developers.
Or you can download its source code, compile it and add the \texttt{moka} executable to
the command path of your machine. This latter approach is more flexible but requires to have
Java JDK version 21 (or higher) installed in your
computer, along with a recent version of Maven. The former approach avoids to install
and compile software on your machine, beyond having docker installed of course.
Moreover, many operations become ackward with docker, because, for instance, files
created inside a docker container remain there, unless explicitly copied out of there.
Both alternatives are described in the following paragraphs, but
our suggested solution is to compile and install \texttt{moka} in your machine.

\subsubsection{Invoking \texttt{moka} from inside a docker container}
\label{subsubsec:moka_inside_docker}

There are a few docker containers providing \texttt{moka} and all the machinery
for running Hotmoka nodes. They are maintained in DockerHub~\cite{hotmoka_dockerhub}.
For instance, you can query the provided version of \texttt{moka} as follows:
%
\begin{shellbox}
  docker run -it --rm hotmoka/mokamint-node:\hotmokaVersion{} moka --version
\end{shellbox}
%
You should see \texttt{\hotmokaVersion{}} answered on the screen.
You do need Java nor Maven for this, nor to compile anything: docker will take care
of downloading the image of the container and run \texttt{moka} inside it.

You can also contact an existing Hotmoka node and query the current state of an object,
allocated at a given storage reference, such as the payer account
of Fig.~\ref{fig:receiver_payer}:
%
\begin{warpprint}
\begin{shellbox}
  docker run -it --rm hotmoka/mokamint-node:\hotmokaVersion{} moka objects show\linebreak\hspace*{5ex}\accountOne{}\linebreak\hspace*{5ex}--uri \serverMokamint{}\end{shellbox}
\end{warpprint}
\begin{warpHTML}
\begin{shellbox}
  docker run -it --rm hotmoka/mokamint-node:\hotmokaVersion{} moka objects show \accountOne{} --uri \serverMokamint{}\end{shellbox}
\end{warpHTML}
%
The output will be something like:
%
\begin{shellbox}
  class io.takamaka.code.lang.ExternallyOwnedAccountED25519
    (from jar installed at
    \takamakaCode{})
    io.takamaka.code.lang.Contract.balance:java.math.BigInteger = \accountOneBalance{}
    io.takamaka.code.lang.ExternallyOwnedAccount.nonce:java.math.BigInteger = 0
    io.takamaka.code.lang.ExternallyOwnedAccount.publicKey:java.lang.String
      = "\accountOnePublicKeyBaseSixtyfour{}"
\end{shellbox}
%
Note that the classpath (the \emph{jar installed at\ldots}) corresponds to
what reported in Fig.~\ref{fig:receiver_payer}, since it is an immutable
property of an object.

\subsubsection{Invoking \texttt{moka} in the local machine}
\label{subsubsec:moka_local}

In order to invoke \texttt{moka} directly, in the local machine, one needs to download
its code, compile it and extend the path of the shell so that it finds the compiled code.
Below, it is shown how to perform this on a Linux machine.

Let us install the code in the \verb|~/Gits| directory of our machine, with the
following sequence of commands. We assume that you have both Git and Maven
installed already:
%
\begin{shellbox}
  mkdir -p ~/Gits
  cd ~/Gits
  git clone --branch v\hotmokaVersion{} \hotmokaRepo
  cd hotmoka
  mvn clean install -DskipTests
\end{shellbox}
%
Then edit your \texttt{.bashrc} configuration file and add at its end
the following command, that expands the command path of the shell:
%
\begin{shellbox}
  export PATH=~/Gits/hotmoka/io-hotmoka-moka/src/main/bash:$PATH
\end{shellbox}
%
Exit the terminal and spawn a new one. You should be able to run \texttt{moka} directly now.
For instance, you can run the same commands of Sec.~\ref{subsubsec:moka_inside_docker}, but
without the help of docker:
%
\begin{shellbox}
  moka --version
\end{shellbox}
%
and
%
\begin{warpprint}
\begin{shellbox}
  moka objects show\linebreak\hspace*{5ex}\accountOne{}\linebreak\hspace*{5ex}--uri \serverMokamint{}\end{shellbox}
\end{warpprint}
\begin{warpHTML}
\begin{shellbox}
  moka objects show \accountOne{} --uri \serverMokamint{}\end{shellbox}
\end{warpHTML}

In the rest of this book, we will normally show direct invocations
of \texttt{moka}, outside of a docker container.
Remember, however, that you can also run it from inside its docker container if you prefer.

\subsubsection{Getting help about \texttt{moka}'s commands}
\label{subsubsec:moka_help}

If you want help about the commands of \texttt{moka}, just use the \texttt{help} command.
Namely, \texttt{moka help} will print on the screen the following help lines:
%
\begin{shellbox}
\input{moka_help.txt}
\end{shellbox}
%
You can see that commands are organized in groups. You can get help about a specific
group by prefixing \texttt{help} to the name of the group. For instance, the
\texttt{moka help objects} command will print:
%
\begin{shellbox}
\input{moka_help_objects.txt}
\end{shellbox}
%
You can print the help of a specific leaf command by prefixing \texttt{help} before it.
For instance, the command \texttt{moka objects help show} will show information about the
\texttt{show} subcommand of the \texttt{objects} group of commands of \texttt{moka}. It will print:
%
\begin{shellbox}
\input{moka_objects_help_show.txt}
\end{shellbox}

\subsection{Mokito}\label{subsec:mokito}

The \texttt{moka} tool allows one to perform a large variety of operations
on a Hotmoka node. However, it is a technical tool, meant for developers.
Most users will only perform simple tasks with a Hotmoka node.
For them, it is simpler to use a mobile app, with a simpler user
interface. Such an app, called Mokito, is currently available for Android only.
You can download it from Google Play and install it in your device, from~\cite{mokito_google_play}.
Its Kotlin source code is available at~\cite{mokito_github},
together with a small Android service for connecting to a remote Hotmoka node.

The first time you will use Mokito on your mobile device,
it will connect by default to a testnet Hotmoka node
and show the screen in Fig.~\ref{fig:mokito_start}. The server can be changed
in the preferences section of the app, accessible through the menu in the
top left area of the app.
%
\begin{figure}
  \begin{center}
    \includegraphics[width=6cm]{pics/mokito_start}
  \end{center}
  \caption{The starting screen of the Mokito app.}
  \label{fig:mokito_start}
\end{figure}
%
You can see in Fig.~\ref{fig:mokito_start} that Mokito shows a \emph{faucet account},
that only exists in test networks and that can be used for funding the creation
of new accounts. We will do this with \texttt{moka} in the next section, but you
can do it from Mokito as well. In Mokito, you can also create keys, pay to keys,
show the manifest of the contacted node, show and navigate  objects in the state of the node.
This should all be intuitive.

\section{Contacting a Hotmoka node}\label{sec:contacting_node}

The examples in this book must be run against a Hotmoka node,
typically part of a Hotmoka blockchain. We will show you in a later chapter how you
can install your own local
node or blockchain. However, for now, it is much simpler to experiment with a node
that is part of one of the public
test blockchains that we provide for experimentation.
Namely, we have installed two Hotmoka nodes for testing, of two distinct blockchains, at URIs
\texttt{\serverMokamint{}} and \texttt{\serverTendermint{}}, respectively.
The peculiarity of these nodes is that they include a \emph{faucet}, that is,
an account that gives
away small amounts of coins, when requested. This is good for experimentation
but, of course, a real node will not include a faucet.
In a real node, people must grasp some coins because they have been earned through mining,
sent by some other user or bought from some exchange.

You can verify that you can contact the test node by typing
the command \texttt{moka nodes manifest show -{}-uri \serverMokamint}
to print the \emph{manifest} of the Hotmoka node
at \texttt{\serverMokamint}. The result should be something like:
%
\begin{shellbox}
\input{moka_nodes_manifest_show.txt}
\end{shellbox}
%
The details of this information are irrelevant for now, but something must be
clarified, to better understand the following sections.
Namely, the \texttt{moka nodes manifest show} command reports information
that tells us that the node
already contains some code and some Java objects, as shown in
Fig.~\ref{fig:manifest}.
%
\begin{figure}
  \begin{center}
    \begin{tikzpicture}[scale=0.5,>=Stealth]
      \draw[rounded corners] (0,-4.5) rectangle (21,19.5) [fill=statebackgroundcolor];

      \draw[rounded corners] (0.5,16) rectangle +(20,2.8) [fill=jarbackgroundcolor];
      \draw (1,18) node[right] {jar: classes of the Takamaka runtime, such as};
      \draw (1,17) node[right] {\texttt{Contract}, \texttt{Storage}, \texttt{@View}, \texttt{@FromContract}\ldots};
      \draw (-2,18.2) node[left] {Takamaka code};
      \draw (-2,17.1) node[left] {at \texttt{\takamakaCodeShort{}}};
      \draw[->,thick] (-2,17.5) -- +(2.5,0);

      \draw[->,thick] (6,13.3) -- +(0,2.7);
      \draw (6,14.8) node[left] {classpath};
      \draw (-2,12.8) node[left] {manifest};
      \draw (-2,11.7) node[left] {at \texttt{\manifestShort{}}};
      \draw[->,thick] (-2,12.3) -- +(2.5,0);

      \draw[rounded corners] (0.5,10.8) rectangle +(11,2.8) [fill=objectbackgroundcolor];
      \draw (1,12.7) node[right] {chainId: \chainId{}};
      \draw (1,11.7) node[right] {signature: ed25519};

      \draw[<-,thick] (4,8.1) -- +(0,2.7);
      \draw (4,9.5) node[right] {gamete};
      \draw[->,thick] (2,10.8) .. controls (2,5) .. node[very near start,sloped,above] {\small gas station} (3,3.8);
      \draw[->,thick] (1,10.8) .. controls (1,2) .. node[near end,sloped,below] {\small validators} (1.5,-1.2);

      \draw[rounded corners] (3,5.3) rectangle +(8,2.8) [fill=objectbackgroundcolor];
      \draw (3.5,6.7) node[right] {balance: 9999\ldots};
      \draw (-2,7.2) node[left] {gamete};
      \draw (-2,6.1) node[left] {at \texttt{\gameteShort{}}};
      \draw[->,thick] (-2,6.7) -- +(5,0);
      \draw[->,thick] (10,8.1) .. controls (14,13) .. node[near end,sloped,below] {classpath} (14,16.1);

      \draw[rounded corners] (2,1) rectangle +(8,2.8) [fill=objectbackgroundcolor];
      \draw (2.5,2.5) node[right] {gasPrice: 1};
      \draw (-2,3) node[left] {gas station};
      \draw (-2,2) node[left] {at \texttt{\gasStationShort{}}};
      \draw[->,thick] (-2,2.5) -- +(4,0);
      \draw[->,thick] (9,3.8) .. controls (15,8) .. node[near end,sloped,below] {classpath} (16,16.1);

      \draw[rounded corners] (0.5,-4) rectangle +(10.5,2.8) [fill=objectbackgroundcolor];
      \draw (1,-2) node[right] {number of validators: 0};
      \draw (1,-3.1) node[right] {current supply: 1209\ldots};
      \draw (-2,-2) node[left] {validators};
      \draw (-2,-3) node[left] {at \texttt{\validatorsShort{}}};
      \draw[->,thick] (-2,-2.5) -- +(2.5,0);
      \draw[->,thick] (9.5,-1.2) .. controls (17,8) .. node[near end,sloped,below] {classpath} (18,16.1);

    \end{tikzpicture}
  \end{center}

  \caption{Manifest, gamete, gas station and validators.}
  \label{fig:manifest}
\end{figure}
%
The Takamaka code reference is the pointer to a jar, installed in blockchain, that contains
the classes of the Takamaka language runtime. All programs that we will write in Takamaka
will depend on that jar, directly or indirectly, since they will use classes such
as \texttt{io.takamaka.code.lang.Contract} or annotations such as
\texttt{io.takamaka.code.lang.View}.
The manifest reference, instead, points to a Java object that publishes
information about the node. Namely, it reports its chain identifier and
the signature algorithm that, by default, is used to sign the transactions
for the node. The manifest refers
to another object, called \emph{gamete}, that is an account holding all the initial
coins, if any. Consequently, the gamete may have a rich balance property,
but also another interesting property, called \emph{max faucet}, that states how much coins
it is willing to give up for free at each transaction. In a real node, and differently from here,
that value should be zero. In this test network, instead, it is a non-zero value
that we will exploit for creating our first account, in
a minute. The manifest refers also to a gas station, that it, to another Java object that provides
information about the gas, such as its current price. Finally, the manifest refers
to another Java object, called \emph{validators}, that keeps information about
the validator nodes of the network, if the network has validators:
in the case of \texttt{\serverMokamint{}} there are no validators, since that network
is based on a completely decentralized proof of space consensus, without special validator nodes.
The validators object contains, in any case, also the initial,
current and final supply of cryptocurrency
(how much cryptocurrency was minted at the beginning of the network,
has much has been minted up to now, and how much will exist eventually).

As we said before, Java objects in the Hotmoka node are identified by their
storage reference, such as \texttt{\gasStation}.
You can think at a storage reference as a machine-independent pointer inside the
memory, or state, of the node.

We have used the \texttt{moka} command to see the manifest of a node. You can also use the
Mokito app for that. Namely, tap on the app menu icon on the top-left corner of the screen
and select \emph{Manifest} from the menu that will appear (see Fig.~\ref{fig:mokito_menu}).
%
\begin{figure}[t]
  \begin{center}
    \includegraphics[width=6cm]{pics/mokito_menu}
  \end{center}
  \caption{The menu of the Mokito app.}
  \label{fig:mokito_menu}
\end{figure}
%
After tapping on \emph{Manifest}, a new screen will appear, containing the same information
that we saw with the command \texttt{moka nodes manifest show} (see Fig.~\ref{fig:mokito_manifest}).
%
\begin{figure}[t]
  \begin{center}
    \includegraphics[width=6cm]{pics/mokito_manifest}
  \end{center}
  \caption{The manifest of the Hotmoka node, shown in the Mokito app.}
  \label{fig:mokito_manifest}
\end{figure}

\section{Creation of a first account}\label{sec:creation_account}
