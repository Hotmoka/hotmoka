\chapter{The support library}\label{ch:support_library}

This chapter presents the support library of the Takamaka language,
that contains classes for simplifying the definition of smart contracts.

In Sec.~\ref{sec:storage_types_and_classes},
we said that storage objects must obey to some constraints.
The strongest of them is that their fields of reference type, in turn, can only hold
storage objects. In particular, arrays are not allowed there. This can
be problematic, in particular for contracts that deal with a
dynamic, variable, potentially unbound number of other contracts.

Therefore, most classes of the support library deal
with such constraints, by providing fixed or variable-sized collections
that can be used in storage objects, since they are storage objects themselves.
Such utility classes implement lists, arrays and maps and are
consequently generally described as \emph{collections}. They have the
property of being storage classes, hence their instances can be kept in
the store of a Hotmoka node,
\emph{as long as only storage objects are added as elements of the collection}.
As usual with collections, these utility classes
have generic type, to implement collections of arbitrary, but fixed
types. This is not problematic, since Java (and hence Takamaka) allows generic types.

\section{Storage lists}\label{sec:storage_lists}

Lists are an ordered sequence of elements. In a list, it is typically
possible to access (read or write) the first element in constant time, while accesses
to the \emph{n}th element require to scan the list from its head and
consequently have a cost proportional to \emph{n}. Because of this,
lists are \emph{not}, in general, random-access data structures, whose \emph{n}th
element should be accessible in constant time.
The size of a list is not fixed: lists grow in size as more elements are added.

\begin{figure}[th]
  \begin{center}
	\begin{tikzpicture}[scale=1]
	\scriptsize
	\externalclasscolor
	\begin{interface}[text width=2cm]{Iterable\string<E\string>}{0,0}
	\end{interface}
	\interfacecolor
	\begin{interface}[text width=5.6cm]{StorageListView\string<E\string>}{0,-1.5}
		\inherit{Iterable\string<E\string>}
		\operation{@View contains(e:Object):boolean}
		\operation{@View first():E}
		\operation{@View last():E}
		\operation{@View get(index:int):E}
		\operation{@View size():int}
		\operation{toArray(generator:IntFunction\string<E[]\string>):E[]}
		\operation{forEach(action:Consumer\string<? super E\string>)}
	\end{interface}
	\begin{interface}[text width=5.3cm]{SnapshottableStorageListView\string<E\string>}{4.5,-5.5}
		\inherit{StorageListView\string<E\string>}
		\operation{snapshot():StorageListView\string<E\string>}
	\end{interface}
	\begin{interface}[text width=4cm]{StorageList\string<E\string>}{-4,-5.5}
		\inherit{StorageListView\string<E\string>}
		\operation{addFirst(element:E)}
		\operation{addLast(element:E)}
		\operation{add(element:E)}
		\operation{clear()}
		\operation{remove(e:Object):boolean}
		\operation{view():StorageListView\string<E\string>}
	\end{interface}
	\begin{interface}[text width=5.6cm]{SnapshottableStorageList\string<E\string>}{4.5,-8}
		\inherit{StorageList\string<E\string>}
		\inherit{SnapshottableStorageListView\string<E\string>}
		\operation{view():SnapshottableStorageListView\string<E\string>}
	\end{interface}
	\externalclasscolor
	\begin{class}[text width=2cm]{Storage}{-0.5,-9}
	\end{class}
	\classcolor
	\begin{class}[text width=3.5cm]{StorageLinkedList\string<E\string>}{0,-10.5}
		\inherit{Storage}
		\implement{SnapshottableStorageList\string<E\string>}
		\operation{StorageLinkedList()}
	\end{class}
	\end{tikzpicture}
  \end{center}
  \caption{The hierarchy of storage lists.}
  \label{fig:lists_hierarchy}
\end{figure}

Java has many classes for implementing lists, all subclasses
of \texttt{java.util.List<E>}. They cannot be used in Takamaka that, instead,
provides an implementation of lists with the storage class
\texttt{io.takamaka.code.util.StorageLinkedList<E>}\index{StorageLinkedList@{\texttt{StorageLinkedList}}}.
Its instances are storage objects and
can consequently be held in fields of storage classes and
can be stored in a Hotmoka node,
\emph{as long as only storage objects are added to the list}. Takamaka lists provide
constant-time access and addition to both ends of a list.
We refer to the JavaDoc of \texttt{StorageLinkedList<E>} for a full description of its methods.
They include methods for adding elements to either end of the list, for accessing and
removing elements, for iterating on a list and for building a Java array
\texttt{E[]} holding the elements of a list.

Fig.~\ref{fig:lists_hierarchy} shows the hierarchy of the storage lists.
A storage list implements the interface \texttt{StorageList<E>}\index{StorageList@{\texttt{StorageList}}},
that defines the methods that modify a list.
That interface extends the interface
\texttt{StorageListView<E>}\index{StorageListView@{\texttt{StorageListView}}}
that, instead, defines the methods
that read data from a list, but do not modify it. This distinction between the \emph{read-only}
interface and the \emph{modification} interface is typical of all collection classes in the
Takamaka library, as we will see. For the moment, note that this distinction is useful
for defining methods \texttt{snapshot()}\index{snapshot()@{\texttt{snapshot()}}}
and \texttt{view()}\index{view()@{\texttt{view()}}}. Both return
a \texttt{StorageListView<E>} but there
is an important difference between them. Namely, \texttt{snapshot()} yields a
\emph{frozen} view of the list, that cannot and will never be modified,
also if the original list gets subsequently updated. Instead,
\texttt{view()} yields a \emph{view} of a list, that is, a read-only list that changes whenever
the original list changes and exactly in the same way: if an element is added to the original
list, the same automatically occurs to the view.
In this sense, a view is just a read-only alias of the original list.
Both methods can be useful to export data, safely,
from a node to the outside world, since both methods
return an \texttt{@Exported}\index{Exported@{\texttt{Exported}}}
object without modification methods.
Method \texttt{snapshot()} runs in linear time (in the length of the list)
while method \texttt{view()} runs in constant time.
%
\begin{commentbox}
Differently from the other collection classes that we will describe in this chapter,
the \texttt{snapshot()} method of lists runs in linear time on the length of the list.
This is inherently related to the structure of a linked list, that requires a full
copy in order to create an unmodifiable clone. Other collections, later, will instead
allow the creation of snapshots in constant time.
\end{commentbox}
%
\begin{commentbox}
It might seem that \texttt{view()} is just an upwards cast to the
interface \texttt{StorageListView<E>}. This is wrong, since that method
does much more. Namely, it applies the façade design pattern
to provide a \emph{distinct} list that lacks any modification method
and implements a façade of the original list.
To appreciate the difference to a cast, assume to have a \texttt{StorageList<E> list} and to write
%
\begin{codebox}\begin{javalst}
StorageListView<E> view = (StorageListView<E>) list;
\end{javalst}\end{codebox}
%
This upwards cast will always succeed.
Variable \texttt{view} does not allow to call any modification method, since they
are not in its static type \texttt{StorageListView<E>}. But a downwards cast back
to \texttt{StorageList<E>} is enough to circumvent
that constraint: \texttt{StorageList<E> list2 = (StorageList<E>) view}.
This way, the original \texttt{list}
can be modified by modifying \texttt{list2} and it would not be safe to export
\texttt{view}, since it
is a Trojan horse for the modification of \texttt{list}. With method \texttt{view()}, the
problem does not arise, since the cast \texttt{StorageList<E> list2 = (StorageList<E>) list.view()}
fails: method \texttt{view()} actually returns another list object without modification methods.
The same is true for method \texttt{snapshot()} that, moreover, yields a frozen view of the
original list. These same considerations hold for the other Takamaka collections that we will
see in this chapter.
\end{commentbox}

Next section shows an example of use for \texttt{StorageLinkedList}.

\subsection{A gradual Ponzi contract}\label{subsec:gradual_ponzi}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-tictactoe} project in \texttt{\hotmokaRepo{}})
\end{center}

Consider our previous Ponzi contract from Ch.~\ref{ch:smart_contracts}
It is somehow irrealistic, since
an investor gets its investment back in full. In a more realistic scenario,
the investor will receive the investment back gradually, as soon as new
investors arrive. This is more complex to program, since
the Ponzi contract must take note of all investors that invested up to now,
not just of the current one as in \emph{SimplePonzi.java}. This requires a
list of investors, of unbounded size. An implementation of this gradual
Ponzi contract is reported below and has been
inspired by a similar Ethereum contract from Iyer and Dannen,
shown at page~150 of~\cite{IyerD18}.
Write its code inside package \texttt{io.hotmoka.tutorial.examples.ponzi} of
the \texttt{io-hotmoka-tutorial-examples-ponzi} project, as a new class
\texttt{GradualPonzi.java}:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.ponzi;

import static io.takamaka.code.lang.Takamaka.require;

import java.math.BigInteger;

import io.takamaka.code.lang.Contract;
import io.takamaka.code.lang.FromContract;
import io.takamaka.code.lang.Payable;
import io.takamaka.code.lang.PayableContract;
import io.takamaka.code.lang.StringSupport;
import io.takamaka.code.math.BigIntegerSupport;
import io.takamaka.code.util.StorageLinkedList;
import io.takamaka.code.util.StorageList;

public class GradualPonzi extends Contract {
  public final BigInteger MINIMUM_INVESTMENT = BigInteger.valueOf(1_000L);

  /**
   * All investors up to now. This list might contain the same investor many
   * times, which is important to pay him back more than investors
   * who only invested once.
   */
  private final StorageList<PayableContract> investors = new StorageLinkedList<>();

  public @FromContract(PayableContract.class) GradualPonzi() {
    investors.add((PayableContract) caller());
  }

  public @Payable @FromContract(PayableContract.class) void invest(BigInteger amount) {
    // new investments must be at least 10% greater than current
    require(BigIntegerSupport.compareTo(amount, MINIMUM_INVESTMENT) >= 0,
      () -> StringSupport.concat("you must invest at least ", MINIMUM_INVESTMENT));
    BigInteger eachInvestorGets = BigIntegerSupport.divide
      (amount, BigInteger.valueOf(investors.size()));
    investors.forEach(investor -> investor.receive(eachInvestorGets));
    investors.add((PayableContract) caller());
  }
}
\end{javalst}\end{codebox}

The constructor of \texttt{GradualPonzi} is annotated as \texttt{@FromContract}. Therefore,
it can only be called by a contract and the latter that gets added, as first investor,
inside the field \texttt{investors}, of type \texttt{io.takamaka.code.util.StorageLinkedList}.
This list, that implements an unbounded list of objects,
is a storage object, as long as only storage objects are
added inside it. \texttt{PayableContract}s are storage objects, hence
its use is correct here.
Subsequently, other contracts can invest by calling method \texttt{invest()}.
A minimum investment is required, but this remains constant over time.
The \texttt{amount} invested gets split by the number of the previous investors
and sent back to each of them. Note that Takamaka allows programmers to use Java's lambdas.
Old fashioned Java programmers, who don't feel at home with such treats,
can exploit the fact that
storage lists are iterable and replace the single-line \texttt{forEach()} call
with a more traditional (but gas-hungrier):
%
\begin{codebox}\begin{javalst}
for (PayableContract investor: investors)
  investor.receive(eachInvestorGets);
\end{javalst}\end{codebox}
%
It is instead \emph{highly discouraged} to iterate the list as if it were an
array. Namely, \emph{do not write}
%
\begin{codebox}\begin{javalst}
for (int pos = 0; pos < investors.size(); pos++)
  investors.get(i).receive(eachInvestorGets);
\end{javalst}\end{codebox}
%
since linked lists are not random-access data structures and the complexity of the
last loop is quadratic in the size of the list. This is not a novelty: the
same occurs with many traditional Java lists that do not implement
\texttt{java.util.RandomAccess} (such as \texttt{java.util.LinkedList}).
In Takamaka, code execution costs gas and
computational complexity does matter, more than in other programming contexts.

\subsection{A note on re-entrancy}\label{subsec:reentrancy}

The \texttt{GradualPonzi.java} class pays back previous investors immediately:
as soon as a new investor invests something, his investment gets
split and forwarded to all previous investors. This should
make Solidity programmers uncomfortable, since the same approach,
in Solidity, might lead to the infamous re-entrancy\index{re-entrancy} attack, when the
contract that receives his investment back has a
fallback function redefined in such a way to re-enter the paying contract and
re-execute the distribution of the investment.
As it is well known, such an attack has made some people rich and other
desperate. You can find more detail
in~\cite{AntonopoulosWPMP25}.
Even if such a frightening scenario does not occur,
paying back previous investors immediately is discouraged in Solidity
also for other reasons. Namely, the contract that receives his
investment back might have a redefined fallback function that
consumes too much gas or does not terminate. This would hang the
loop that pays back previous investors, actually locking the
money inside the \texttt{GradualPonzi} contract. Moreover, paying back
a contract is a relatively expensive operation in Solidity, even if the
fallback function is not redefined, and this cost is paid by the
new investor that called \texttt{invest()}, in terms of gas. The cost is linear
in the number of investors that must be paid back.

As a solution to these problems, Solidity programmers do not pay previous
investors back immediately, but let the \texttt{GradualPonzi} contract take
note of the balance of each investor, through a map.
This map is updated as soon as a new investor arrives, by increasing the
balance of every previous investor. The cost of updating the balances
is still linear in the number of previous investors, but it is cheaper
(in Solidity) than sending money back to each of them, which
requires expensive inter-contract calls that trigger new sub-transactions.
With this technique, previous investors are
now required to withdraw their balance explicitly and voluntarily,
through a call to some function, typically called \texttt{widthdraw()}.
This leads to the \emph{withdrawal pattern}, widely used for writing Solidity contracts.

We have not used the withdrawal pattern in \texttt{GradualPonzi.java}. In general,
there is no need for such pattern in Takamaka, at least not for simple
contracts like \texttt{GradualPonzi.java}. The reason is that the
\texttt{receive()}\index{receive()@{\texttt{receive()}}}
method of a payable contract (corresponding to the
fallback function of Solidity) are \texttt{final} in Takamaka and very cheap
in terms of gas. In particular, inter-contract calls are not
especially expensive in Takamaka, since they are just a method
invocation in Java bytecode (one bytecode instruction). They are \emph{not} inner transactions.
They are actually cheaper than
updating a map of balances. Moreover, avoiding the \texttt{withdraw()} transactions
reduces the overall number of transactions;
without using the map supporting the withdrawal pattern, Takamaka contracts
consume less gas and less storage.
Hence, the withdrawal pattern is both
useless in Takamaka and more expensive than paying back previous contracts immediately.

\subsection{Running the gradual Ponzi contract}\label{subsec:running_gradual_ponzi}

Let us play with the \texttt{GradualPonzi} contract now.
We can now start by installing its jar in the node:
%
\index{moka!jars install@{\texttt{jars install}}}
\inputCommand{moka_jars_install_gradual_ponzi}
\inputOutput{moka_jars_install_gradual_ponzi}
%
Create two more keys now, for two more accounts that we are going to create soon:
%
\index{moka!keys create@{\texttt{keys create}}}
\inputCommand{moka_keys_create_account2}
\inputOutput{moka_keys_create_account2}
%
and then
%
\inputCommand{moka_keys_create_account3}
\inputOutput{moka_keys_create_account3}
%
We can create the two new accounts now:
%
\index{moka!accounts create@{\texttt{accounts create}}}
\inputCommand{moka_accounts_create_account2}
\inputOutput{moka_accounts_create_account2}
%
and
%
\inputCommand{moka_accounts_create_account3}
\inputOutput{moka_accounts_create_account3}

We let our first account create an instance of \texttt{GradualPonzi} in the node now
and become the first investor of the contract:
%
\index{moka!objects create@{\texttt{objects create}}}
\inputCommand{moka_objects_create_gradual_ponzi}
\inputOutput{moka_objects_create_gradual_ponzi}
%
We let the other two players invest, in sequence, in this new \texttt{GradualPonzi} contract.
First investment:
%
\index{moka!objects call@{\texttt{objects call}}}
\inputCommand{moka_objects_call_invest_1}
\inputOutput{moka_objects_call_invest_1}
%
Second investment:
%
\inputCommand{moka_objects_call_invest_2}
\inputOutput{moka_objects_call_invest_2}

We let the first player try to invest again in the contract now, this time
with a too small investment, which leads to an exception,
since the code of the contract requires a minimum investment:
%
\inputCommand{moka_objects_call_invest_3}
\inputOutput{moka_objects_call_invest_3}
%
This exception states that a transaction failed because the last
investor invested less than 1000 units of coin. Note that the
exception message reports the cause (a \texttt{require} failed)
and includes the source program line
of the contract where the exception occurred:
line $65$ of the source file \texttt{GradualPonzi.java}, that is line
%
\index{BigIntegerSupport@{\texttt{BigIntegerSupport}}}
\begin{codebox}\begin{javalst}
require(BigIntegerSupport.compareTo(amount, MINIMUM_INVESTMENT) >= 0,
  () -> StringSupport.concat("you must invest at least ", MINIMUM_INVESTMENT));
\end{javalst}\end{codebox}
%
Finally, we can check the state of the contract:
%
\index{moka!objects show@{\texttt{objects show}}}
\inputCommand{moka_objects_show_gradual_ponzi}
\inputOutput{moka_objects_show_gradual_ponzi}
%
As you can see, the contract keeps no balance. Moreover, its \texttt{investors} field is bound to an
object, whose state can be further investigated:
%
\inputCommand{moka_objects_show_investors}
\inputOutput{moka_objects_show_investors}
%
As you can see, it is a \texttt{StorageLinkedList} of size three, since it contains
our three accounts that interacted with the \texttt{GradualPonzi} contract instance.

\section{Storage arrays}\label{sec:storage_arrays}

Arrays are an ordered sequence of elements, with constant-time access
to such elements, both for reading and for writing. The size of the arrays is typically
fixed, although there are programming languages with limited forms of dynamic arrays.

Java has native arrays, of type \texttt{E[]}, where \texttt{E} is the
type of the elements of the array. They can be used in Takamaka, but not
as fields of storage classes. For that, Takamaka provides class
\texttt{io.takamaka.code.util.StorageTreeArray<E>}\index{StorageTreeArray@{\texttt{StorageTreeArray}}}
and class
\texttt{SnapshottableStorageTreeArray<E>}\index{SnapshottableStorageTreeArray@{\texttt{SnapshottableStorageTreeArray}}},
whose instances are storage objects and
can consequently be held in fields of storage classes and
can be stored in the store of a Hotmoka node, \emph{as long as only
storage objects are added inside them}. Their size is fixed and decided
at the time of construction. Although we consider such classes
as the storage replacement for Java arrays, it must be stated that the complexity of
accessing their elements is logarithmic in the size of the array, which is
a significant deviation from the standard definition of arrays. Nevertheless,
logarithmic complexity is much better than the linear complexity for
accessing elements of a \texttt{StorageLinkedList<E>} that, instead, has the advantage
of being dynamic in size. The difference between the two classes
is that instances of \texttt{SnapshottableStorageTreeArray<E>} allow the construction
of snapshots, which increases their cost in space, time and consequently gas.
Therefore, it is better to use a \texttt{StorageTreeArray<E>} if the
snapshotting feature is not used.

\begin{figure}[th]
  \begin{center}
	\begin{tikzpicture}[scale=1]
	\scriptsize
	\externalclasscolor
	\begin{interface}[text width=2cm]{Iterable\string<E\string>}{0,0}
	\end{interface}
	\interfacecolor
	\begin{interface}[text width=8.5cm]{StorageArrayView\string<E\string>}{0,-1.5}
		\inherit{Iterable\string<E\string>}
		\operation{@View length():int}
		\operation{@View get(index:int):E}
		\operation{@View getOrDefault(index:int, \string_default:E):E}
		\operation{getOrDefault(index:int, \string_default:Supplier\string<? extends E\string>):E}
		\operation{toArray(generator:IntFunction\string<E[]\string>):E[]}
		\operation{forEach(action:Consumer\string<? super E\string>)}
	\end{interface}
	\begin{interface}[text width=6cm]{SnapshottableStorageArrayView\string<E\string>}{4.5,-6.5}
		\inherit{StorageArrayView\string<E\string>}
		\operation{snapshot():StorageArrayView\string<E\string>}
	\end{interface}
	\begin{interface}[text width=9cm]{StorageArray\string<E\string>}{-4,-5.5}
		\inherit{StorageArrayView\string<E\string>}
		\operation{set(index:int, value:E)}
		\operation{update(index:int, how:UnaryOperator\string<E\string>)}
		\operation{setIfAbsent(index:int, value:E):E}
		\operation{computeIfAbsent(index:int, supplier:IntFunction\string<? extends E\string>):E}
		\operation{view():StorageArrayView\string<E\string>}
	\end{interface}
	\begin{interface}[text width=5.2cm]{SnapshottableStorageArray\string<E\string>}{4.5,-9}
		\inherit{StorageArray\string<E\string>}
		\inherit{SnapshottableStorageArrayView\string<E\string>}
		\operation{view():SnapshottableStorageArrayView\string<E\string>}
	\end{interface}
	\externalclasscolor
	\begin{class}[text width=2cm]{Storage}{0,-9}
	\end{class}
	\classcolor
	\begin{class}[text width=6cm]{StorageTreeArray\string<E\string>}{-5,-10}
		\inherit{Storage}
		\implement{StorageArray\string<E\string>}
		\operation{StorageTreeArray(length:int)}
		\operation{StorageTreeArray(length:int, initialValue:E)}
	\end{class}
	\begin{class}[text width=7.5cm]{SnapshottableStorageTreeArray\string<E\string>}{3,-11}
		\inherit{Storage}
		\implement{SnapshottableStorageArray\string<E\string>}
		\operation{SnapshottableStorageArray(length:int)}
		\operation{SnapshottableStorageArray(length:int, initialValue:E)}
	\end{class}
	\end{tikzpicture}
  \end{center}
  \caption{The hierarchy of storage arrays.}
  \label{fig:arrays_hierarchy}
\end{figure}

We refer to the JavaDoc of \texttt{StorageTreeArray<E>}
and \texttt{SnapshottableStorageTreeArray<E>} for a full list of their methods.
There are methods for adding elements, for accessing and
removing elements, for iterating on an array and for building a Java array
\texttt{E[]} with the elements of a \texttt{StorageTreeArray<E>}
or \texttt{SnapshottableStorageTreeArray<E>}.
Fig.~\ref{fig:arrays_hierarchy} shows the hierarchy of such array classes.
They implement the interface
\texttt{StorageArray<E>}\index{StorageArray@{\texttt{StorageArray}}},
that defines the methods that modify an array.
That interface extends the interface
\texttt{StorageArrayView<E>}\index{StorageArrayView@{\texttt{StorageArrayView}}}
that, instead, defines the methods
that read data from an array, but do not modify it.
This distinction between the \emph{read-only}
interface and the \emph{modification} interface is identical
to what we have seen for lists in the previous
sections. All array classes have a method
\texttt{view()}\index{view()@{\texttt{view()}}} while only
snapshottable arrays have a method
\texttt{snapshot()}\index{snapshot()@{\texttt{snapshot()}}}, as for lists.
Both methods yield \texttt{@Exported}
storage arrays in constant time. All constructors of the
arrays classes require to specify the unmodifiable
size of the array. Moreover, it is possible to specify
a default value for the elements of the
array, that can be explicit or given as a supplier, possibly indexed.

Next section shows an example of use for \texttt{StorageTreeArray<E>}.

\subsection{A tic-tac-toe contract}\label{subsec:tic_tac_toe}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-tictactoe} project in \texttt{\hotmokaRepo{}})
\end{center}

Tic-tac-toe is a game where two players place, alternately,
a cross and a circle on a $3\times 3$ board, initially empty. The winner is the
player who places three crosses or three circles on the same row,
column or diagonal. For instance, in Fig.~\ref{fig:cross_wins} the player of
the cross wins.
%
\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \myincludegraphics{.4\linewidth}{tictactoe_wins}
  \caption{Cross wins.}
  \label{fig:cross_wins}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \myincludegraphics{.5\linewidth}{tictactoe_draw}
  \caption{A draw.}
  \label{fig:tictactoe_draw}
\end{subfigure}
\caption{The two ways a tic-tac-toe game can end: victory of one of the players or a draw.}
\end{figure}
%
Some games that end up in a draw, when the board is full but nobody wins,
as in Fig.~\ref{fig:tictactoe_draw}.

A natural representation of the tic-tac-toe board is a two-dimensional array
where indexes are distributed as shown in Fig.~\ref{fig:tictactoe_grid},
%
\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \myincludegraphics{.5\linewidth}{tictactoe_grid}
  \caption{A two-dimensional representation of the board.}
  \label{fig:tictactoe_grid}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \myincludegraphics{.42\linewidth}{tictactoe_grid_linear}
  \caption{A linear representation of the board.}
  \label{fig:tictactoe_linear}
\end{subfigure}
\caption{Two alternative representations of the board of the game.}
\end{figure}
%
implemented as a \texttt{StorageTreeArray<StorageTreeArray<Tile>>}, where \texttt{Tile} is
a class that enumerates the three possible tiles (empty, cross, circle). This is
possible but overkill. It is simpler and cheaper (also in terms of gas)
to use the previous diagram as a conceptual representation of the board
shown to the users, but use, internally,
a one-dimensional array of nine tiles, distributed as in
Fig.~\ref{fig:tictactoe_linear}.
This one-dimensional array can be implemented as a \texttt{StorageTreeArray<Tile>}.
There will be functions
for translating the conceptual representation into the internal one.

Create hence in Eclipse a new Maven Java 21 (or later) project. Use for this project the name
\texttt{io-hotmoka-tutorial-examples-tictactoe}.
You can do this by duplicating the project \texttt{io-hotmoka-tutorial-examples-family}.
Use the following \texttt{pom.xml}:
%
\begin{codebox}\begin{xmllst}
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <groupId>io.hotmoka</groupId>
  <artifactId>io-hotmoka-tutorial-examples-tictactoe</artifactId>
  <version>|\hotmokaVersion{}|</version>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.release>21</maven.compiler.release>
  </properties>

  <dependencies>
    <dependency>
      <groupId>io.hotmoka</groupId>
      <artifactId>io-takamaka-code</artifactId>
      <version>|\takamakaVersion{}|</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.11.0</version>
      </plugin>
    </plugins>
  </build>

</project>
\end{xmllst}\end{codebox}
%
and the following \texttt{module-info.java}:
%
\begin{codebox}\begin{javalst}
module tictactoe {
  requires io.takamaka.code;
}
\end{javalst}\end{codebox}
%
Create package \texttt{io.hotmoka.tutorial.examples.tictactoe}
inside \texttt{src/main/java} and add
the following \texttt{TicTacToe.java} source inside that package:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.tictactoe;

import static io.takamaka.code.lang.Takamaka.require;

import java.math.BigInteger;

import io.takamaka.code.lang.Contract;
import io.takamaka.code.lang.Exported;
import io.takamaka.code.lang.FromContract;
import io.takamaka.code.lang.Payable;
import io.takamaka.code.lang.PayableContract;
import io.takamaka.code.lang.Storage;
import io.takamaka.code.lang.StringSupport;
import io.takamaka.code.lang.View;
import io.takamaka.code.math.BigIntegerSupport;
import io.takamaka.code.util.StorageTreeArray;

public class TicTacToe extends Contract {

  @Exported
  public class Tile extends Storage {
    private final char c;

    private Tile(char c) {
      this.c = c;
    }

    @Override
    public String toString() {
      return String.valueOf(c);
    }

    private Tile nextTurn() {
      return this == CROSS ? CIRCLE : CROSS;
    }
  }

  private final Tile EMPTY = new Tile(' ');
  private final Tile CROSS = new Tile('X');
  private final Tile CIRCLE = new Tile('O');

  private final StorageTreeArray<Tile> board = new StorageTreeArray<>(9, EMPTY);
  private PayableContract crossPlayer;
  private PayableContract circlePlayer;
  private Tile turn = CROSS; // cross plays first
  private boolean gameOver;

  public @View Tile at(int x, int y) {
    require(1 <= x && x <= 3 && 1 <= y && y <= 3, "coordinates must be between 1 and 3");
    return board.get((y - 1) * 3 + x - 1);
  }

  private void set(int x, int y, Tile tile) {
    board.set((y - 1) * 3 + x - 1, tile);
  }

  public @Payable @FromContract(PayableContract.class) void play(long amount, int x, int y) {
    require(!gameOver, "the game is over");
    require(1 <= x && x <= 3 && 1 <= y && y <= 3, "coordinates must be between 1 and 3");
    require(at(x, y) == EMPTY, "the selected tile is not empty");

    PayableContract player = (PayableContract) caller();

    if (turn == CROSS)
      if (crossPlayer == null)
        crossPlayer = player;
      else
        require(player == crossPlayer, "it's not your turn");
    else
      if (circlePlayer == null) {
        require(crossPlayer != player, "you cannot play against yourself");
        long previousBet = BigIntegerSupport.subtract
          (balance(), BigInteger.valueOf(amount)).longValue();
        require(amount >= previousBet,
          () -> StringSupport.concat("you must bet at least ", previousBet, " coins"));
        circlePlayer = player;
      }
      else
        require(player == circlePlayer, "it's not your turn");

    set(x, y, turn);
    if (isGameOver(x, y))
      player.receive(balance());
    else
      turn = turn.nextTurn();
  }

  private boolean isGameOver(int x, int y) {
    if (at(x, 1) == turn && at(x, 2) == turn && at(x, 3) == turn) // column x
      return gameOver = true;

    if (at(1, y) == turn && at(2, y) == turn && at(3, y) == turn) // row y
      return gameOver = true;

    if (x == y && at(1, 1) == turn && at (2, 2) == turn && at(3, 3) == turn) // first diagonal
      return gameOver = true;

    if (x + y == 4 && at(1, 3) == turn && at(2, 2) == turn && at(3, 1) == turn) // second diagonal
      return gameOver = true;

    return gameOver = false;
  }

  @Override
  public @View String toString() {
    return StringSupport.concat(at(1, 1), "|", at(2, 1), "|", at(3, 1),
      "\n-----\n", at(1, 2), "|", at(2, 2), "|", at(3, 2),
      "\n-----\n", at(1, 3), "|", at(2, 3), "|", at(3, 3));
  }
}
\end{javalst}\end{codebox}

The internal class \texttt{Tile} represents the three alternatives that can be
put in the tic-tac-toe board. It overrides the default
\texttt{toString()} implementation, to yield the
usual representation for such alternatives; its \texttt{nextTurn()} method
alternates between cross and circle.

The board of the game is represented as a \texttt{new StorageTreeArray<>(9, EMPTY)}, whose
elements are indexed from zero to eight (inclusive) and are initialized to \texttt{EMPTY}.
It is also possible to construct the array as \texttt{new StorageTreeArray<>(9)}, but then
its elements would hold the default value \texttt{null} and the array would need to be initialized
inside a constructor for \texttt{TicTacToe}.

Methods \texttt{at()} and \texttt{set()} read and set the board element
at indexes $(x,y)$, respectively. They transform the two-dimensional conceptual representation
of the board into its internal one-dimensional representation. Since \texttt{at()} is public,
we defensively check the validity of the indexes there.

Method \texttt{play()} is the heart of the contract. Being called by the accounts
that play the game, it is annotated as \texttt{@FromContract}. It is also annotated as
\texttt{@Payable(PayableContract.class)} since players must bet money for
taking part in the game, at least for the first two moves, and receive
money if they win. The first
contract that plays is registered as \texttt{crossPlayer}. The second contract
that plays is registered as \texttt{circlePlayer}. Subsequent moves must
come, alternately, from \texttt{crossPlayer} and \texttt{circlePlayer}. The contract
uses a \texttt{turn} variable to keep track of the current turn.

Note the extensive use of \texttt{require()} to check all error situations:
%
\begin{enumerate}
\item It is possible to play only if the game is not over yet.
\item A move must be inside the board and identify an empty tile.
\item Players must alternate correctly.
\item The second player must bet at least as much as the first player.
\item It is not allowed to play against oneself.
\end{enumerate}

The \texttt{play()} method ends with a call to \texttt{gameOver()} that checks
if the game is over, that is, if the current player won.
In that case, the winner receives the full
jackpot. Note that the \texttt{gameOver()} method receives the coordinates
where the current player has moved. This allows it to restrict the
check for game over: the game is over only if the row or column
where the player moved contain the same tile; if the current player
played on a diagonal, the method checks the diagonals as well.
It is of course possible to check all rows, columns and diagonals, always,
but our solution is gas-thriftier.

The \texttt{toString()} method yields a string representation of the current board, such as
%
\begin{alltt}
X|O| 
-----
 |X|O
-----
 |X| 
\end{alltt}

\subsection{A more realistic tic-tac-toe contract}\label{subsec:more_realistic_tictactoe}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-tictactoe\_revised} project in \texttt{\hotmokaRepo{}})
\end{center}

The \texttt{TicTacToe.java} code implements the rules of a tic-tac-toe game, but has
a couple of drawbacks that make it still incomplete. Namely:
%
\begin{enumerate}
\item The creator of the game must spend gas to call its constructor,
  but has no direct incentive in doing so. He must be a benefactor,
  or hope to take part in the game after creation, if he is faster than
  any other potential player.
\item If the game ends in a draw, money gets stuck in the \texttt{TicTacToe} contract
  instance, for ever and ever.
\end{enumerate}

Replace hence the previous version of \texttt{TicTacToe.java} with the following
revised version. This new version solves
both problems at once. The policy is very simple: it imposes a minimum
bet, in order to avoid free games; if a winner emerges,
then the game forwards him only $90\%$ of the jackpot; the remaining $10\%$ goes to the
creator of the \texttt{TicTacToe} contract itself. If, instead, the game ends in a draw,
it forwards the whole jackpot to the creator.
Note that we added a \texttt{@FromContract} constructor, that takes
note of the \texttt{creator} of the game:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.tictactoe;

import static io.takamaka.code.lang.Takamaka.require;

import java.math.BigInteger;

import io.takamaka.code.lang.Contract;
import io.takamaka.code.lang.Exported;
import io.takamaka.code.lang.FromContract;
import io.takamaka.code.lang.Payable;
import io.takamaka.code.lang.PayableContract;
import io.takamaka.code.lang.Storage;
import io.takamaka.code.lang.StringSupport;
import io.takamaka.code.lang.View;
import io.takamaka.code.math.BigIntegerSupport;
import io.takamaka.code.util.StorageTreeArray;

public class TicTacToe extends Contract {

  @Exported
  public class Tile extends Storage {
    private final char c;

    private Tile(char c) {
      this.c = c;
    }

    @Override
    public String toString() {
      return String.valueOf(c);
    }

    private Tile nextTurn() {
      return this == CROSS ? CIRCLE : CROSS;
    }
  }

  private final Tile EMPTY = new Tile(' ');
  private final Tile CROSS = new Tile('X');
  private final Tile CIRCLE = new Tile('O');

  private static final long MINIMUM_BET = 100L;

  private final StorageTreeArray<Tile> board = new StorageTreeArray<>(9, EMPTY);
  private final PayableContract creator;
  private PayableContract crossPlayer;
  private PayableContract circlePlayer;
  private Tile turn = CROSS; // cross plays first
  private boolean gameOver;

  public @FromContract(PayableContract.class) TicTacToe() {
    creator = (PayableContract) caller();
  }

  public @View Tile at(int x, int y) {
    require(1 <= x && x <= 3 && 1 <= y && y <= 3, "coordinates must be between 1 and 3");
    return board.get((y - 1) * 3 + x - 1);
  }

  private void set(int x, int y, Tile tile) {
    board.set((y - 1) * 3 + x - 1, tile);
  }

  public @Payable @FromContract(PayableContract.class) void play(long amount, int x, int y) {
    require(!gameOver, "the game is over");
    require(1 <= x && x <= 3 && 1 <= y && y <= 3, "coordinates must be between 1 and 3");
    require(at(x, y) == EMPTY, "the selected tile is not empty");

    PayableContract player = (PayableContract) caller();

    if (turn == CROSS)
      if (crossPlayer == null) {
        require(amount >= MINIMUM_BET, () -> "you must invest at least " + MINIMUM_BET + " coins");
         crossPlayer = player;
      }
      else
        require(player == crossPlayer, "it's not your turn");
    else
      if (circlePlayer == null) {
        require(crossPlayer != player, "you cannot play against yourself");
        long previousBet = BigIntegerSupport.subtract
          (balance(), BigInteger.valueOf(amount)).longValue();
        require(amount >= previousBet,
          () -> StringSupport.concat("you must bet at least ", previousBet, " coins"));
        circlePlayer = player;
      }
      else
        require(player == circlePlayer, "it's not your turn");

    set(x, y, turn);
    if (isGameOver(x, y)) {
      // 90% goes to the winner
      player.receive(BigIntegerSupport.divide
        (BigIntegerSupport.multiply(balance(), BigInteger.valueOf(9L)), BigInteger.valueOf(10L)));
      // the rest to the creator of the game
      creator.receive(balance());
    }
    else if (isDraw())
      // everything goes to the creator of the game
      creator.receive(balance());
    else
      turn = turn.nextTurn();
  }

  private boolean isGameOver(int x, int y) {
    if (at(x, 1) == turn && at(x, 2) == turn && at(x, 3) == turn) // column x
      return gameOver = true;

    if (at(1, y) == turn && at(2, y) == turn && at(3, y) == turn) // row y
      return gameOver = true;

    if (x == y && at(1, 1) == turn && at (2, 2) == turn && at(3, 3) == turn) // first diagonal
      return gameOver = true;

    if (x + y == 4 && at(1, 3) == turn && at(2, 2) == turn && at(3, 1) == turn) // second diagonal
      return gameOver = true;

    return gameOver = false;
  }

  private boolean isDraw() {
    for (var tile: board)
      if (tile == EMPTY)
        return false;

    return true;
  }

  @Override
  public @View String toString() {
    return StringSupport.concat(at(1, 1), "|", at(2, 1), "|", at(3, 1),
      "\n-----\n", at(1, 2), "|", at(2, 2), "|", at(3, 2),
      "\n-----\n", at(1, 3), "|", at(2, 3), "|", at(3, 3));
  }
}    
\end{javalst}\end{codebox}

\begin{commentbox}
  We have chosen to allow a \texttt{long amount} in the \texttt{@Payable}
  method \texttt{play()} since
  it is unlikely that users will want to invest huge quantities of money in this
  game. This gives us the opportunity to discuss why the computation of the
  previous bet has been written as
  \begin{center}\begin{alltt}
    long previousBet = BigIntegerSupport.subtract
      (balance(), BigInteger.valueOf(amount)).longValue()
  \end{alltt}\end{center}
  instead of the simpler
  \texttt{long previousBet = balance().longValue() - amount}.
  The reason is that, when that line is executed, both players have already paid
  their bet, that accumulates in the balance of the \texttt{TicTacToe} contract.
  Each single bet is a \texttt{long}, but their sum could overflow the size of a \texttt{long}.
  Hence, we have to deal with a computation on \texttt{BigInteger}. The same situation
  occurs later, when we have to compute the $90\%$ that goes to the winner:
  the jackpot might be larger than a \texttt{long} and we have to compute over
  \texttt{BigInteger}. As a final remark, note that in the line:
  \begin{center}\begin{alltt}
      BigIntegerSupport.divide(BigIntegerSupport.multiply
        (balance(), BigInteger.valueOf(9L)), BigInteger.valueOf(10L))
  \end{alltt}\end{center}
  we \emph{first multiply} by $9$ and \emph{then divide} by $10$. This reduces the
  approximation inherent to integer division. For instance, if the jackpot
  (\texttt{balance()}) were 209, we have (with Java's left-to-right evaluation)
  $209\cdot 9/10=1881/10=188$ while $209/10\cdot 9=20\cdot 9=180$.
\end{commentbox}

\subsection{Running the tic-tac-toe contract}\label{subsec:running_tictactoe}

Let us play with the \texttt{TicTacToe} contract. Go in
the \texttt{io-hotmoka-tutorial-examples-tictactoe} project,
compile it with Maven and store it in the Hotmoka node:
%
\index{moka!jars install@{\texttt{jars install}}}
\inputCommand{moka_jars_install_tictactoe_revised}
\inputOutput{moka_jars_install_tictactoe_revised}
%
Then we create an instance of the contract in the node:
%
\index{moka!objects create@{\texttt{objects create}}}
\inputCommand{moka_objects_create_tictactoe_revised}
\inputOutput{moka_objects_create_tictactoe_revised}

We use two of our accounts now, that we have already created in the previous section,
to interact with the contract: they will play, alternately, until the first player wins.
We will report the resulting of calling \texttt{toString()} on the contract, after each move.

The first player starts, by playing at (1,1), and bets 100:
%
\index{moka!objects call@{\texttt{objects call}}}
\inputCommand{moka_objects_call_tictactoe_play_1}
\inputOutput{moka_objects_call_tictactoe_play_1}
%
\inputCommand{moka_objects_call_tictactoe_toString_1}
\inputOutput{moka_objects_call_tictactoe_toString_1}
%
Note that the call to \texttt{toString()} does not require to provide the password of the key pair of the caller account,
since that method is a \texttt{@View} method: this means that moka runs a transaction to call it, it does not add a transaction.

The second player plays now, at (2,1), betting 100:
%
\inputCommand{moka_objects_call_tictactoe_play_2}
\inputOutput{moka_objects_call_tictactoe_play_2}
%
\inputCommand{moka_objects_call_tictactoe_toString_2}
\inputOutput{moka_objects_call_tictactoe_toString_2}
%
The first player replies, by playing at (1,2):
%
\inputCommand{moka_objects_call_tictactoe_play_3}
\inputOutput{moka_objects_call_tictactoe_play_3}
%
\inputCommand{moka_objects_call_tictactoe_toString_3}
\inputOutput{moka_objects_call_tictactoe_toString_3}
%
Then the second player plays at (2,2):
%
\inputCommand{moka_objects_call_tictactoe_play_4}
\inputOutput{moka_objects_call_tictactoe_play_4}
%
\inputCommand{moka_objects_call_tictactoe_toString_4}
\inputOutput{moka_objects_call_tictactoe_toString_4}
%
The first player wins by playing at (1,3):
%
\inputCommand{moka_objects_call_tictactoe_play_5}
\inputOutput{moka_objects_call_tictactoe_play_5}
%
\inputCommand{moka_objects_call_tictactoe_toString_5}
\inputOutput{moka_objects_call_tictactoe_toString_5}
%
We can verify that the game is over now:
%
\index{moka!objects show@{\texttt{objects show}}}
\inputCommand{moka_objects_show_tictactoe}
\inputOutput{moka_objects_show_tictactoe}
%
As you can see, the \texttt{gameOver} field holds true. Moreover, the balance of the contract is zero since it has been distributed to
the winner and to the creator of the game (that actually coincide to our first account, in this specific run).

If the second player attempts to play now, the transaction will be rejected, since the game is over:
%
\inputCommand{moka_objects_call_tictactoe_play_6}
\inputOutput{moka_objects_call_tictactoe_play_6}

\subsection{Specialized storage array classes}\label{subsec:specialized_storage_array_classes}

The \texttt{StorageTreeArray<E>} class is very general, since it can be used to hold
any type \texttt{E} of storage values. Since it uses generics,
primitive values cannot be held in a \texttt{StorageTreeArray<E>}, directly.
For instance, \texttt{StorageTreeArray<byte>} is not legal syntax in Java.
Instead, one could think to use \texttt{StorageTreeArray<Byte>}, where \texttt{Byte}
is the Java wrapper class \texttt{java.lang.Byte}. However, that class is not
currently allowed in storage, hence \texttt{StorageTreeArray<Byte>} will not work either.
One should hence define a new wrapper class for \texttt{byte}, that extends \texttt{Storage}.
That is possible, but highly discouraged:
the use of wrapper classes introduces a level of indirection
and requires the instantiation of many small objects, which costs gas. Instead,
Takamaka provides specialized storage classes implementing arrays of bytes,
without wrappers. The rationale is that such arrays arise
naturally when dealing, for instance, with hashes or encrypted data
(see next section for an example) and consequently deserve
a specialized and optimized implementation.
Such specialized array classes
can have their length specified at construction time, or fixed to
a constant (for best optimization and minimal gas consumption).

\begin{figure}[th]
  \begin{center}
    \myincludegraphics{0.8\textwidth}{bytes}
  \end{center}
  \caption{The hierarchy of specialized byte array classes.}
  \label{fig:byte_array_hierarchy}
\end{figure}

Fig.~\ref{fig:byte_array_hierarchy} shows the hierarchy of the specialized classes for arrays of bytes,
available in Takamaka.
The interface \texttt{StorageByteArrayView}\index{StorageByteArrayView@{\texttt{StorageByteArrayView}}}
defines the methods that read data from an array
of bytes, while the interface \texttt{StorageByteArray}\index{StorageByteArray@{\texttt{StorageByteArray}}}
defines the modification methods.
Class \texttt{StorageTreeByteArray}\index{StorageTreeByteArray@{\texttt{StorageTreeByteArray}}}
allows one to create byte arrays of any length, specified at construction time.
Classes \texttt{Bytes32}\index{Bytes32@{\texttt{Bytes32}}} and
\texttt{Bytes32Snapshot}\index{Bytes32Snapshot@{\texttt{Bytes32Snapshot}}}
have, instead, fixed length of $32$ bytes;
their constructors include one that allows one to specify such $32$ bytes,
which is useful for calling the constructor from outside the node,
since \texttt{byte} is a storage type.
While a \texttt{Bytes32} is modifiable, instances of class \texttt{Bytes32Snapshot}
are not modifiable after being created and are \texttt{@Exported}.
There are sibling classes for different, fixed sizes, such as
\texttt{Bytes64} and \texttt{Bytes8Snaphot}. For a full description of the methods
of these classes and interfaces, we refer to their JavaDoc.

\section{Storage maps}\label{sec:storage_maps}

Maps are dynamic associations of objects to objects. They are useful
for programming smart contracts, as their extensive use in Solidity proves.
However, most such uses are related to the withdrawal pattern, that is
not needed in Takamaka. Nevertheless, there are still situations when
maps are useful in Takamaka code, as we show below.

Java has many implementations of maps.
However, they are not storage objects and consequently cannot be
stored in a Hotmoka node. This section describes the Takamaka library classes
\texttt{io.takamaka.code.util.StorageTreeMap<K,V>}\index{StorageTreeMap@{\texttt{StorageTreeMap}}} and
\texttt{SnapshottableStorageTreeMap<K,V>}\index{SnapshottableStorageTreeMap@{\texttt{SnapshottableStorageTreeMap}}},
that extend \texttt{Storage} and
whose instances can then be held in the store of a node, if
keys \texttt{K} and values \texttt{V} can be stored in a node as well.

\begin{figure}[th]
  \begin{center}
	\begin{tikzpicture}[scale=1]
	\scriptsize
	\externalclasscolor
	\begin{interface}[text width=4cm]{Iterable\string<Entry\string<K V\string>{}\string>}{0,0}
	\end{interface}
	\interfacecolor
	\begin{interface}[text width=9cm]{StorageMapView\string<K V\string>}{0,-1.5}
		\inherit{Iterable\string<Entry\string<K V\string>{}\string>}
		\operation{@View size():int}
		\operation{@View isEmpty():boolean}
		\operation{@View get(key:Object):V}
		\operation{@View getOrDefault(key:Object, \string_default:V):V}
		\operation{getOrDefault(key:Object, \string_default:Supplier\string<? extends V\string>):V}
		\operation{@View containsKey(key:Object):boolean}
		\operation{@View min(), max():K}
		\operation{@View floorKey(key:K), ceilingKey(key:K):K}
		\operation{@View select(k:int):K}
		\operation{forEach(action:Consumer\string<? super Entry\string<K,V\string>{}\string>)}
		\operation{forEachKey(action:Consumer\string<? super K\string>)}
		\operation{forEachValue(action:Consumer\string<? super V\string>)}
	\end{interface}
	\begin{interface}[text width=6cm]{SnapshottableStorageMapView\string<K V\string>}{4.5,-7}
		\inherit{StorageMapView\string<K V\string>}
		\operation{snapshot():StorageMapView\string<K,V\string>}
	\end{interface}
	\begin{interface}[text width=9.7cm]{StorageMap\string<K V\string>}{-4,-7}
		\inherit{StorageMapView\string<K V\string>}
		\operation{put(key:K, value:V)}
		\operation{putIfAbsent(key:K, value:V):V}
		\operation{computeIfAbsent(key:K, supplier:Function\string<? super K, ? extends V\string>):V}
		\operation{removeMin(), removeMax()}
		\operation{remove(key:Object)}
		\operation{update(key:K, how:UnaryOperator\string<V\string>)}
		\operation{clear()}
		\operation{view():StorageMapView\string<K,V\string>}
	\end{interface}
	\begin{interface}[text width=6cm]{SnapshottableStorageMap\string<K V\string>}{4.5,-10}
		\inherit{StorageMap\string<K V\string>}
		\inherit{SnapshottableStorageMapView\string<K V\string>}
		\operation{view():SnapshottableStorageMapView\string<K,V\string>}
	\end{interface}
	\externalclasscolor
	\begin{class}[text width=2cm]{Storage}{-1,-11}
	\end{class}
	\classcolor
	\begin{class}[text width=6cm]{StorageTreeMap\string<K V\string>}{-5,-12}
		\inherit{Storage}
		\implement{StorageMap\string<K V\string>}
		\operation{StorageTreeMap()}
	\end{class}
	\begin{class}[text width=7.5cm]{SnapshottableStorageTreeMap\string<K V\string>}{3,-12}
		\inherit{Storage}
		\implement{SnapshottableStorageMap\string<K V\string>}
		\operation{SnapshottableStorageTreeMap()}
	\end{class}
	\end{tikzpicture}
  \end{center}
  \caption{The hierarchy of storage maps.}
  \label{fig:maps_hierarchy}
\end{figure}

We refer to the JavaDoc of \texttt{StorageTreeMap} and \texttt{SnapshottableStorageTreeMap}
for a full description of their methods,
that are similar to those of traditional Java maps. Here, we just observe
that a key is mapped into a value by calling method
\texttt{void put(K key, V value)}, while the value bound to a key is retrieved by calling
\texttt{V get(Object key)}. It is possible to yield a default value when a key is not
in the map, by calling \texttt{V getOrDefault(Object key, V \_default)} or
its sibling \texttt{V getOrDefault(Object key, Supplier<? extends V> \_default)}, that
evaluates the default value only if needed. Method \texttt{V putIfAbsent(K key, V value)}
binds the key to the value only if the key is unbound. Similarly for
its sibling \texttt{V computeIfAbsent(K key, Function<? super K, ? extends V> value)} that computes
the new value only if needed (these two methods differ for their
returned value, as in Java maps. Please refer to their JavaDoc).

Instances of \texttt{StorageTreeMap<K,V>} and \texttt{SnapshottableStorageTreeMap<K,V>}
keep keys in increasing order. Namely, if
type \texttt{K} has a natural order, that order is used. Otherwise, keys
(that must be storage objects) are kept ordered by increasing storage
reference. Consequently, methods \texttt{forEach(Consumer<? super Entry<K,V>{}> action)},
\texttt{forEachKey(Consumer<? super K> action)} and
\texttt{forEachValue(Consumer<? super V> action)}
perform an internal iteration of the elements of the map, in order.
%
\begin{commentbox}
Compare this with Solidity, where maps do not know the set of their keys nor the
set of their values, so that, in Solidity, it is impossible to iterate on maps.
\end{commentbox}

Fig.~\ref{fig:maps_hierarchy} shows the hierarchy of the storage map classes.
They implement the library interface \texttt{StorageMap<K,V>}\index{StorageMap@{\texttt{StorageMap}}},
that defines the methods that modify a map.
That interface extends the interface \texttt{StorageMapView<K,V>}\index{StorageMapView@{\texttt{StorageMapView}}}
that, instead, defines the methods that read data from a map, but do not modify it.
Methods \texttt{snapshot()}\index{snapshot()@{\texttt{snapshot()}}}
and \texttt{view()}\index{view()@{\texttt{view()}}} return an \texttt{@Exported}
\texttt{StorageMapView<K,V>}, in constant time.
Only instances of class \texttt{SnapshottableStorageTreeMap<K,V>} allow the creation of snapshots.
Because of that, they are slightly more expensive, in time, space and gas, than instances of
class \texttt{StorageTreeMap<K,V>}. Therefore, use always a \texttt{StorageMapView<K,V>} whenever
snapshots are not needed.

There are also specialized map classes, optimized
for specific primitive types of keys, such as
\texttt{StorageTreeIntMap<V>}\index{StorageTreeIntMap@{\texttt{StorageTreeIntMap}}},
whose keys are \texttt{int} values. We refer to their JavaDoc for further information.

Next section shows an example of use for \texttt{StorageTreeMap<K,V>}.

\subsection{A blind auction contract}\label{subsec:blind_auction}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-auction} project in \texttt{\hotmokaRepo{}})
\end{center}

This section exemplifies the use of class \texttt{StorageTreeMap} by writing a smart
contract that implements a \emph{blind auction}. That contract allows
a \emph{beneficiary} to sell an item to the buying contract that offers
the highest bid. Since data in blockchain is public, in a non-blind
auction it is possible that bidders eavesdrop the offers of other bidders
in order to place an offer that is only slightly higher than the current
best offer. A blind auction, instead, uses a two-phases
mechanism: in the initial \emph{bidding time}, bidders place bids, hashed, so that
they do not reveal their amount. After the bidding time expires, the second
phase, called \emph{reveal time}, allows bidders to
reveal the real values of their bids and the auction contract to determine
the actual winner.
This works since, to reveal a bid, each bidder provides the real data
of the bid. The auction contract then recomputes the hash from real data and
checks if the result matches the hash provided at bidding time.
If not, the bid is considered invalid. Bidders can even place fake offers
on purpose, in order to confuse other bidders.

Create in Eclipse a new Maven Java 21 (or later) project. Use for this project the name
\texttt{io-hotmoka-tutorial-examples-auction}.
You could do this for instance by duplicating the project \texttt{io-hotmoka-tutorial-examples-family}.
Use the following \texttt{pom.xml}:
%
\begin{codebox}\begin{xmllst}
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <groupId>io.hotmoka</groupId>
  <artifactId>io-hotmoka-tutorial-examples-auction</artifactId>
  <version>|\hotmokaVersion{}|</version>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.release>21</maven.compiler.release>
  </properties>

  <dependencies>
    <dependency>
      <groupId>io.hotmoka</groupId>
      <artifactId>io-takamaka-code</artifactId>
      <version>|\takamakaVersion{}|</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.11.0</version>
      </plugin>
    </plugins>
  </build>

</project>
\end{xmllst}\end{codebox}
%
and the following \texttt{module-info.java}:
%
\begin{codebox}\begin{javalst}
module auction {
  requires io.takamaka.code;
}
\end{javalst}\end{codebox}

Create package \texttt{io.hotmoka.tutorial.examples.auction}
inside \texttt{src/main/java} and add
the following \texttt{BlindAuction.java} inside that package.
It is a Takamaka contract that implements
a blind auction. Since each bidder may place more bids and since such bids
must be kept in storage until reveal time, this code uses a map
from bidders to lists of bids. This smart contract has been inspired
by a similar Ethereum contract in Solidity available at
\url{https://docs.soliditylang.org/en/v0.8.33/solidity-by-example.html#blind-auction}.
Please note that the code below does not compile yet, since it misses two classes
that we will define in the next section.

%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.auction;

import static io.takamaka.code.lang.Takamaka.event;
import static io.takamaka.code.lang.Takamaka.now;
import static io.takamaka.code.lang.Takamaka.require;

import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.util.function.Supplier;

import io.takamaka.code.lang.Contract;
import io.takamaka.code.lang.Exported;
import io.takamaka.code.lang.FromContract;
import io.takamaka.code.lang.Payable;
import io.takamaka.code.lang.PayableContract;
import io.takamaka.code.lang.Storage;
import io.takamaka.code.lang.StringSupport;
import io.takamaka.code.math.BigIntegerSupport;
import io.takamaka.code.security.SHA256Digest;
import io.takamaka.code.util.Bytes32Snapshot;
import io.takamaka.code.util.StorageLinkedList;
import io.takamaka.code.util.StorageList;
import io.takamaka.code.util.StorageMap;
import io.takamaka.code.util.StorageTreeMap;

/**
* A contract for a simple auction. This class is derived from the Solidity
* code shown at https://docs.soliditylang.org/en/v0.8.33/
* solidity-by-example.html#blind-auction
* In this contract, bidders place bids together with a hash. At the end of
* the bidding period, bidders are expected to reveal if and which of their
* bids were real and their actual value. Fake bids are refunded. Real bids
* are compared and the bidder with the highest bid wins.
*/
public class BlindAuction extends Contract {

  /**
  * A bid placed by a bidder. The deposit has been payed in full.
  * If, later, the bid will be revealed as fake, then the deposit will
  * be fully refunded. If, instead, the bid will be revealed as real, but
  * for a lower amount, then only the difference will be refunded.
  */
  private static class Bid extends Storage {

    /**
    * The hash that will be regenerated and compared at reveal time.
    */
    private final Bytes32Snapshot hash;

    /**
    * The value of the bid. Its real value might be lower and known
    * at real time only.
    */
    private final BigInteger deposit;

    private Bid(Bytes32Snapshot hash, BigInteger deposit) {
      this.hash = hash;
      this.deposit = deposit;
    }

    /**
    * Recomputes the hash of a bid at reveal time and compares it
    * against the hash provided at bidding time. If they match,
    * we can reasonably trust the bid.
    * 
    * @param revealed the revealed bid
    * @param digest the hasher
    * @return true if and only if the hashes match
    */
    private boolean matches(RevealedBid revealed, SHA256Digest digest) {
      digest.update(BigIntegerSupport.toByteArray(revealed.value));
      digest.update(revealed.fake ? (byte) 0 : (byte) 1);
      digest.update(revealed.salt.toArray());
      byte[] arr1 = hash.toArray();
      byte[] arr2 = digest.digest();

      if (arr1.length != arr2.length)
        return false;

      for (int pos = 0; pos < arr1.length; pos++)
        if (arr1[pos] != arr2[pos])
          return false;

      return true;
    }
  }

  /**
  * A bid revealed by a bidder at reveal time. The bidder shows
  * if the corresponding bid was fake or real, and how much was the
  * actual value of the bid. This might be lower than previously
  * communicated.
  */
  @Exported
  public static class RevealedBid extends Storage {
    private final BigInteger value;
    private final boolean fake;

    /**
    * The salt used to strengthen the hashing.
    */
    private final Bytes32Snapshot salt;

    public RevealedBid(BigInteger value, boolean fake, Bytes32Snapshot salt) {
      this.value = value;
      this.fake = fake;
      this.salt = salt;
    }
  }

  /**
  * The beneficiary that, at the end of the reveal time, will receive
  * the highest bid.
  */
  private final PayableContract beneficiary;

  /**
  * The bids for each bidder. A bidder might place more bids.
  */
  private final StorageMap<PayableContract, StorageList<Bid>> bids = new StorageTreeMap<>();

  /**
  * The time when the bidding time ends.
  */
  private final long biddingEnd;

  /**
  * The time when the reveal time ends.
  */
  private final long revealEnd;

  /**
  * The bidder with the highest bid, at reveal time.
  */
  private PayableContract highestBidder;

  /**
  * The highest bid, at reveal time.
  */
  private BigInteger highestBid;

  /**
  * Creates a blind auction contract.
  * 
  * @param biddingTime the length of the bidding time
  * @param revealTime the length of the reveal time
  */
  public @FromContract(PayableContract.class) BlindAuction(int biddingTime, int revealTime) {
    require(biddingTime > 0, "Bidding time must be positive");
    require(revealTime > 0, "Reveal time must be positive");

    this.beneficiary = (PayableContract) caller();
    this.biddingEnd = now() + biddingTime;
    this.revealEnd = biddingEnd + revealTime;
  }

  /**
  * Places a blinded bid the given hash.
  * The sent money is only refunded if the bid is correctly
  * revealed in the revealing phase. The bid is valid if the
  * money sent together with the bid is at least "value" and
  * "fake" is not true. Setting "fake" to true and sending
  * not the exact amount are ways to hide the real bid but
  * still make the required deposit. The same bidder can place multiple bids.
  */
  public @Payable @FromContract(PayableContract.class) void bid(BigInteger amount, Bytes32Snapshot hash) {
    onlyBefore(biddingEnd);
    bids.computeIfAbsent((PayableContract) caller(),
     (Supplier<? extends StorageList<Bid>>) StorageLinkedList::new).add(new Bid(hash, amount));
  }

  /**
  * Reveals a bid of the caller. The caller will get a refund for all
  * correctly blinded invalid bids and for all bids except
  * for the totally highest.
  * 
  * @param revealed the revealed bid
  * @throws NoSuchAlgorithmException if the hashing algorithm is not available
  */
  public @FromContract(PayableContract.class) void reveal(RevealedBid revealed)
      throws NoSuchAlgorithmException {
    onlyAfter(biddingEnd);
    onlyBefore(revealEnd);
    PayableContract bidder = (PayableContract) caller();
    StorageList<Bid> bids = this.bids.get(bidder);
    require(bids != null && bids.size() > 0, "No bids to reveal");
    require(revealed != null, () -> "The revealed bid cannot be null");

    // any other hashing algorithm will do, as long as both
    // bidder and auction contracts use the same
    var digest = new SHA256Digest();
    // by removing the head of the list, it makes it impossible for the caller
    // to re-claim the same deposits
    bidder.receive(refundFor(bidder, bids.removeFirst(), revealed, digest));
  }

  public PayableContract auctionEnd() {
    onlyAfter(revealEnd);
    PayableContract winner = highestBidder;
		
    if (winner != null) {
      beneficiary.receive(highestBid);
      event(new AuctionEnd(winner, highestBid));
      highestBidder = null;
    }

    return winner;
  }

  /**
  * Checks how much of the deposit should be refunded for a given bid.
  * 
  * @param bidder the bidder that placed the bid
  * @param bid the bid, as was placed at bidding time
  * @param revealed the bid, as was revealed later
  * @param digest the hashing algorithm
  * @return the amount to refund
  */
  private BigInteger refundFor(PayableContract bidder, Bid bid, RevealedBid revealed,
                               SHA256Digest digest) {
    if (!bid.matches(revealed, digest))
      // the bid was not actually revealed: no refund
      return BigInteger.ZERO;
    else if (!revealed.fake && BigIntegerSupport.compareTo(bid.deposit, revealed.value) >= 0
             && placeBid(bidder, revealed.value))
      // the bid was correctly revealed and is the best up to now:
      // only the difference between promised and provided is refunded;
      // the rest might be refunded later if a better bid will be revealed
      return BigIntegerSupport.subtract(bid.deposit, revealed.value);
    else
      // the bid was correctly revealed and is not the best one:
      // it is fully refunded
      return bid.deposit;
  }

  /**
  * Takes note that a bidder has correctly revealed a bid for the given value.
  * 
  * @param bidder the bidder
  * @param value the value, as revealed
  * @return true if and only if this is the best bid, up to now
  */
  private boolean placeBid(PayableContract bidder, BigInteger value) {
    if (highestBid != null && BigIntegerSupport.compareTo(value, highestBid) <= 0)
      // this is not the best bid seen so far
      return false;

    // if there was a best bidder already, its bid is refunded
    if (highestBidder != null)
      // refund the previously highest bidder
      highestBidder.receive(highestBid);

    // take note that this is the best bid up to now
    highestBid = value;
    highestBidder = bidder;
    event(new BidIncrease(bidder, value));

    return true;
  }

  private static void onlyBefore(long when) {
    long diff = now() - when;
    require(diff <= 0, StringSupport.concat(diff, " ms too late"));
  }

  private static void onlyAfter(long when) {
    long diff = now() - when;
    require(diff >= 0, StringSupport.concat(-diff, " ms too early"));
  }
}
\end{javalst}\end{codebox}

Let us discuss this (long) code, by starting from the inner classes.

Class \texttt{Bid} represents a bid placed by a contract that takes part in the auction.
This information will be stored in blockchain at bidding time, hence
it is known to all other participants. An instance of \texttt{Bid} contains
the \texttt{deposit} paid at time of placing the bid. This is not necessarily
the real value of the offer but must be at least as large as the real offer,
or otherwise the bid will be considered as invalid and rejected at reveal time. Instances
of \texttt{Bid} contain a \texttt{hash} consisting of $32$ bytes. As already said, this will
be recomputed at reveal time and matched against the result.
Since arrays cannot be stored in blockchain, we use the storage class
\texttt{io.takamaka.code.util.Bytes32Snapshot} here, a library class that holds $32$ bytes, as a
traditional array (see Sec.~\ref{subsec:specialized_storage_array_classes}).
It is well possible to use a \texttt{StorageArray} of a wrapper
of \texttt{byte} here, but \texttt{Bytes32Snapshot} is much more compact and its methods consume less gas.

Class \texttt{RevealedBid} describes a bid revealed after bidding time.
It contains the real value of the bid, the salt used to strengthen the
hashing algorithm and a boolean \texttt{fake} that, when true, means that the
bid must be considered as invalid, since it was only placed in order
to confuse other bidders. It is possible to recompute and check the hash of
a revealed bid through method \texttt{matches()}, that uses a given
hashing algorithm (\texttt{digest}, a Java \texttt{java.security.MessageDigest}) to
hash value, fake mark and salt into bytes, finally compared
against the hash provided at bidding time.

The \texttt{BlindAuction} contract stores the \texttt{beneficiary} of the auction.
It is the contract that created the auction and is consequently
initialized, in the constructor of \texttt{BlindAuction}, to its caller.
The constructor must be annotated as \texttt{@FromContract} because of that.
The same constructor receives the length of bidding time and reveal time, in
milliseconds. This allows the contract to compute the absolute ending time
for the bidding phase and for the reveal phase, stored into fields
\texttt{biddingEnd} and \texttt{revealEnd}, respectively.
Note, in the constructor of \texttt{BlindAuction}, the
use of the static method \texttt{io.takamaka.code.lang.Takamaka.now()}, that yields the
current time, as with the traditional \texttt{System.currentTimeMillis()} of Java
(that instead cannot be used in Takamaka code). Method \texttt{now()}, in a blockchain, yields the
time of creation of the block of the current transaction, as seen by its miner.
That time is reported in the block and hence is independent from the
machine that runs the contract, which guarantees determinism.

Method \texttt{bid()} allows a caller (the bidder) to place a bid during the bidding phase.
An instance of \texttt{Bid} is created and added to a list, specific to each
bidder. Here is where our map comes to help. Namely, field
\texttt{bids} holds a \texttt{StorageTreeMap<PayableContract, StorageList<Bid>>},
that can be held in the store of a node since it is a storage map between storage keys
and storage values. Method \texttt{bid()} computes an empty list of bids if it is the
first time that a bidder places a bid. For that, it uses method
\texttt{computeIfAbsent()} of \texttt{StorageMap}. If it used method \texttt{get()}, it would
run into a null-pointer exception the first time a bidder places a bid.
That is, storage maps default to \texttt{null}, as all Java maps. (But differently to
Solidity maps, that provide a default value automatically when undefined.)

Method \texttt{reveal()} is called by each bidder during the reveal phase.
It accesses the \texttt{bids} placed by the bidder during the bidding time.
The method matches each revealed bid against the corresponding
list of bids for the player, by calling
method \texttt{refundFor()}, that determines how much of the deposit must be
refunded to the bidder. Namely, if a bid was fake or was not the best bid,
it must be refunded in full. If it was the best bid, it must be partially refunded
if the apparent \texttt{deposit} turns out to be higher than the actual value of the
revealed bid. While bids are refunded, method \texttt{placeBid} updates
the best bid information.

Method \texttt{auctionEnd()} is meant to be called after the reveal phase.
If there is a winner, it sends the highest bid to the beneficiary.

Note the use of methods \texttt{onlyBefore()} and \texttt{onlyAfter()} to guarantee
that some methods are only run at the right moment.

\subsection{Events}\label{subsec:events}\index{event}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-auction\_events} project in \texttt{\hotmokaRepo{}})
\end{center}

The code in the previous section does not compile since it misses two
classes \texttt{BidIncrease.java} and \texttt{AuctionEnd.java}, that we report below.
Namely, the code of the blind auction contract contains some lines that generate
\emph{events}, such as:
%
\begin{codebox}\begin{javalst}
event(new AuctionEnd(winner, highestBid));
\end{javalst}\end{codebox}

Events are milestones that are saved in the store of a Hotmoka node.
From outside the node, it is possible to subscribe to specific events and get
notified as soon as an event of that kind occurs,
to trigger actions when that happens. In terms of the
Takamaka language, events are generated through the
\texttt{io.takamaka.code.lang.Takamaka.event(Event event)}\index{event()@{\texttt{event()}}} method,
that receives a parameter
of type \texttt{io.takamaka.code.lang.Event}\index{Event@{\texttt{Event}}}. The latter is simply an abstract class that
extends \texttt{Storage}. Hence, events will
be stored in the node as part of the transaction that generated that event.
The constructor of class \texttt{Event} is annotated as \texttt{@FromContract}, which allows one
to create events from the code of contracts only. The creating contract is available
through method \texttt{creator()}\index{creator()@{\texttt{creator()}}} of class \texttt{Event}.

In our example, the \texttt{BlindAuction} class uses two events, that you can add
to the \texttt{auction} package and are defined as follows:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.auction;

import java.math.BigInteger;

import io.takamaka.code.lang.FromContract;
import io.takamaka.code.lang.Event;
import io.takamaka.code.lang.PayableContract;
import io.takamaka.code.lang.View;

public class BidIncrease extends Event {
  public final PayableContract bidder;
  public final BigInteger amount;

  @FromContract BidIncrease(PayableContract bidder, BigInteger amount) {
    this.bidder = bidder;
    this.amount = amount;
  }

  public @View PayableContract getBidder() {
    return bidder;
  }

  public @View BigInteger getAmount() {
    return amount;
  }
}
\end{javalst}\end{codebox}
%
and
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.auction;

import java.math.BigInteger;

import io.takamaka.code.lang.FromContract;
import io.takamaka.code.lang.Event;
import io.takamaka.code.lang.PayableContract;
import io.takamaka.code.lang.View;

public class AuctionEnd extends Event {
  public final PayableContract highestBidder;
  public final BigInteger highestBid;

  @FromContract AuctionEnd(PayableContract highestBidder, BigInteger highestBid) {
    this.highestBidder = highestBidder;
    this.highestBid = highestBid;
  }

  public @View PayableContract getHighestBidder() {
    return highestBidder;
  }

  public @View BigInteger getHighestBid() {
  return highestBid;
  }
}
\end{javalst}\end{codebox}

Now that all classes have been completed, the project should compile.
Go inside the project \texttt{io-hotmoka-tutorial-examples-auction} and run
\texttt{mvn install}.

\subsection{Running the blind auction contract}\label{subsec:running_blind_auction}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-runs} project in \texttt{\hotmokaRepo{}})
\end{center}

This section presents a Java class that connects to a Hotmoka node and runs the blind auction
contract of the previous section. We could run it in the \texttt{\serverMokamint{}} server,
but that Hotmoka node is based on a proof of space consensus, that generates a block every ten
seconds \emph{on average}. This means that, for a transaction to be committed, one could have to wait
more, sometime up to one minute. This would make the test slow and would require larger windows
for the bidding and for the revealing phases. Instead, we use the \texttt{\serverTendermint{}} server,
that is a Hotmoka node based on a proof of stake consensus, that generates a block every four seconds.
This makes the test faster and the timings reliable. However, this means that we must first generate
some new accounts for our tests, since those that we generated before for
\texttt{\serverMokamint{}} do not exist in \texttt{\serverTendermint{}}. We do it as previously done,
but swapping the server we are talking to:
%
\index{moka!keys create@{\texttt{keys create}}}
\inputCommand{moka_keys_create_account4}
\inputOutput{moka_keys_create_account4}
%
\inputCommand{moka_keys_create_account5}
\inputOutput{moka_keys_create_account5}
%
\inputCommand{moka_keys_create_account6}
\inputOutput{moka_keys_create_account6}
%
\index{moka!accounts create@{\texttt{accounts create}}}
\inputCommand{moka_accounts_create_account4}
\inputOutput{moka_accounts_create_account4}
%
\inputCommand{moka_accounts_create_account5}
\inputOutput{moka_accounts_create_account5}
%
\inputCommand{moka_accounts_create_account6}
\inputOutput{moka_accounts_create_account6}

Go to the \texttt{io-hotmoka-tutorial-examples-runs} Eclipse project and add the following
class inside its package:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.runs;

import static io.hotmoka.helpers.Coin.panarea;
import static io.hotmoka.node.StorageTypes.BIG_INTEGER;
import static io.hotmoka.node.StorageTypes.BOOLEAN;
import static io.hotmoka.node.StorageTypes.BYTE;
import static io.hotmoka.node.StorageTypes.BYTES32_SNAPSHOT;
import static io.hotmoka.node.StorageTypes.INT;
import static io.hotmoka.node.StorageTypes.PAYABLE_CONTRACT;
import static io.hotmoka.node.StorageValues.byteOf;

import java.math.BigInteger;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.KeyPair;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.function.Function;

import io.hotmoka.constants.Constants;
import io.hotmoka.crypto.api.Signer;
import io.hotmoka.helpers.GasHelpers;
import io.hotmoka.helpers.NonceHelpers;
import io.hotmoka.helpers.SignatureHelpers;
import io.hotmoka.helpers.api.GasHelper;
import io.hotmoka.helpers.api.NonceHelper;
import io.hotmoka.node.Accounts;
import io.hotmoka.node.ConstructorSignatures;
import io.hotmoka.node.MethodSignatures;
import io.hotmoka.node.StorageTypes;
import io.hotmoka.node.StorageValues;
import io.hotmoka.node.TransactionRequests;
import io.hotmoka.node.api.Node;
import io.hotmoka.node.api.requests.SignedTransactionRequest;
import io.hotmoka.node.api.signatures.ConstructorSignature;
import io.hotmoka.node.api.transactions.TransactionReference;
import io.hotmoka.node.api.types.ClassType;
import io.hotmoka.node.api.values.StorageReference;
import io.hotmoka.node.api.values.StorageValue;
import io.hotmoka.node.remote.RemoteNodes;

public class Auction {

  public final static int NUM_BIDS = 10; // number of bids placed
  public final static int BIDDING_TIME = 230_000; // in milliseconds
  public final static int REVEAL_TIME = 350_000; // in milliseconds

  private final static BigInteger _500_000 = BigInteger.valueOf(500_000);

  private final static ClassType BLIND_AUCTION
    = StorageTypes.classNamed("io.hotmoka.tutorial.examples.auction.BlindAuction");
  private final static ConstructorSignature CONSTRUCTOR_BYTES32_SNAPSHOT
    = ConstructorSignatures.of(BYTES32_SNAPSHOT,
      BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE,
      BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE,
      BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE,
      BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE);

  private final TransactionReference takamakaCode;
  private final StorageReference[] accounts;
  private final List<Signer<SignedTransactionRequest<?>>> signers = new ArrayList<>();
  private final String chainId;
  private final long start;  // the time when bids started being placed
  private final Node node;
  private final TransactionReference classpath;
  private final StorageReference auction;
  private final List<BidToReveal> bids = new ArrayList<>();
  private final GasHelper gasHelper;
  private final NonceHelper nonceHelper;

  public static void main(String[] args) throws Exception {
	try (Node node = RemoteNodes.of(new URI(args[0]), 20000)) {
      new Auction(node, Paths.get(args[1]),
        StorageValues.reference(args[2]), args[3],
        StorageValues.reference(args[4]), args[5],
        StorageValues.reference(args[6]), args[7]);
    }
  }

  /**
  * Class used to keep in memory the bids placed by each player,
  * that will be revealed at the end.
  */
  private class BidToReveal {
    private final int player;
    private final BigInteger value;
    private final boolean fake;
    private final byte[] salt;

    private BidToReveal(int player, BigInteger value, boolean fake, byte[] salt) {
      this.player = player;
      this.value = value;
      this.fake = fake;
      this.salt = salt;
    }

    /**
    * Creates in store a revealed bid corresponding to this object.
    * 
    * @return the storage reference to the freshly created revealed bid
    */
    private StorageReference intoBlockchain() throws Exception {
      StorageReference bytes32 = node.addConstructorCallTransaction(TransactionRequests.constructorCall
        (signers.get(player), accounts[player],
        nonceHelper.getNonceOf(accounts[player]), chainId, _500_000,
        panarea(gasHelper.getSafeGasPrice()), classpath, CONSTRUCTOR_BYTES32_SNAPSHOT,
        byteOf(salt[0]), byteOf(salt[1]), byteOf(salt[2]), byteOf(salt[3]),
        byteOf(salt[4]), byteOf(salt[5]), byteOf(salt[6]), byteOf(salt[7]),
        byteOf(salt[8]), byteOf(salt[9]), byteOf(salt[10]), byteOf(salt[11]),
        byteOf(salt[12]), byteOf(salt[13]), byteOf(salt[14]), byteOf(salt[15]),
        byteOf(salt[16]), byteOf(salt[17]), byteOf(salt[18]), byteOf(salt[19]),
        byteOf(salt[20]), byteOf(salt[21]), byteOf(salt[22]), byteOf(salt[23]),
        byteOf(salt[24]), byteOf(salt[25]), byteOf(salt[26]), byteOf(salt[27]),
        byteOf(salt[28]), byteOf(salt[29]), byteOf(salt[30]), byteOf(salt[31])));

      var CONSTRUCTOR_REVEALED_BID
        = ConstructorSignatures.of(
           StorageTypes.classNamed("io.hotmoka.tutorial.examples.auction.BlindAuction$RevealedBid"),
           BIG_INTEGER, BOOLEAN, BYTES32_SNAPSHOT);

      return node.addConstructorCallTransaction(TransactionRequests.constructorCall
        (signers.get(player), accounts[player],
        nonceHelper.getNonceOf(accounts[player]), chainId,
        _500_000, panarea(gasHelper.getSafeGasPrice()), classpath, CONSTRUCTOR_REVEALED_BID,
        StorageValues.bigIntegerOf(value), StorageValues.booleanOf(fake), bytes32));
    }
  }

  private Auction(Node node, Path dir, StorageReference account1, String password1,
      StorageReference account2, String password2, StorageReference account3, String password3)
      throws Exception {

    this.node = node;
    takamakaCode = node.getTakamakaCode();
    accounts = new StorageReference[] { account1, account2, account3 };
    var signature = node.getConfig().getSignatureForRequests();
    Function<? super SignedTransactionRequest<?>, byte[]> toBytes
      = SignedTransactionRequest<?>::toByteArrayWithoutSignature;
    signers.add(signature.getSigner(loadKeys(node, dir, account1, password1).getPrivate(), toBytes));
    signers.add(signature.getSigner(loadKeys(node, dir, account2, password2).getPrivate(), toBytes));
    signers.add(signature.getSigner(loadKeys(node, dir, account3, password3).getPrivate(), toBytes));
    gasHelper = GasHelpers.of(node);
    nonceHelper = NonceHelpers.of(node);
    chainId = node.getConfig().getChainId();
    classpath = installJar();
    auction = createContract();
    start = System.currentTimeMillis();

    StorageReference expectedWinner = placeBids();
    waitUntilEndOfBiddingTime();
    revealBids();
    waitUntilEndOfRevealTime();
    StorageValue winner = askForWinner();

    // show that the contract computes the correct winner
    System.out.println("expected winner: " + expectedWinner);
    System.out.println("actual winner: " + winner);
  }

  private StorageReference createContract() throws Exception {
    System.out.println("Creating contract");

    var CONSTRUCTOR_BLIND_AUCTION = ConstructorSignatures.of(BLIND_AUCTION, INT, INT);

    return node.addConstructorCallTransaction
      (TransactionRequests.constructorCall(signers.get(0), accounts[0],
      nonceHelper.getNonceOf(accounts[0]), chainId, _500_000, panarea(gasHelper.getSafeGasPrice()),
      classpath, CONSTRUCTOR_BLIND_AUCTION,
      StorageValues.intOf(BIDDING_TIME), StorageValues.intOf(REVEAL_TIME)));
  }

  private TransactionReference installJar() throws Exception {
    System.out.println("Installing jar");

    //the path of the user jar to install
    var auctionPath = Paths.get(System.getProperty("user.home")
      + "/.m2/repository/io/hotmoka/io-hotmoka-tutorial-examples-auction/"
      + Constants.HOTMOKA_VERSION
      + "/io-hotmoka-tutorial-examples-auction-" + Constants.HOTMOKA_VERSION + ".jar");

    return node.addJarStoreTransaction(TransactionRequests.jarStore
      (signers.get(0), // an object that signs with the payer's private key
      accounts[0], // payer
      nonceHelper.getNonceOf(accounts[0]), // payer's nonce
      chainId, // chain identifier
      BigInteger.valueOf(5_000_000), // gas limit: enough for this jar
      gasHelper.getSafeGasPrice(), // gas price: at least the current gas price of the network
      takamakaCode, // class path for the execution of the transaction
      Files.readAllBytes(auctionPath), // bytes of the jar to install
      takamakaCode)); // dependency
  }

  private StorageReference placeBids() throws Exception {
    var maxBid = BigInteger.ZERO;
    StorageReference expectedWinner = null;
    var random = new Random();
    var BID = MethodSignatures.ofVoid(BLIND_AUCTION, "bid", BIG_INTEGER, BYTES32_SNAPSHOT);

    int i = 1;
    while (i <= NUM_BIDS) { // generate NUM_BIDS random bids
      System.out.println("Placing bid " + i + "/" + NUM_BIDS);
      int player = 1 + random.nextInt(accounts.length - 1);
      var deposit = BigInteger.valueOf(random.nextInt(1000));
      var value = BigInteger.valueOf(random.nextInt(1000));
      boolean fake = random.nextInt(100) >= 80;
      var salt = new byte[32];
      random.nextBytes(salt); // random 32 bytes of salt for each bid

      // create a Bytes32 hash of the bid in the store of the node
      StorageReference bytes32 = codeAsBytes32(player, value, fake, salt);

      // keep note of the best bid, to verify the result at the end
      if (!fake && deposit.compareTo(value) >= 0)
        if (expectedWinner == null || value.compareTo(maxBid) > 0) {
          maxBid = value;
          expectedWinner = accounts[player];
        }
        else if (value.equals(maxBid))
          // we do not allow ex aequos, since the winner
          // would depend on the fastest player to reveal
          continue;

      // keep the explicit bid in memory, not yet in the node,
      // since it would be visible there
      bids.add(new BidToReveal(player, value, fake, salt));

      // place a hashed bid in the node
      node.addInstanceMethodCallTransaction(TransactionRequests.instanceMethodCall
        (signers.get(player), accounts[player],
        nonceHelper.getNonceOf(accounts[player]), chainId,
        _500_000, panarea(gasHelper.getSafeGasPrice()), classpath, BID,
        auction, StorageValues.bigIntegerOf(deposit), bytes32));

      i++;
    }

    return expectedWinner;
  }

  private void revealBids() throws Exception {
    var REVEAL = MethodSignatures.ofVoid
      (BLIND_AUCTION, "reveal",
       StorageTypes.classNamed("io.hotmoka.tutorial.examples.auction.BlindAuction$RevealedBid"));

    // we create the revealed bids in blockchain; this is safe now, since the bidding time is over
    int counter = 1;
    for (BidToReveal bid: bids) {
      System.out.println("Revealing bid " + counter++ + "/" + bids.size());
      int player = bid.player;
      StorageReference bidInBlockchain = bid.intoBlockchain();
      node.addInstanceMethodCallTransaction(TransactionRequests.instanceMethodCall
        (signers.get(player), accounts[player],
        nonceHelper.getNonceOf(accounts[player]), chainId, _500_000,
        panarea(gasHelper.getSafeGasPrice()),
        classpath, REVEAL, auction, bidInBlockchain));
    }
  }

  private StorageReference askForWinner() throws Exception {
    var AUCTION_END = MethodSignatures.ofNonVoid
      (BLIND_AUCTION, "auctionEnd", PAYABLE_CONTRACT);

    StorageValue winner = node.addInstanceMethodCallTransaction
      (TransactionRequests.instanceMethodCall
      (signers.get(0), accounts[0], nonceHelper.getNonceOf(accounts[0]),
      chainId, _500_000, panarea(gasHelper.getSafeGasPrice()),
      classpath, AUCTION_END, auction)).get();

    // the winner is normally a StorageReference,
    // but it could be a NullValue if all bids were fake
    return winner instanceof StorageReference sr ? sr : null;
  }

  private void waitUntilEndOfBiddingTime() {
    waitUntil(BIDDING_TIME + 10000, "Waiting until the end of the bidding time");
  }

  private void waitUntilEndOfRevealTime() {
    waitUntil(BIDDING_TIME + REVEAL_TIME + 10000, "Waiting until the end of the revealing time");
  }

  /**
  * Waits until a specific time after start.
  */
  private void waitUntil(long duration, String forWhat) {
    long msToWait = start + duration - System.currentTimeMillis();
    System.out.println(forWhat + " (" + msToWait + "ms still missing)");
	try {
      Thread.sleep(msToWait);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }

  /**
  * Hashes a bid and put it in the store of the node, in hashed form.
  */
  private StorageReference codeAsBytes32(int player, BigInteger value, boolean fake, byte[] salt)
      throws Exception {
	// the hashing algorithm used to hide the bids
	var digest = MessageDigest.getInstance("SHA-256");
    digest.update(value.toByteArray());
    digest.update(fake ? (byte) 0 : (byte) 1);
    digest.update(salt);
    byte[] hash = digest.digest();
    return createBytes32(player, hash);
  }

  /**
  * Creates a Bytes32Snapshot object in the store of the node.
  */
  private StorageReference createBytes32(int player, byte[] hash) throws Exception {
    return node.addConstructorCallTransaction
      (TransactionRequests.constructorCall(
      signers.get(player),
      accounts[player],
      nonceHelper.getNonceOf(accounts[player]), chainId,
      _500_000, panarea(gasHelper.getSafeGasPrice()),
      classpath, CONSTRUCTOR_BYTES32_SNAPSHOT,
      byteOf(hash[0]), byteOf(hash[1]),
      byteOf(hash[2]), byteOf(hash[3]),
      byteOf(hash[4]), byteOf(hash[5]),
      byteOf(hash[6]), byteOf(hash[7]),
      byteOf(hash[8]), byteOf(hash[9]),
      byteOf(hash[10]), byteOf(hash[11]),
      byteOf(hash[12]), byteOf(hash[13]),
      byteOf(hash[14]), byteOf(hash[15]),
      byteOf(hash[16]), byteOf(hash[17]),
      byteOf(hash[18]), byteOf(hash[19]),
      byteOf(hash[20]), byteOf(hash[21]),
      byteOf(hash[22]), byteOf(hash[23]),
      byteOf(hash[24]), byteOf(hash[25]),
      byteOf(hash[26]), byteOf(hash[27]),
      byteOf(hash[28]), byteOf(hash[29]),
      byteOf(hash[30]), byteOf(hash[31])));
  }

  private static KeyPair loadKeys(Node node, Path dir, StorageReference account, String password)
      throws Exception {
    return Accounts.of(account, dir).keys(password,
      SignatureHelpers.of(node).signatureAlgorithmFor(account));
  }
}
\end{javalst}\end{codebox}

This test class is relatively long and complex. Let us start from its beginning.
The code specifies that the test will place 10 random bids, that the bidding phase
lasts $100$ seconds and that the reveal phase lasts $140$ seconds
(these timings are fine on a blockchain that creates a block every four seconds;
shorter block creation times would allow shorter timings):
%
\begin{codebox}\begin{javalst}
public final static int NUM_BIDS = 10;
public final static int BIDDING_TIME = 230_000;
public final static int REVEAL_TIME = 350_000;
\end{javalst}\end{codebox}

Some constant signatures follow,
that simplify the calls to methods and constructors later.
Method \texttt{main()} connects to a remote node and passes it
as a parameter to the constructor of class \texttt{Auction}, that
installs \texttt{io-hotmoka-tutorial-examples-auction-\hotmokaVersion{}.jar} inside it.
It stores the node in field \texttt{node}.
Then the constructor of \texttt{Auction} creates an \texttt{auction} contract in the node
and calls method \texttt{placeBids()} that
uses the inner class \texttt{BidToReveal} to keep track of the bids placed
during the test, in clear. Initially, bids are kept in
memory, not in the store of the node, where they could be publicly accessed.
Only their hashes are stored in the node.
Method \texttt{placeBids()} generates \texttt{NUM\_BIDS} random bids on behalf
of the \texttt{accounts.length - 1} players (the first element of the
\texttt{accounts} array is the creator of the auction):
%
\begin{codebox}\begin{javalst}
int i = 1;
while (i <= NUM_BIDS) {
  int player = 1 + random.nextInt(accounts.length - 1);
  var deposit = BigInteger.valueOf(random.nextInt(1000));
  var value = BigInteger.valueOf(random.nextInt(1000));
  var fake = random.nextInt(100) >= 80; // fake in 20% of the cases
  var salt = new byte[32];
  random.nextBytes(salt);
  ...
}
\end{javalst}\end{codebox}

Each random bid is hashed (including a random salt) and a \texttt{Bytes32Snapshot} object
is created in the store of the node, containing that hash:
%
\begin{codebox}\begin{javalst}
StorageReference bytes32 = codeAsBytes32(player, value, fake, salt);
\end{javalst}\end{codebox}
%
The bid, in clear, is added to a list \texttt{bids} that, at the end of the loop,
will contain all bids:
%
\begin{codebox}\begin{javalst}
bids.add(new BidToReveal(player, value, fake, salt));
\end{javalst}\end{codebox}
%
The hash is used instead to place a bid in the node:
%
\begin{codebox}\begin{javalst}
node.addInstanceMethodCallTransaction(TransactionRequests.instanceMethodCall
  (signers.get(player), accounts[player],
  nonceHelper.getNonceOf(accounts[player]), chainId,
  _500_000, panarea(gasHelper.getSafeGasPrice()), classpath, BID,
  auction, StorageValues.bigIntegerOf(deposit), bytes32));
\end{javalst}\end{codebox}
%
The loop takes also care of keeping track of the best bidder, that placed
the best bid, so that it can be compared at the end with the best bidder
computed by the smart contract (they should coincide):
%
\begin{codebox}\begin{javalst}
if (!fake && deposit.compareTo(value) >= 0)
  if (expectedWinner == null || value.compareTo(maxBid) > 0) {
    maxBid = value;
    expectedWinner = accounts[player];
  }
  else if (value.equals(maxBid))
    continue;
\end{javalst}\end{codebox}
%
As you can see, the test above avoids generating a bid that
is equal to the best bid seen so far. This avoids having two bidders
that place the same bid: the smart contract will consider as winner
the first bidder that reveals its bids. To avoid this tricky case, we prefer
to assume that the best bid is unique. This is just a simplification of the
testing code, since the smart contract deals perfectly with that case.

After all bids have been placed, the constructor of \texttt{Auction} waits until the end of
the bidding time:
%
\begin{codebox}\begin{javalst}
waitUntilEndOfBiddingTime();
\end{javalst}\end{codebox}
%
Then it calls method \texttt{revealBids()}, that reveals
the bids to the smart contract, in plain. It creates in the store of the node
a data structure
\texttt{RevealedBid} for each elements of the list \texttt{bids}, by calling
\texttt{bid.intoBlockchain()}.
This creates the bid in clear in the store of the node, but this is safe now,
since the bidding time is over and
they cannot be used to guess a winning bid anymore. Then method \texttt{revealBids()}
reveals the bids by calling method \texttt{reveal()} of the smart contract:
%
\begin{codebox}\begin{javalst}
for (BidToReveal bid: bids) {
  int player = bid.player;
  StorageReference bidInBlockchain = bid.intoBlockchain();
  node.addInstanceMethodCallTransaction(TransactionRequests.instanceMethodCall
    (signers.get(player), accounts[player],
    nonceHelper.getNonceOf(accounts[player]), chainId, _500_000,
    panarea(gasHelper.getSafeGasPrice()),
    classpath, REVEAL, auction, bidInBlockchain));
}
\end{javalst}\end{codebox}
%
Note that this is possible since the inner class \texttt{RevealedBid} of the
smart contract has been annotated as \texttt{@Exported}
(see its code in Sec.~\ref{subsec:blind_auction}), hence its instances can be
passed as argument to calls from outside the blockchain.

Subsequently, the constructor of \texttt{Auction} waits until the end of the reveal phase:
%
\begin{codebox}\begin{javalst}
waitUntilEndOfRevealTime();
\end{javalst}\end{codebox}
%
After that, method \texttt{askForWinner()}
signals to the smart contract that the auction is over and asks about the winner:
%
\begin{codebox}\begin{javalst}
StorageValue winner = node.addInstanceMethodCallTransaction
  (TransactionRequests.instanceMethodCall
  (signers.get(0), accounts[0], nonceHelper.getNonceOf(accounts[0]),
  chainId, _500_000, panarea(gasHelper.getSafeGasPrice()),
  classpath, AUCTION_END, auction)).get();
\end{javalst}\end{codebox}
  
The final two \texttt{System.out.println()}'ss in the constructor of
\texttt{Auction} allow one to verify that the smart contract
actually computes the right winner, since they will always print the identical storage
object (different at each run, in general), such as:
%
\begin{shellbox}\begin{alltt}
expected winner: \accountFiveShort{}
actual winner: \accountFiveShort{}
\end{alltt}\end{shellbox}

We can run class \texttt{Auction} now (please note that the execution of this test will take a few minutes):
%
\inputCommand{mvn_exec_blind_auction}
%
Its execution should print something like this on the console:
%
\inputOutput{mvn_exec_blind_auction}

\subsection{Listening to events}\label{subsec:listening_to_events}
%
\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-runs} project in \texttt{\hotmokaRepo{}})
\end{center}

The \texttt{BlindAuction} contract generates events during its execution. If an external tool, such
as a wallet, wants to listen to such events and trigger some activity when they occur,
it is enough for it to subscribe to the events of a node that is executing the contract,
by providing a handler that gets executed each time a new event gets generated.
Subscription requires to specify the creator of the events that should be forwarded to the
handler. In our case, this is the \texttt{auction} contract. Thus, clone the \texttt{Auction.java} class into
\texttt{Events.java} and modify its constructor as follows:
%
\begin{codebox}\begin{javalst}
...
import io.hotmoka.node.api.ClosedNodeException;
import io.hotmoka.node.api.UnknownReferenceException;
...
auction = createAuction();
start = System.currentTimeMillis();

try (var subscription = node.subscribeToEvents(auction, this::eventHandler)) {
  StorageReference expectedWinner = placeBids();
  waitUntilEndOfBiddingTime();
  revealBids();
  waitUntilEndOfRevealTime();
  StorageValue winner = askForWinner();

  System.out.println("expected winner: " + expectedWinner);
  System.out.println("actual winner: " + winner);

  waitUntilAllEventsAreFlushed();
}

private void waitUntilAllEventsAreFlushed() {
  waitUntil(BIDDING_TIME + REVEAL_TIME + 30000, "Waiting until all events are flushed");
}

private void eventHandler(StorageReference creator, StorageReference event) {
  try {
    System.out.println
      ("Seen event of class " + node.getClassTag(event).getClazz()
       + " created by contract " + creator);
  }
  catch (ClosedNodeException | UnknownReferenceException | TimeoutException e) {
    System.out.println("The node is misbehaving: " + e.getMessage());
  }
  catch (InterruptedException e) {
    Thread.currentThread().interrupt();
  }
}
\end{javalst}\end{codebox}
%
The event handler, in this case, simply prints on the console the class of the event and its creator
(that will coincide with \texttt{auction}). You can run the \texttt{Events} class now:
%
\inputCommand{mvn_exec_blind_auction_events}
%
You should see something like this on the console:
%
\inputOutput{mvn_exec_blind_auction_events}
%
\begin{commentbox}
The \texttt{subscribeToEvents()}\index{subscribeToEvents()@{\texttt{subscribeToEvents()}}}
method returns a \texttt{Subscription}\index{Subscription@{\texttt{Subscription}}} object that should be
closed when it is not needed anymore, in order to reduce the overhead on the node.
Since it is an \texttt{AutoCloseable} resource, the recommended technique is to use a
try-with-resource construct, as shown in the previous example.
Moreover, our code waits for a few seconds before closing the
subscription to the events, in order to give events the time to be forwarded to the client.
\end{commentbox}

In general, event handlers can perform arbitrarily complex operations and even access the
event object in the store of the node,
from its storage reference, reading its fields or calling its methods. Please remember, however,
that event handlers are run in a thread of the node. Hence, they should be fast and shouldn't hang.
It is good practice to let event handlers add events in a queue, in a non-blocking way.
A consumer thread, external to the node, then retrieves the events from the queue and processes them in turn.

It is possible to subscribe to \emph{all} events generated by a node,
by using \texttt{null} as creator in the \texttt{subscribeToEvents()} method. Think twice before doing that,
since your handler will be notified of \emph{all} events generated by \emph{any} application installed in
the node. It might be a lot.