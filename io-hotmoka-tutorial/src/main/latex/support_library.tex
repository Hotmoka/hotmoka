\chapter{The support library}\label{ch:support_library}

This chapter presents the support library of the Takamaka language,
that contains classes for simplifying the definition of smart contracts.

In Sec.~\ref{sec:storage-types-and-constraints-on-storage-classes},
we said that storage objects must obey to some constraints.
The strongest of them is that their fields of reference type, in turn, can only hold
storage objects. In particular, arrays are not allowed there. This can
be problematic, in particular for contracts that deal with a
dynamic, variable, potentially unbound number of other contracts.

Therefore, most classes of the support library deal
with such constraints, by providing fixed or variable-sized collections
that can be used in storage objects, since they are storage objects themselves.
Such utility classes implement lists, arrays and maps and are
consequently generally described as \emph{collections}. They have the
property of being storage classes, hence their instances can be kept in
the store of a Hotmoka node,
\emph{as long as only storage objects are added as elements of the collection}.
As usual with collections, these utility classes
have generic type, to implement collections of arbitrary, but fixed
types. This is not problematic, since Java (and hence Takamaka) allows generic types.

\section{Storage lists}\label{sec:storage_lists}

Lists are an ordered sequence of elements. In a list, it is typically
possible to access the first element in constant time, while accesses
to the \emph{n}th element require to scan the list from its head and
consequently have a cost proportional to \emph{n}. Because of this,
lists are \emph{not}, in general, random-access data structures, whose \emph{n}th
element should be accessible in constant time. It is also possible
to add an element at the beginning of a list, in constant time.
The size of a list is not fixed: lists grow in size as more elements are added.

\begin{figure}[th]
  \begin{center}
    \includegraphics[width=0.45\textwidth]{pics/lists}
  \end{center}
  \caption{The hierarchy of storage lists.}
  \label{fig:lists_hierarchy}
\end{figure}

Java has many classes for implementing lists, all subclasses
of \texttt{java.util.List<E>}. They cannot be used in Takamaka that, instead,
provides an implementation of lists with the storage class
\texttt{io.takamaka.code.util.StorageLinkedList<E>}\index{StorageLinkedList@{\texttt{StorageLinkedList}}}.
Its instances are storage objects and
can consequently be held in fields of storage classes and
can be stored in a Hotmoka node,
\emph{as long as only storage objects are added to the list}. Takamaka lists provide
constant-time access and addition to both ends of a list.
We refer to the JavaDoc of \texttt{StorageLinkedList<E>} for a full description of its methods.
They include methods for adding elements to either ends of the list, for accessing and
removing elements, for iterating on a list and for building a Java array
\texttt{E[]} holding the elements of a list.

Fig.~\ref{fig:lists_hierarchy} shows the hierarchy of the \texttt{StorageLinkedList<E>} class.
It implements the interface \texttt{StorageList<E>}\index{StorageList@{\texttt{StorageList}}},
that defines the methods that modify a list.
That interface extends the interface
\texttt{StorageListView<E>}\index{StorageListView@{\texttt{StorageListView}}}
that, instead, defines the methods
that read data from a list, but do not modify it. This distinction between the \emph{read-only}
interface and the \emph{modification} interface is typical of all collection classes in the
Takamaka library, as we will see. For the moment, note that this distinction is useful
for defining methods \texttt{snapshot()}\index{snapshot()@{\texttt{snapshot()}}}
and \texttt{view()}\index{view()@{\texttt{view()}}}. Both return
a \texttt{StorageListView<E>} but there
is an important difference between them. Namely, \texttt{snapshot()} yields a
\emph{frozen} view of the list,
that cannot and will never be modified, also if the original list gets subsequently updated.
Instead,
\texttt{view()} yields a \emph{view} of a list, that is, a read-only list that changes whenever
the original list changes and exactly in the same way: if an element is added to the original
list, the same automatically occurs to the view.
In this sense, a view is just a read-only alias of the original list.
Both methods can be useful to export data, safely,
from a node to the outside world, since both methods
return an \texttt{@Exported}\index{Exported@{\texttt{Exported}}}
object without modification methods.
Method \texttt{snapshot()} runs in linear time (in the length of the list)
while method \texttt{view()} runs in constant time.
%
\begin{commentbox}
It might seem that \texttt{view()} is just an upwards cast to the
interface \texttt{StorageListView<E>}. This is wrong, since that method
does much more. Namely, it applies the façade design pattern
to provide a \emph{distinct} list that lacks any modification method
and implements a façade of the original list.
To appreciate the difference to a cast, assume to have a \texttt{StorageList<E> list} and to write
\texttt{StorageListView<E> view = (StorageListView<E>) list}. This upwards cast will always succeed.
Variable \texttt{view} does not allow to call any modification method, since they
are not in its static type \texttt{StorageListView<E>}. But a downwards cast back
to \texttt{StorageList<E>} is enough to circumvent
that constraint: \texttt{StorageList<E> list2 = (StorageList<E>) view}.
This way, the original \texttt{list}
can be modified by modifying \texttt{list2} and it would not be safe to export
\texttt{view}, since it
is a Trojan horse for the modification of \texttt{list}. With method \texttt{view()}, the
problem does not arise, since the cast \texttt{StorageList<E> list2 = (StorageList<E>) list.view()}
fails: method \texttt{view()} actually returns another list object without modification methods.
The same is true for method \texttt{snapshot()} that, moreover, yields a frozen view of the
original list. These same considerations hold for the other Takamaka collections that we will
see in this chapter.
\end{commentbox}

Next section shows an example of use for \texttt{StorageLinkedList}.

\subsection{A gradual Ponzi contract}\label{sec:gradual_ponzi}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-tictactoe} project in \texttt{\hotmokaRepo{}})
\end{center}

Consider our previous Ponzi contract from Ch.~\ref{ch:smart_contracts}
It is somehow irrealistic, since
an investor gets its investment back in full. In a more realistic scenario,
the investor will receive the investment back gradually, as soon as new
investors arrive. This is more complex to program, since
the Ponzi contract must take note of all investors that invested up to now,
not just of the current one as in \emph{SimplePonzi.java}. This requires a
list of investors, of unbounded size. An implementation of this gradual
Ponzi contract is reported below and has been
inspired by a similar Ethereum contract from Iyer and Dannen,
shown at page~150 of~\cite{IyerD18}.
Write its code inside package \texttt{io.hotmoka.tutorial.examples.ponzi} of
the \texttt{io-hotmoka-tutorial-examples-ponzi} project, as a new class
\texttt{GradualPonzi.java}:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.ponzi;

import static io.takamaka.code.lang.Takamaka.require;

import java.math.BigInteger;

import io.takamaka.code.lang.Contract;
import io.takamaka.code.lang.FromContract;
import io.takamaka.code.lang.Payable;
import io.takamaka.code.lang.PayableContract;
import io.takamaka.code.lang.StringSupport;
import io.takamaka.code.math.BigIntegerSupport;
import io.takamaka.code.util.StorageLinkedList;
import io.takamaka.code.util.StorageList;

public class GradualPonzi extends Contract {
  public final BigInteger MINIMUM_INVESTMENT = BigInteger.valueOf(1_000L);

  /**
   * All investors up to now. This list might contain the same investor many
   * times, which is important to pay him back more than investors
   * who only invested once.
   */
  private final StorageList<PayableContract> investors = new StorageLinkedList<>();

  public @FromContract(PayableContract.class) GradualPonzi() {
    investors.add((PayableContract) caller());
  }

  public @Payable @FromContract(PayableContract.class) void invest(BigInteger amount) {
    // new investments must be at least 10% greater than current
    require(BigIntegerSupport.compareTo(amount, MINIMUM_INVESTMENT) >= 0,
      () -> StringSupport.concat("you must invest at least ", MINIMUM_INVESTMENT));
    BigInteger eachInvestorGets = BigIntegerSupport.divide
      (amount, BigInteger.valueOf(investors.size()));
    investors.forEach(investor -> investor.receive(eachInvestorGets));
    investors.add((PayableContract) caller());
  }
}
\end{javalst}\end{codebox}

The constructor of \texttt{GradualPonzi} is annotated as \texttt{@FromContract}. Therefore,
it can only be called by a contract and the latter that gets added, as first investor,
inside the field \texttt{investors}, of type \texttt{io.takamaka.code.util.StorageLinkedList}.
This list, that implements an unbounded list of objects,
is a storage object, as long as only storage objects are
added inside it. \texttt{PayableContract}s are storage objects, hence
its use is correct here.
Subsequently, other contracts can invest by calling method \texttt{invest()}.
A minimum investment is required, but this remains constant over time.
The \texttt{amount} invested gets split by the number of the previous investors
and sent back to each of them. Note that Takamaka allows programmers to use Java's lambdas.
Old fashioned Java programmers, who don't feel at home with such treats,
can exploit the fact that
storage lists are iterable and replace the single-line \texttt{forEach()} call
with a more traditional (but gas-hungrier):
%
\begin{codebox}\begin{javalst}
for (PayableContract investor: investors)
  investor.receive(eachInvestorGets);
\end{javalst}\end{codebox}
%
It is instead \emph{highly discouraged} to iterate the list as if it were an
array. Namely, \emph{do not write}
%
\begin{codebox}\begin{javalst}
for (int pos = 0; pos < investors.size(); pos++)
  investors.get(i).receive(eachInvestorGets);
\end{javalst}\end{codebox}
%
since linked lists are not random-access data structures and the complexity of the
last loop is quadratic in the size of the list. This is not a novelty: the
same occurs with many traditional Java lists that do not implement
\texttt{java.util.RandomAccess} (such as \texttt{java.util.LinkedList}).
In Takamaka, code execution costs gas and
computational complexity does matter, more than in other programming contexts.

\subsection{A note on re-entrancy}\label{subsec:reentrancy}

The \texttt{GradualPonzi.java} class pays back previous investors immediately:
as soon as a new investor invests something, his investment gets
split and forwarded to all previous investors. This should
make Solidity programmers uncomfortable, since the same approach,
in Solidity, might lead to the infamous re-entrancy\index{re-entrancy} attack, when the
contract that receives his investment back has a
fallback function redefined in such a way to re-enter the paying contract and
re-execute the distribution of the investment.
As it is well known, such an attack has made some people rich and other
desperate. You can find more detail
in~\cite{AntonopoulosWPMP25}.
Even if such a frightening scenario does not occur,
paying back previous investors immediately is discouraged in Solidity
also for other reasons. Namely, the contract that receives his
investment back might have a redefined fallback function that
consumes too much gas or does not terminate. This would hang the
loop that pays back previous investors, actually locking the
money inside the \texttt{GradualPonzi} contract. Moreover, paying back
a contract is a relatively expensive operation in Solidity, even if the
fallback function is not redefined, and this cost is paid by the
new investor that called \texttt{invest()}, in terms of gas. The cost is linear
in the number of investors that must be paid back.

As a solution to these problems, Solidity programmers do not pay previous
investors back immediately, but let the \texttt{GradualPonzi} contract take
note of the balance of each investor, through a map.
This map is updated as soon as a new investor arrives, by increasing the
balance of every previous investor. The cost of updating the balances
is still linear in the number of previous investors, but it is cheaper
(in Solidity) than sending money back to each of them, which
requires expensive inter-contract calls that trigger new sub-transactions.
With this technique, previous investors are
now required to withdraw their balance explicitly and voluntarily,
through a call to some function, typically called \texttt{widthdraw()}.
This leads to the \emph{withdrawal pattern}, widely used for writing Solidity contracts.

We have not used the withdrawal pattern in \texttt{GradualPonzi.java}. In general,
there is no need for such pattern in Takamaka, at least not for simple
contracts like \texttt{GradualPonzi.java}. The reason is that the
\texttt{receive()}\index{receive()@{\texttt{receive()}}}
method of a payable contract (corresponding to the
fallback function of Solidity) are \texttt{final} in Takamaka and very cheap
in terms of gas. In particular, inter-contract calls are not
especially expensive in Takamaka, since they are just a method
invocation in Java bytecode (one bytecode instruction). They are \emph{not} inner transactions.
They are actually cheaper than
updating a map of balances. Moreover, avoiding the \texttt{withdraw()} transactions
reduces the overall number of transactions;
without using the map supporting the withdrawal pattern, Takamaka contracts
consume less gas and less storage.
Hence, the withdrawal pattern is both
useless in Takamaka and more expensive than paying back previous contracts immediately.

\subsection{Running the gradual Ponzi contract}\label{subsec:running_gradual_ponzi}

Let us play with the \texttt{GradualPonzi} contract now.
We can now start by installing its jar in the node:
%
\input{moka_jars_install_gradual_ponzi_command}
\input{moka_jars_install_gradual_ponzi_output}
%
Create two more keys now, for two more accounts that we are going to create soon:
%
\input{moka_keys_create_account2_command}
\input{moka_keys_create_account2_output}
%
and then
%
\input{moka_keys_create_account3_command}
\input{moka_keys_create_account3_output}
%
We can create the two new accounts now:
%
\input{moka_accounts_create_account2_command}
\input{moka_accounts_create_account2_output}
%
and
%
\input{moka_accounts_create_account3_command}
\input{moka_accounts_create_account3_output}

We let our first account create an instance of \texttt{GradualPonzi} in the node now
and become the first investor of the contract:
%
\input{moka_objects_create_gradual_ponzi_command}
\input{moka_objects_create_gradual_ponzi_output}
%
We let the other two players invest, in sequence, in this new \texttt{GradualPonzi} contract.
First investment:
%
\input{moka_objects_call_invest_1_command}
\input{moka_objects_call_invest_1_output}
%
Second investment:
%
\input{moka_objects_call_invest_2_command}
\input{moka_objects_call_invest_2_output}

We let the first player try to invest again in the contract now, this time
with a too small investment, which leads to an exception,
since the code of the contract requires a minimum investment:
%
\input{moka_objects_call_invest_3_command}
\input{moka_objects_call_invest_3_output}
%
This exception states that a transaction failed because the last
investor invested less than 1000 units of coin. Note that the
exception message reports the cause (a \texttt{require} failed)
and includes the source program line
of the contract where the exception occurred:
line $65$ of the source file \texttt{GradualPonzi.java}, that is line
%
\begin{codebox}\begin{javalst}
require(BigIntegerSupport.compareTo(amount, MINIMUM_INVESTMENT) >= 0,
  () -> StringSupport.concat("you must invest at least ", MINIMUM_INVESTMENT));
\end{javalst}\end{codebox}
%
Finally, we can check the state of the contract:
%
\input{moka_objects_show_gradual_ponzi_command}
\input{moka_objects_show_gradual_ponzi_output}
%
As you can see, the contract keeps no balance. Moreover, its \texttt{investors} field is bound to an
object, whose state can be further investigated:
%
\input{moka_objects_show_investors_command}
\input{moka_objects_show_investors_output}
%
As you can see, it is a \texttt{StorageLinkedList} of size three, since it contains
our three accounts that interacted with the \texttt{GradualPonzi} contract instance.

\section{Storage arrays}\label{sec:storage_arrays}

Arrays are an ordered sequence of elements, with constant-time access
to such elements, both for reading and for writing. The size of the arrays is typically
fixed, although there are programming languages with limited forms of dynamic arrays.

Java has native arrays, of type \texttt{E[]}, where \texttt{E} is the
type of the elements of the array. They can be used in Takamaka, but not
as fields of storage classes. For that, Takamaka provides class
\texttt{io.takamaka.code.util.StorageTreeArray<E>}\index{StorageTreeArray@{\texttt{StorageTreeArray}}}. Its instances are storage objects and
can consequently be held in fields of storage classes and
can be stored in the store of a Hotmoka node, \emph{as long as only
storage objects are added to the array}. Their size is fixed and decided
at the time of construction. Although we consider \texttt{StorageTreeArray<E>} as the storage
replacement for Java arrays, it must be stated that the complexity of
accessing their elements is logarithmic in the size of the array, which is
a significant deviation from the standard definition of arrays. Nevertheless,
logarithmic complexity is much better than the linear complexity for
accessing elements of a \texttt{StorageLinkedList<E>} that, instead, has the advantage
of being dynamic in size.

\begin{figure}[th]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{pics/arrays}
  \end{center}
  \caption{The hierarchy of storage arrays.}
  \label{fig:arrays_hierarchy}
\end{figure}

We refer to the JavaDoc of \texttt{StorageTreeArray<E>} for a full list of its methods.
They include methods for adding elements, for accessing and
removing elements, for iterating on an array and for building a Java array
\texttt{E[]} with the elements of a \texttt{StorageTreeArray<E>}.
Fig.~\ref{fig:arrays_hierarchy} shows the hierarchy of the \texttt{StorageTreeArray<E>} class.
It implements the interface
\texttt{StorageArray<E>}\index{StorageArray@{\texttt{StorageArray}}},
that defines the methods that modify an array.
That interface extends the interface
\texttt{StorageArrayView<E>}\index{StorageArrayView@{\texttt{StorageArrayView}}}
that, instead, defines the methods
that read data from an array, but do not modify it. This distinction between the \emph{read-only}
interface and the \emph{modification} interface is identical to what we have seen for lists in the previous
sections. Arrays have methods \texttt{snapshot()}\index{snapshot()@{\texttt{snapshot()}}}
and \texttt{view()}\index{view()@{\texttt{view()}}} as well, like lists.
They yield \texttt{@Exported}
storage arrays, both in constant time. All constructors of the
\texttt{StorageTreeArray<E>} class require to specify the unmodifiable
size of the array. Moreover, it is possible to specify a default value for the elements of the
array, that can be explicit or given as a supplier, possibly indexed.

Next section shows an example of use for \texttt{StorageTreeArray<E>}.

\subsection{A tic-tac-toe contract}\label{subsec:tic_tac_toe}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-tictactoe} project in \texttt{\hotmokaRepo{}})
\end{center}

Tic-tac-toe is a game where two players place, alternately,
a cross and a circle on a $3\times 3$ board, initially empty. The winner is the
player who places three crosses or three circles on the same row,
column or diagonal. For instance, in Fig.~\ref{fig:cross_wins} the player of
the cross wins.
%
\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.4\linewidth]{pics/tictactoe_wins}
  \caption{Cross wins.}
  \label{fig:cross_wins}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.5\linewidth]{pics/tictactoe_draw}
  \caption{A draw.}
  \label{fig:tictactoe_draw}
\end{subfigure}
\caption{The two ways a tic-tac-toe game can end: victory of one of the players or a draw.}
\end{figure}
%
Some games that end up in a draw, when the board is full but nobody wins,
as in Fig.~\ref{fig:tictactoe_draw}.

A natural representation of the tic-tac-toe board is a two-dimensional array
where indexes are distributed as shown in Fig.~\ref{fig:tictactoe_grid},
%
\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.5\linewidth]{pics/tictactoe_grid}
  \caption{A two-dimensional representation of the board.}
  \label{fig:tictactoe_grid}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.42\linewidth]{pics/tictactoe_grid_linear}
  \caption{A linear representation of the board.}
  \label{fig:tictactoe_linear}
\end{subfigure}
\caption{Two alternative representations of the board of the game.}
\end{figure}
%
implemented as a \texttt{StorageTreeArray<StorageTreeArray<Tile>>}, where \texttt{Tile} is
a class that enumerates the three possible tiles (empty, cross, circle). This is
possible but overkill. It is simpler and cheaper (also in terms of gas)
to use the previous diagram as a conceptual representation of the board
shown to the users, but use, internally,
a one-dimensional array of nine tiles, distributed as in
Fig.~\ref{fig:tictactoe_linear}.
This one-dimensional array can be implemented as a \texttt{StorageTreeArray<Tile>}.
There will be functions
for translating the conceptual representation into the internal one.

Create hence in Eclipse a new Maven Java 21 (or later) project. Use for this project the name
\texttt{io-hotmoka-tutorial-examples-tictactoe}.
You can do this by duplicating the project \texttt{io-hotmoka-tutorial-examples-family}.
Use the following \texttt{pom.xml}:
%
\begin{codebox}\begin{xmllst}
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <groupId>io.hotmoka</groupId>
  <artifactId>io-hotmoka-tutorial-examples-tictactoe</artifactId>
  <version>|\hotmokaVersion{}|</version>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.release>21</maven.compiler.release>
  </properties>

  <dependencies>
    <dependency>
      <groupId>io.hotmoka</groupId>
      <artifactId>io-takamaka-code</artifactId>
      <version>|\takamakaVersion{}|</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.11.0</version>
      </plugin>
    </plugins>
  </build>

</project>
\end{xmllst}\end{codebox}
%
and the following \texttt{module-info.java}:
%
\begin{codebox}\begin{javalst}
module tictactoe {
  requires io.takamaka.code;
}
\end{javalst}\end{codebox}
%
Create package \texttt{io.hotmoka.tutorial.examples.tictactoe}
inside \texttt{src/main/java} and add
the following \texttt{TicTacToe.java} source inside that package:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.tictactoe;

import static io.takamaka.code.lang.Takamaka.require;

import java.math.BigInteger;

import io.takamaka.code.lang.Contract;
import io.takamaka.code.lang.Exported;
import io.takamaka.code.lang.FromContract;
import io.takamaka.code.lang.Payable;
import io.takamaka.code.lang.PayableContract;
import io.takamaka.code.lang.Storage;
import io.takamaka.code.lang.StringSupport;
import io.takamaka.code.lang.View;
import io.takamaka.code.math.BigIntegerSupport;
import io.takamaka.code.util.StorageTreeArray;

public class TicTacToe extends Contract {

  @Exported
  public class Tile extends Storage {
    private final char c;

    private Tile(char c) {
      this.c = c;
    }

    @Override
    public String toString() {
      return String.valueOf(c);
    }

    private Tile nextTurn() {
      return this == CROSS ? CIRCLE : CROSS;
    }
  }

  private final Tile EMPTY = new Tile(' ');
  private final Tile CROSS = new Tile('X');
  private final Tile CIRCLE = new Tile('O');

  private final StorageTreeArray<Tile> board = new StorageTreeArray<>(9, EMPTY);
  private PayableContract crossPlayer;
  private PayableContract circlePlayer;
  private Tile turn = CROSS; // cross plays first
  private boolean gameOver;

  public @View Tile at(int x, int y) {
    require(1 <= x && x <= 3 && 1 <= y && y <= 3, "coordinates must be between 1 and 3");
    return board.get((y - 1) * 3 + x - 1);
  }

  private void set(int x, int y, Tile tile) {
    board.set((y - 1) * 3 + x - 1, tile);
  }

  public @Payable @FromContract(PayableContract.class) void play(long amount, int x, int y) {
    require(!gameOver, "the game is over");
    require(1 <= x && x <= 3 && 1 <= y && y <= 3, "coordinates must be between 1 and 3");
    require(at(x, y) == EMPTY, "the selected tile is not empty");

    PayableContract player = (PayableContract) caller();

    if (turn == CROSS)
      if (crossPlayer == null)
        crossPlayer = player;
      else
        require(player == crossPlayer, "it's not your turn");
    else
      if (circlePlayer == null) {
        require(crossPlayer != player, "you cannot play against yourself");
        long previousBet = BigIntegerSupport.subtract
          (balance(), BigInteger.valueOf(amount)).longValue();
        require(amount >= previousBet,
          () -> StringSupport.concat("you must bet at least ", previousBet, " coins"));
        circlePlayer = player;
      }
      else
        require(player == circlePlayer, "it's not your turn");

    set(x, y, turn);
    if (isGameOver(x, y))
      player.receive(balance());
    else
      turn = turn.nextTurn();
  }

  private boolean isGameOver(int x, int y) {
    if (at(x, 1) == turn && at(x, 2) == turn && at(x, 3) == turn) // column x
      return gameOver = true;

    if (at(1, y) == turn && at(2, y) == turn && at(3, y) == turn) // row y
      return gameOver = true;

    if (x == y && at(1, 1) == turn && at (2, 2) == turn && at(3, 3) == turn) // first diagonal
      return gameOver = true;

    if (x + y == 4 && at(1, 3) == turn && at(2, 2) == turn && at(3, 1) == turn) // second diagonal
      return gameOver = true;

    return gameOver = false;
  }

  @Override
  public @View String toString() {
    return StringSupport.concat(at(1, 1), "|", at(2, 1), "|", at(3, 1),
      "\n-----\n", at(1, 2), "|", at(2, 2), "|", at(3, 2),
      "\n-----\n", at(1, 3), "|", at(2, 3), "|", at(3, 3));
  }
}
\end{javalst}\end{codebox}

The internal class \texttt{Tile} represents the three alternatives that can be
put in the tic-tac-toe board. It overrides the default
\texttt{toString()} implementation, to yield the
usual representation for such alternatives; its \texttt{nextTurn()} method
alternates between cross and circle.

The board of the game is represented as a \texttt{new StorageTreeArray<>(9, EMPTY)}, whose
elements are indexed from zero to eight (inclusive) and are initialized to \texttt{EMPTY}.
It is also possible to construct the array as \texttt{new StorageTreeArray<>(9)}, but then
its elements would hold the default value \texttt{null} and the array would need to be initialized
inside a constructor for \texttt{TicTacToe}.

Methods \texttt{at()} and \texttt{set()} read and set the board element
at indexes $(x,y)$, respectively. They transform the two-dimensional conceptual representation
of the board into its internal one-dimensional representation. Since \texttt{at()} is public,
we defensively check the validity of the indexes there.

Method \texttt{play()} is the heart of the contract. Being called by the accounts
that play the game, it is annotated as \texttt{@FromContract}. It is also annotated as
\texttt{@Payable(PayableContract.class)} since players must bet money for
taking part in the game, at least for the first two moves, and receive
money if they win. The first
contract that plays is registered as \texttt{crossPlayer}. The second contract
that plays is registered as \texttt{circlePlayer}. Subsequent moves must
come, alternately, from \texttt{crossPlayer} and \texttt{circlePlayer}. The contract
uses a \texttt{turn} variable to keep track of the current turn.

Note the extensive use of \texttt{require()} to check all error situations:
%
\begin{enumerate}
\item It is possible to play only if the game is not over yet.
\item A move must be inside the board and identify an empty tile.
\item Players must alternate correctly.
\item The second player must bet at least as much as the first player.
\item It is not allowed to play against oneself.
\end{enumerate}

The \texttt{play()} method ends with a call to \texttt{gameOver()} that checks
if the game is over, that is, if the current player won.
In that case, the winner receives the full
jackpot. Note that the \texttt{gameOver()} method receives the coordinates
where the current player has moved. This allows it to restrict the
check for game over: the game is over only if the row or column
where the player moved contain the same tile; if the current player
played on a diagonal, the method checks the diagonals as well.
It is of course possible to check all rows, columns and diagonals, always,
but our solution is gas-thriftier.

The \texttt{toString()} method yields a string representation of the current board, such as
%
\begin{alltt}
X|O| 
-----
 |X|O
-----
 |X| 
\end{alltt}

\subsection{A more realistic tic-tac-toe contract}\label{subsec:more_realistic_tictactoe}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-tictactoe\_revised} project in \texttt{\hotmokaRepo{}})
\end{center}

The \texttt{TicTacToe.java} code implements the rules of a tic-tac-toe game, but has
a couple of drawbacks that make it still incomplete. Namely:
%
\begin{enumerate}
\item The creator of the game must spend gas to call its constructor,
  but has no direct incentive in doing so. He must be a benefactor,
  or hope to take part in the game after creation, if he is faster than
  any other potential player.
\item If the game ends in a draw, money gets stuck in the \texttt{TicTacToe} contract
  instance, for ever and ever.
\end{enumerate}

Replace hence the previous version of \texttt{TicTacToe.java} with the following
revised version. This new version solves
both problems at once. The policy is very simple: it imposes a minimum
bet, in order to avoid free games; if a winner emerges,
then the game forwards him only $90\%$ of the jackpot; the remaining $10\%$ goes to the
creator of the \texttt{TicTacToe} contract itself. If, instead, the game ends in a draw,
it forwards the whole jackpot to the creator.
Note that we added a \texttt{@FromContract} constructor, that takes
note of the \texttt{creator} of the game:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.tictactoe;

import static io.takamaka.code.lang.Takamaka.require;

import java.math.BigInteger;

import io.takamaka.code.lang.Contract;
import io.takamaka.code.lang.Exported;
import io.takamaka.code.lang.FromContract;
import io.takamaka.code.lang.Payable;
import io.takamaka.code.lang.PayableContract;
import io.takamaka.code.lang.Storage;
import io.takamaka.code.lang.StringSupport;
import io.takamaka.code.lang.View;
import io.takamaka.code.math.BigIntegerSupport;
import io.takamaka.code.util.StorageTreeArray;

public class TicTacToe extends Contract {

  @Exported
  public class Tile extends Storage {
    private final char c;

    private Tile(char c) {
      this.c = c;
    }

    @Override
    public String toString() {
      return String.valueOf(c);
    }

    private Tile nextTurn() {
      return this == CROSS ? CIRCLE : CROSS;
    }
  }

  private final Tile EMPTY = new Tile(' ');
  private final Tile CROSS = new Tile('X');
  private final Tile CIRCLE = new Tile('O');

  private static final long MINIMUM_BET = 100L;

  private final StorageTreeArray<Tile> board = new StorageTreeArray<>(9, EMPTY);
  private final PayableContract creator;
  private PayableContract crossPlayer;
  private PayableContract circlePlayer;
  private Tile turn = CROSS; // cross plays first
  private boolean gameOver;

  public @FromContract(PayableContract.class) TicTacToe() {
    creator = (PayableContract) caller();
  }

  public @View Tile at(int x, int y) {
    require(1 <= x && x <= 3 && 1 <= y && y <= 3, "coordinates must be between 1 and 3");
    return board.get((y - 1) * 3 + x - 1);
  }

  private void set(int x, int y, Tile tile) {
    board.set((y - 1) * 3 + x - 1, tile);
  }

  public @Payable @FromContract(PayableContract.class) void play(long amount, int x, int y) {
    require(!gameOver, "the game is over");
    require(1 <= x && x <= 3 && 1 <= y && y <= 3, "coordinates must be between 1 and 3");
    require(at(x, y) == EMPTY, "the selected tile is not empty");

    PayableContract player = (PayableContract) caller();

    if (turn == CROSS)
      if (crossPlayer == null) {
        require(amount >= MINIMUM_BET, () -> "you must invest at least " + MINIMUM_BET + " coins");
         crossPlayer = player;
      }
      else
        require(player == crossPlayer, "it's not your turn");
    else
      if (circlePlayer == null) {
        require(crossPlayer != player, "you cannot play against yourself");
        long previousBet = BigIntegerSupport.subtract
          (balance(), BigInteger.valueOf(amount)).longValue();
        require(amount >= previousBet,
          () -> StringSupport.concat("you must bet at least ", previousBet, " coins"));
        circlePlayer = player;
      }
      else
        require(player == circlePlayer, "it's not your turn");

    set(x, y, turn);
    if (isGameOver(x, y)) {
      // 90% goes to the winner
      player.receive(BigIntegerSupport.divide
        (BigIntegerSupport.multiply(balance(), BigInteger.valueOf(9L)), BigInteger.valueOf(10L)));
      // the rest to the creator of the game
      creator.receive(balance());
    }
    else if (isDraw())
      // everything goes to the creator of the game
      creator.receive(balance());
    else
      turn = turn.nextTurn();
  }

  private boolean isGameOver(int x, int y) {
    if (at(x, 1) == turn && at(x, 2) == turn && at(x, 3) == turn) // column x
      return gameOver = true;

    if (at(1, y) == turn && at(2, y) == turn && at(3, y) == turn) // row y
      return gameOver = true;

    if (x == y && at(1, 1) == turn && at (2, 2) == turn && at(3, 3) == turn) // first diagonal
      return gameOver = true;

    if (x + y == 4 && at(1, 3) == turn && at(2, 2) == turn && at(3, 1) == turn) // second diagonal
      return gameOver = true;

    return gameOver = false;
  }

  private boolean isDraw() {
    for (var tile: board)
      if (tile == EMPTY)
        return false;

    return true;
  }

  @Override
  public @View String toString() {
    return StringSupport.concat(at(1, 1), "|", at(2, 1), "|", at(3, 1),
      "\n-----\n", at(1, 2), "|", at(2, 2), "|", at(3, 2),
      "\n-----\n", at(1, 3), "|", at(2, 3), "|", at(3, 3));
  }
}    
\end{javalst}\end{codebox}

\begin{commentbox}
  We have chosen to allow a \texttt{long amount} in the \texttt{@Payable}
  method \texttt{play()} since
  it is unlikely that users will want to invest huge quantities of money in this
  game. This gives us the opportunity to discuss why the computation of the
  previous bet has been written as
  \begin{center}\begin{alltt}
    long previousBet = BigIntegerSupport.subtract
      (balance(), BigInteger.valueOf(amount)).longValue()
  \end{alltt}\end{center}
  instead of the simpler
  \texttt{long previousBet = balance().longValue() - amount}.
  The reason is that, when that line is executed, both players have already paid
  their bet, that accumulates in the balance of the \texttt{TicTacToe} contract.
  Each single bet is a \texttt{long}, but their sum could overflow the size of a \texttt{long}.
  Hence, we have to deal with a computation on \texttt{BigInteger}. The same situation
  occurs later, when we have to compute the $90\%$ that goes to the winner:
  the jackpot might be larger than a \texttt{long} and we have to compute over
  \texttt{BigInteger}. As a final remark, note that in the line:
  \begin{center}\begin{alltt}
      BigIntegerSupport.divide(BigIntegerSupport.multiply
        (balance(), BigInteger.valueOf(9L)), BigInteger.valueOf(10L))
  \end{alltt}\end{center}
  we \emph{first multiply} by $9$ and \emph{then divide} by $10$. This reduces the
  approximation inherent to integer division. For instance, if the jackpot
  (\texttt{balance()}) were 209, we have (with Java's left-to-right evaluation)
  $209\cdot 9/10=1881/10=188$ while $209/10\cdot 9=20\cdot 9=180$.
\end{commentbox}

\subsection{Running the tic-tac-toe contract}\label{subsec:running_tictactoe}

Let us play with the \texttt{TicTacToe} contract. Go in
the \texttt{io-hotmoka-tutorial-examples-tictactoe} project,
compile it with Maven and store it in the Hotmoka node:
%
\input{moka_jars_install_tictactoe_revised_command}
\input{moka_jars_install_tictactoe_revised_output}
%
Then we create an instance of the contract in the node:
%
\input{moka_objects_create_tictactoe_revised_command}
\input{moka_objects_create_tictactoe_revised_output}

We use two of our accounts now, that we have already created in the previous section,
to interact with the contract: they will play, alternately, until the first player wins.
We will report the resulting of calling \texttt{toString()} on the contract, after each move.

The first player starts, by playing at (1,1), and bets 100:
%
\input{moka_objects_call_tictactoe_play_1_command}
\input{moka_objects_call_tictactoe_play_1_output}
%
\input{moka_objects_call_tictactoe_toString_1_command}
\input{moka_objects_call_tictactoe_toString_1_output}
%
Note that the call to \texttt{toString()} does not require to provide the password of the key pair of the caller account,
since that method is a \texttt{@View} method: this means that moka runs a transaction to call it, it does not add a transaction.

The second player plays now, at (2,1), betting 100:
%
\input{moka_objects_call_tictactoe_play_2_command}
\input{moka_objects_call_tictactoe_play_2_output}
%
\input{moka_objects_call_tictactoe_toString_2_command}
\input{moka_objects_call_tictactoe_toString_2_output}
%
The first player replies, by playing at (1,2):
%
\input{moka_objects_call_tictactoe_play_3_command}
\input{moka_objects_call_tictactoe_play_3_output}
%
\input{moka_objects_call_tictactoe_toString_3_command}
\input{moka_objects_call_tictactoe_toString_3_output}
%
Then the second player plays at (2,2):
%
\input{moka_objects_call_tictactoe_play_4_command}
\input{moka_objects_call_tictactoe_play_4_output}
%
\input{moka_objects_call_tictactoe_toString_4_command}
\input{moka_objects_call_tictactoe_toString_4_output}
%
The first player wins by playing at (1,3):
%
\input{moka_objects_call_tictactoe_play_5_command}
\input{moka_objects_call_tictactoe_play_5_output}
%
\input{moka_objects_call_tictactoe_toString_5_command}
\input{moka_objects_call_tictactoe_toString_5_output}
%
We can verify that the game is over now:
%
\input{moka_objects_show_tictactoe_command}
\input{moka_objects_show_tictactoe_output}
%
As you can see, the \texttt{gameOver} field holds true. Moreover, the balance of the contract is zero since it has been distributed to
the winner and to the creator of the game (that actually coincide to our first account, in this specific run).

If the second player attempts to play now, the transaction will be rejected, since the game is over:
%
\input{moka_objects_call_tictactoe_play_6_command}
\input{moka_objects_call_tictactoe_play_6_output}

\subsection{Specialized storage array classes}\label{subsec:tspecialized_storage_array_classes}

The \texttt{StorageTreeArray<E>} class is very general, since it can be used to hold
any type \texttt{E} of storage values. Since it uses generics,
primitive values cannot be held in a \texttt{StorageTreeArray<E>}, directly.
For instance, \texttt{StorageTreeArray<byte>} is not legal syntax in Java.
Instead, one could think to use \texttt{StorageTreeArray<Byte>}, where \texttt{Byte}
is the Java wrapper class \texttt{java.lang.Byte}. However, that class is not
currently allowed in storage, hence \texttt{StorageTreeArray<Byte>} will not work either.
One should hence define a new wrapper class for \texttt{byte}, that extends \texttt{Storage}.
That is possible, but highly discouraged:
the use of wrapper classes introduces a level of indirection
and requires the instantiation of many small objects, which costs gas. Instead,
Takamaka provides specialized storage classes implementing arrays of bytes,
without wrappers. The rationale is that such arrays arise
naturally when dealing, for instance, with hashes or encrypted data
(see next section for an example) and consequently deserve
a specialized and optimized implementation.
Such specialized array classes
can have their length specified at construction time, or fixed to
a constant (for best optimization and minimal gas consumption).

\begin{figure}[th]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{pics/bytes}
  \end{center}
  \caption{The hierarchy of specialized byte array classes.}
  \label{fig:byte_array_hierarchy}
\end{figure}

Fig.~\ref{fig:byte_array_hierarchy} shows the hierarchy of the specialized classes for arrays of bytes,
available in Takamaka.
The interface \texttt{StorageByteArrayView}\index{StorageByteArrayView@{\texttt{StorageByteArrayView}}}
defines the methods that read data from an array
of bytes, while the interface \texttt{StorageByteArray}\index{StorageByteArray@{\texttt{StorageByteArray}}}
defines the modification methods.
Class \texttt{StorageTreeByteArray}\index{StorageTreeByteArray@{\texttt{StorageTreeByteArray}}}
allows one to create byte arrays of any length, specified at construction time.
Classes \texttt{Bytes32}\index{Bytes32@{\texttt{Bytes32}}} and
\texttt{Bytes32Snapshot}\index{Bytes32Snapshot@{\texttt{Bytes32Snapshot}}}
have, instead, fixed length of $32$ bytes;
their constructors include one that allows one to specify such $32$ bytes,
which is useful for calling the constructor from outside the node,
since \texttt{byte} is a storage type.
While a \texttt{Bytes32} is modifiable, instances of class \texttt{Bytes32Snapshot}
are not modifiable after being created and are \texttt{@Exported}.
There are sibling classes for different, fixed sizes, such as
\texttt{Bytes64} and \texttt{Bytes8Snaphot}. For a full description of the methods
of these classes and interfaces, we refer to their JavaDoc.

\section{Storage maps}\label{sec:storage_maps}

Maps are dynamic associations of objects to objects. They are useful
for programming smart contracts, as their extensive use in Solidity proves.
However, most such uses are related to the withdrawal pattern, that is
not needed in Takamaka. Nevertheless, there are still situations when
maps are useful in Takamaka code, as we show below.

Java has many implementations of maps.
However, they are not storage objects and consequently cannot be
stored in a Hotmoka node. This section describes the
Takamaka library class
\texttt{io.takamaka.code.util.StorageTreeMap<K,V>}\index{StorageTreeMap@{\texttt{StorageTreeMap}}},
that extends \texttt{Storage} and
whose instances can then be held in the store of a node, if
keys \texttt{K} and values \texttt{V} can be stored in a node as well.

\begin{figure}[th]
  \begin{center}
    \includegraphics[width=0.45\textwidth]{pics/maps}
  \end{center}
  \caption{The hierarchy of storage maps.}
  \label{fig:maps_hierarchy}
\end{figure}

We refer to the JavaDoc of \texttt{StorageTreeMap} for a full description of its methods,
that are similar to those of traditional Java maps. Here, we just observe
that a key is mapped into a value by calling method
\texttt{void put(K key, V value)}, while the value bound to a key is retrieved by calling
\texttt{V get(Object key)}. It is possible to yield a default value when a key is not
in the map, by calling \texttt{V getOrDefault(Object key, V \_default)} or
its sibling \texttt{V getOrDefault(Object key, Supplier<? extends V> \_default)}, that
evaluates the default value only if needed. Method \texttt{V putIfAbsent(K key, V value)},
binds the key to the value only if the key is unbound. Similarly for
its sibling \texttt{V computeIfAbsent(K key, Supplier<? extends V> value)} that, however,
evaluates the new value only if needed (these two methods differ for their
returned value, as in Java maps. Please refer to their JavaDoc).

Instances of \texttt{StorageTreeMap<K,V>} keep keys in increasing order. Namely, if
type \texttt{K} has a natural order, that order is used. Otherwise, keys
(that must be storage objects) are kept ordered by increasing storage
reference. Consequently, methods \texttt{forEach(Consumer<? super Entry<K,V>> action)},
\texttt{forEachKey(Consumer<? super K> action)} and
\texttt{forEachValue(Consumer<? super V> action)}
perform an internal iteration of the elements of the map, in order.
%
\begin{commentbox}
Compare this with Solidity, where maps do not know the set of their keys nor the
set of their values.
\end{commentbox}

Fig.~\ref{fig:maps_hierarchy} shows the hierarchy of the \texttt{StorageTreeMap<K,V>} class.
It implements the interface \texttt{StorageMap<K,V>}\index{StorageMap@{\texttt{StorageMap}}},
that defines the methods that modify a map.
That interface extends the interface \texttt{StorageMapView<K,V>}\index{StorageMapView@{\texttt{StorageMapView}}}
that, instead, defines the methods that read data from a map, but do not modify it.
Methods \texttt{snapshot()} and \texttt{view()} return an \texttt{@Exported}
\texttt{StorageMapView<K,V>}, in constant time.

There are also specialized map classes, optimized
for specific primitive types of keys, such as
\texttt{StorageTreeIntMap<V>}\index{StorageTreeIntMap@{\texttt{StorageTreeIntMap}}},
whose keys are \texttt{int} values. We refer to their JavaDoc for further information.

\section{A blind auction contract}\label{subsec:blind_auction}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-auction} project in \texttt{\hotmokaRepo{}})
\end{center}

This section exemplifies the use of class \texttt{StorageTreeMap} by writing a smart
contract that implements a \emph{blind auction}. That contract allows
a \emph{beneficiary} to sell an item to the buying contract that offers
the highest bid. Since data in blockchain is public, in a non-blind
auction it is possible that bidders eavesdrop the offers of other bidders
in order to place an offer that is only slightly higher than the current
best offer. A blind auction, instead, uses a two-phases
mechanism: in the initial \emph{bidding time}, bidders place bids, hashed, so that
they do not reveal their amount. After the bidding time expires, the second
phase, called \emph{reveal time}, allows bidders to
reveal the real values of their bids and the auction contract to determine
the actual winner.
This works since, to reveal a bid, each bidder provides the real data
of the bid. The auction contract then recomputes the hash from real data and
checks if the result matches the hash provided at bidding time.
If not, the bid is considered invalid. Bidders can even place fake offers
on purpose, in order to confuse other bidders.

Create in Eclipse a new Maven Java 21 (or later) project. Use for this project the name
\texttt{io-hotmoka-tutorial-examples-auction}.
You could do this for instance by duplicating the project \texttt{io-hotmoka-tutorial-examples-family}.
Use the following \texttt{pom.xml}:
%
\begin{codebox}\begin{xmllst}
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <groupId>io.hotmoka</groupId>
  <artifactId>io-hotmoka-tutorial-examples-auction</artifactId>
  <version>|\hotmokaVersion{}|</version>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.release>21</maven.compiler.release>
  </properties>

  <dependencies>
    <dependency>
      <groupId>io.hotmoka</groupId>
      <artifactId>io-takamaka-code</artifactId>
      <version>|\takamakaVersion{}|</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.11.0</version>
      </plugin>
    </plugins>
  </build>

</project>
\end{xmllst}\end{codebox}
%
and the following \texttt{module-info.java}:
%
\begin{codebox}\begin{javalst}
module auction {
  requires io.takamaka.code;
}
\end{javalst}\end{codebox}

Create package \texttt{io.hotmoka.tutorial.examples.auction}
inside \texttt{src/main/java} and add
the following \texttt{BlindAuction.java} inside that package.
It is a Takamaka contract that implements
a blind auction. Since each bidder may place more bids and since such bids
must be kept in storage until reveal time, this code uses a map
from bidders to lists of bids. This smart contract has been inspired
by a similar Ethereum contract in Solidity available at
\url{https://docs.soliditylang.org/en/v0.8.33/solidity-by-example.html#blind-auction}.
Please note that the code below does not compile yet, since it misses two classes
that we will define in the next section.

%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.auction;

import static io.takamaka.code.lang.Takamaka.event;
import static io.takamaka.code.lang.Takamaka.now;
import static io.takamaka.code.lang.Takamaka.require;

import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.util.function.Supplier;

import io.takamaka.code.lang.Contract;
import io.takamaka.code.lang.Exported;
import io.takamaka.code.lang.FromContract;
import io.takamaka.code.lang.Payable;
import io.takamaka.code.lang.PayableContract;
import io.takamaka.code.lang.Storage;
import io.takamaka.code.lang.StringSupport;
import io.takamaka.code.math.BigIntegerSupport;
import io.takamaka.code.security.SHA256Digest;
import io.takamaka.code.util.Bytes32Snapshot;
import io.takamaka.code.util.StorageLinkedList;
import io.takamaka.code.util.StorageList;
import io.takamaka.code.util.StorageMap;
import io.takamaka.code.util.StorageTreeMap;

/**
* A contract for a simple auction. This class is derived from the Solidity
* code shown at https://docs.soliditylang.org/en/v0.8.33/
* solidity-by-example.html#blind-auction
* In this contract, bidders place bids together with a hash. At the end of
* the bidding period, bidders are expected to reveal if and which of their
* bids were real and their actual value. Fake bids are refunded. Real bids
* are compared and the bidder with the highest bid wins.
*/
public class BlindAuction extends Contract {

  /**
  * A bid placed by a bidder. The deposit has been payed in full.
  * If, later, the bid will be revealed as fake, then the deposit will
  * be fully refunded. If, instead, the bid will be revealed as real, but
  * for a lower amount, then only the difference will be refunded.
  */
  private static class Bid extends Storage {

    /**
    * The hash that will be regenerated and compared at reveal time.
    */
    private final Bytes32Snapshot hash;

    /**
    * The value of the bid. Its real value might be lower and known
    * at real time only.
    */
    private final BigInteger deposit;

    private Bid(Bytes32Snapshot hash, BigInteger deposit) {
      this.hash = hash;
      this.deposit = deposit;
    }

    /**
    * Recomputes the hash of a bid at reveal time and compares it
    * against the hash provided at bidding time. If they match,
    * we can reasonably trust the bid.
    * 
    * @param revealed the revealed bid
    * @param digest the hasher
    * @return true if and only if the hashes match
    */
    private boolean matches(RevealedBid revealed, SHA256Digest digest) {
      digest.update(BigIntegerSupport.toByteArray(revealed.value));
      digest.update(revealed.fake ? (byte) 0 : (byte) 1);
      digest.update(revealed.salt.toArray());
      byte[] arr1 = hash.toArray();
      byte[] arr2 = digest.digest();

      if (arr1.length != arr2.length)
        return false;

      for (int pos = 0; pos < arr1.length; pos++)
        if (arr1[pos] != arr2[pos])
          return false;

      return true;
    }
  }

  /**
  * A bid revealed by a bidder at reveal time. The bidder shows
  * if the corresponding bid was fake or real, and how much was the
  * actual value of the bid. This might be lower than previously
  * communicated.
  */
  @Exported
  public static class RevealedBid extends Storage {
    private final BigInteger value;
    private final boolean fake;

    /**
    * The salt used to strengthen the hashing.
    */
    private final Bytes32Snapshot salt;

    public RevealedBid(BigInteger value, boolean fake, Bytes32Snapshot salt) {
      this.value = value;
      this.fake = fake;
      this.salt = salt;
    }
  }

  /**
  * The beneficiary that, at the end of the reveal time, will receive
  * the highest bid.
  */
  private final PayableContract beneficiary;

  /**
  * The bids for each bidder. A bidder might place more bids.
  */
  private final StorageMap<PayableContract, StorageList<Bid>> bids = new StorageTreeMap<>();

  /**
  * The time when the bidding time ends.
  */
  private final long biddingEnd;

  /**
  * The time when the reveal time ends.
  */
  private final long revealEnd;

  /**
  * The bidder with the highest bid, at reveal time.
  */
  private PayableContract highestBidder;

  /**
  * The highest bid, at reveal time.
  */
  private BigInteger highestBid;

  /**
  * Creates a blind auction contract.
  * 
  * @param biddingTime the length of the bidding time
  * @param revealTime the length of the reveal time
  */
  public @FromContract(PayableContract.class) BlindAuction(int biddingTime, int revealTime) {
    require(biddingTime > 0, "Bidding time must be positive");
    require(revealTime > 0, "Reveal time must be positive");

    this.beneficiary = (PayableContract) caller();
    this.biddingEnd = now() + biddingTime;
    this.revealEnd = biddingEnd + revealTime;
  }

  /**
  * Places a blinded bid the given hash.
  * The sent money is only refunded if the bid is correctly
  * revealed in the revealing phase. The bid is valid if the
  * money sent together with the bid is at least "value" and
  * "fake" is not true. Setting "fake" to true and sending
  * not the exact amount are ways to hide the real bid but
  * still make the required deposit. The same bidder can place multiple bids.
  */
  public @Payable @FromContract(PayableContract.class) void bid(BigInteger amount, Bytes32Snapshot hash) {
    onlyBefore(biddingEnd);
    bids.computeIfAbsent((PayableContract) caller(),
     (Supplier<? extends StorageList<Bid>>) StorageLinkedList::new).add(new Bid(hash, amount));
  }

  /**
  * Reveals a bid of the caller. The caller will get a refund for all
  * correctly blinded invalid bids and for all bids except
  * for the totally highest.
  * 
  * @param revealed the revealed bid
  * @throws NoSuchAlgorithmException if the hashing algorithm is not available
  */
  public @FromContract(PayableContract.class) void reveal(RevealedBid revealed)
      throws NoSuchAlgorithmException {
    onlyAfter(biddingEnd);
    onlyBefore(revealEnd);
    PayableContract bidder = (PayableContract) caller();
    StorageList<Bid> bids = this.bids.get(bidder);
    require(bids != null && bids.size() > 0, "No bids to reveal");
    require(revealed != null, () -> "The revealed bid cannot be null");

    // any other hashing algorithm will do, as long as both
    // bidder and auction contracts use the same
    var digest = new SHA256Digest();
    // by removing the head of the list, it makes it impossible for the caller
    // to re-claim the same deposits
    bidder.receive(refundFor(bidder, bids.removeFirst(), revealed, digest));
  }

  public PayableContract auctionEnd() {
    onlyAfter(revealEnd);
    PayableContract winner = highestBidder;
		
    if (winner != null) {
      beneficiary.receive(highestBid);
      event(new AuctionEnd(winner, highestBid));
      highestBidder = null;
    }

    return winner;
  }

  /**
  * Checks how much of the deposit should be refunded for a given bid.
  * 
  * @param bidder the bidder that placed the bid
  * @param bid the bid, as was placed at bidding time
  * @param revealed the bid, as was revealed later
  * @param digest the hashing algorithm
  * @return the amount to refund
  */
  private BigInteger refundFor(PayableContract bidder, Bid bid, RevealedBid revealed,
                               SHA256Digest digest) {
    if (!bid.matches(revealed, digest))
      // the bid was not actually revealed: no refund
      return BigInteger.ZERO;
    else if (!revealed.fake && BigIntegerSupport.compareTo(bid.deposit, revealed.value) >= 0
             && placeBid(bidder, revealed.value))
      // the bid was correctly revealed and is the best up to now:
      // only the difference between promised and provided is refunded;
      // the rest might be refunded later if a better bid will be revealed
      return BigIntegerSupport.subtract(bid.deposit, revealed.value);
    else
      // the bid was correctly revealed and is not the best one:
      // it is fully refunded
      return bid.deposit;
  }

  /**
  * Takes note that a bidder has correctly revealed a bid for the given value.
  * 
  * @param bidder the bidder
  * @param value the value, as revealed
  * @return true if and only if this is the best bid, up to now
  */
  private boolean placeBid(PayableContract bidder, BigInteger value) {
    if (highestBid != null && BigIntegerSupport.compareTo(value, highestBid) <= 0)
      // this is not the best bid seen so far
      return false;

    // if there was a best bidder already, its bid is refunded
    if (highestBidder != null)
      // refund the previously highest bidder
      highestBidder.receive(highestBid);

    // take note that this is the best bid up to now
    highestBid = value;
    highestBidder = bidder;
    event(new BidIncrease(bidder, value));

    return true;
  }

  private static void onlyBefore(long when) {
    long diff = now() - when;
    require(diff <= 0, StringSupport.concat(diff, " ms too late"));
  }

  private static void onlyAfter(long when) {
    long diff = now() - when;
    require(diff >= 0, StringSupport.concat(-diff, " ms too early"));
  }
}
\end{javalst}\end{codebox}