\chapter{The support library}\label{ch:support_library}

This chapter presents the support library of the Takamaka language,
that contains classes for simplifying the definition of smart contracts.

In Sec.~\ref{sec:storage-types-and-constraints-on-storage-classes},
we said that storage objects must obey to some constraints.
The strongest of them is that their fields of reference type, in turn, can only hold
storage objects. In particular, arrays are not allowed there. This can
be problematic, in particular for contracts that deal with a
dynamic, variable, potentially unbound number of other contracts.

Therefore, most classes of the support library deal
with such constraints, by providing fixed or variable-sized collections
that can be used in storage objects, since they are storage objects themselves.
Such utility classes implement lists, arrays and maps and are
consequently generally described as \emph{collections}. They have the
property of being storage classes, hence their instances can be kept in
the store of a Hotmoka node,
\emph{as long as only storage objects are added as elements of the collection}.
As usual with collections, these utility classes
have generic type, to implement collections of arbitrary, but fixed
types. This is not problematic, since Java (and hence Takamaka) allows generic types.

\section{Storage lists}\label{sec:storage_lists}

Lists are an ordered sequence of elements. In a list, it is typically
possible to access the first element in constant time, while accesses
to the \emph{n}th element require to scan the list from its head and
consequently have a cost proportional to \emph{n}. Because of this,
lists are \emph{not}, in general, random-access data structures, whose \emph{n}th
element should be accessible in constant time. It is also possible
to add an element at the beginning of a list, in constant time.
The size of a list is not fixed: lists grow in size as more elements are added.

\begin{figure}[th]
  \begin{center}
    \includegraphics[width=0.45\textwidth]{pics/lists}
  \end{center}
  \caption{The hierarchy of storage lists.}
  \label{fig:lists_hierarchy}
\end{figure}

Java has many classes for implementing lists, all subclasses
of \texttt{java.util.List<E>}. They cannot be used in Takamaka that, instead,
provides an implementation of lists with the storage class
\texttt{io.takamaka.code.util.StorageLinkedList<E>}\index{StorageLinkedList@{\texttt{StorageLinkedList}}}.
Its instances are storage objects and
can consequently be held in fields of storage classes and
can be stored in a Hotmoka node,
\emph{as long as only storage objects are added to the list}. Takamaka lists provide
constant-time access and addition to both ends of a list.
We refer to the JavaDoc of \texttt{StorageLinkedList<E>} for a full description of its methods.
They include methods for adding elements to either ends of the list, for accessing and
removing elements, for iterating on a list and for building a Java array
\texttt{E[]} holding the elements of a list.

Fig.~\ref{fig:lists_hierarchy} shows the hierarchy of the \texttt{StorageLinkedList<E>} class.
It implements the interface \texttt{StorageList<E>}, that defines the methods that modify a list.
That interface extends the interface \texttt{StorageListView<E>} that, instead, defines the methods
that read data from a list, but do not modify it. This distinction between the \emph{read-only}
interface and the \emph{modification} interface is typical of all collection classes in the
Takamaka library, as we will see. For the moment, note that this distinction is useful
for defining methods \texttt{snapshot()}\index{snapshot()@{\texttt{snapshot()}}}
and \texttt{view()}\index{view()@{\texttt{view()}}}. Both return
a \texttt{StorageListView<E>} but there
is an important difference between them. Namely, \texttt{snapshot()} yields a
\emph{frozen} view of the list,
that cannot and will never be modified, also if the original list gets subsequently updated.
Instead,
\texttt{view()} yields a \emph{view} of a list, that is, a read-only list that changes whenever
the original list changes and exactly in the same way: if an element is added to the original
list, the same automatically occurs to the view.
In this sense, a view is just a read-only alias of the original list.
Both methods can be useful to export data, safely,
from a node to the outside world, since both methods
return an \texttt{@Exported}\index{Exported@{\texttt{Exported}}}
object without modification methods.
Method \texttt{snapshot()} runs in linear time (in the length of the list)
while method \texttt{view()} runs in constant time.
%
\begin{commentbox}
It might seem that \texttt{view()} is just an upwards cast to the
interface \texttt{StorageListView<E>}. This is wrong, since that method
does much more. Namely, it applies the façade design pattern
to provide a \emph{distinct} list that lacks any modification method
and implements a façade of the original list.
To appreciate the difference to a cast, assume to have a \texttt{StorageList<E> list} and to write
\texttt{StorageListView<E> view = (StorageListView<E>) list}. This upwards cast will always succeed.
Variable \texttt{view} does not allow to call any modification method, since they
are not in its static type \texttt{StorageListView<E>}. But a downwards cast back
to \texttt{StorageList<E>} is enough to circumvent
that constraint: \texttt{StorageList<E> list2 = (StorageList<E>) view}.
This way, the original \texttt{list}
can be modified by modifying \texttt{list2} and it would not be safe to export
\texttt{view}, since it
is a Trojan horse for the modification of \texttt{list}. With method \texttt{view()}, the
problem does not arise, since the cast \texttt{StorageList<E> list2 = (StorageList<E>) list.view()}
fails: method \texttt{view()} actually returns another list object without modification methods.
The same is true for method \texttt{snapshot()} that, moreover, yields a frozen view of the
original list. These same considerations hold for the other Takamaka collections that we will
see in this chapter.
\end{commentbox}

Next section shows an example of use for \texttt{StorageLinkedList}.

\section{A gradual Ponzi contract}\label{sec:gradual_ponzi}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-ponzi\_gradual} project in \texttt{\hotmokaRepo{}})
\end{center}

Consider our previous Ponzi contract from Ch.~\ref{ch:smart_contracts}
It is somehow irrealistic, since
an investor gets its investment back in full. In a more realistic scenario,
the investor will receive the investment back gradually, as soon as new
investors arrive. This is more complex to program, since
the Ponzi contract must take note of all investors that invested up to now,
not just of the current one as in \emph{SimplePonzi.java}. This requires a
list of investors, of unbounded size. An implementation of this gradual
Ponzi contract is reported below and has been
inspired by a similar Ethereum contract from Iyer and Dannen,
shown at page 150 of~\cite{IyerD18}.
Write its code inside package \texttt{io.hotmoka.tutorial.examples.ponzi} of
the \texttt{io-hotmoka-tutorial-examples-ponzi} project, as a new class
\texttt{GradualPonzi.java}:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.ponzi;

import static io.takamaka.code.lang.Takamaka.require;

import java.math.BigInteger;

import io.takamaka.code.lang.Contract;
import io.takamaka.code.lang.FromContract;
import io.takamaka.code.lang.Payable;
import io.takamaka.code.lang.PayableContract;
import io.takamaka.code.lang.StringSupport;
import io.takamaka.code.math.BigIntegerSupport;
import io.takamaka.code.util.StorageLinkedList;
import io.takamaka.code.util.StorageList;

public class GradualPonzi extends Contract {
  public final BigInteger MINIMUM_INVESTMENT = BigInteger.valueOf(1_000L);

  /**
   * All investors up to now. This list might contain the same investor many
   * times, which is important to pay him back more than investors
   * who only invested once.
   */
  private final StorageList<PayableContract> investors = new StorageLinkedList<>();

  public @FromContract(PayableContract.class) GradualPonzi() {
    investors.add((PayableContract) caller());
  }

  public @Payable @FromContract(PayableContract.class) void invest(BigInteger amount) {
    // new investments must be at least 10% greater than current
    require(BigIntegerSupport.compareTo(amount, MINIMUM_INVESTMENT) >= 0,
      () -> StringSupport.concat("you must invest at least ", MINIMUM_INVESTMENT));
    BigInteger eachInvestorGets = BigIntegerSupport.divide
      (amount, BigInteger.valueOf(investors.size()));
    investors.forEach(investor -> investor.receive(eachInvestorGets));
    investors.add((PayableContract) caller());
  }
}
\end{javalst}\end{codebox}

The constructor of \texttt{GradualPonzi} is annotated as \texttt{@FromContract}. Therefore,
it can only be called by a contract and the latter that gets added, as first investor,
inside the field \texttt{investors}, of type \texttt{io.takamaka.code.util.StorageLinkedList}.
This list, that implements an unbounded list of objects,
is a storage object, as long as only storage objects are
added inside it. \texttt{PayableContract}s are storage objects, hence
its use is correct here.
Subsequently, other contracts can invest by calling method \texttt{invest()}.
A minimum investment is required, but this remains constant over time.
The \texttt{amount} invested gets split by the number of the previous investors
and sent back to each of them. Note that Takamaka allows programmers to use Java's lambdas.
Old fashioned Java programmers, who don't feel at home with such treats,
can exploit the fact that
storage lists are iterable and replace the single-line \texttt{forEach()} call
with a more traditional (but gas-hungrier):
%
\begin{codebox}\begin{javalst}
for (PayableContract investor: investors)
  investor.receive(eachInvestorGets);
\end{javalst}\end{codebox}
%
It is instead \emph{highly discouraged} to iterate the list as if it were an
array. Namely, \emph{do not write}
%
\begin{codebox}\begin{javalst}
for (int pos = 0; pos < investors.size(); pos++)
  investors.get(i).receive(eachInvestorGets);
\end{javalst}\end{codebox}
%
since linked lists are not random-access data structures and the complexity of the
last loop is quadratic in the size of the list. This is not a novelty: the
same occurs with many traditional Java lists that do not implement
\texttt{java.util.RandomAccess} (such as \texttt{java.util.LinkedList}).
In Takamaka, code execution costs gas and
computational complexity does matter, more than in other programming contexts.

\section{A note on re-entrancy}\label{sec:reentrancy}

The \texttt{GradualPonzi.java} class pays back previous investors immediately:
as soon as a new investor invests something, his investment gets
split and forwarded to all previous investors. This should
make Solidity programmers uncomfortable, since the same approach,
in Solidity, might lead to the infamous re-entrancy\index{re-entrancy} attack, when the
contract that receives his investment back has a
fallback function redefined in such a way to re-enter the paying contract and
re-execute the distribution of the investment.
As it is well known, such an attack has made some people rich and other
desperate. You can find more detail
in~\cite{AntonopoulosWPMP25}.
Even if such a frightening scenario does not occur,
paying back previous investors immediately is discouraged in Solidity
also for other reasons. Namely, the contract that receives his
investment back might have a redefined fallback function that
consumes too much gas or does not terminate. This would hang the
loop that pays back previous investors, actually locking the
money inside the \texttt{GradualPonzi} contract. Moreover, paying back
a contract is a relatively expensive operation in Solidity, even if the
fallback function is not redefined, and this cost is paid by the
new investor that called \texttt{invest()}, in terms of gas. The cost is linear
in the number of investors that must be paid back.

As a solution to these problems, Solidity programmers do not pay previous
investors back immediately, but let the \texttt{GradualPonzi} contract take
note of the balance of each investor, through a map.
This map is updated as soon as a new investor arrives, by increasing the
balance of every previous investor. The cost of updating the balances
is still linear in the number of previous investors, but it is cheaper
(in Solidity) than sending money back to each of them, which
requires expensive inter-contract calls that trigger new sub-transactions.
With this technique, previous investors are
now required to withdraw their balance explicitly and voluntarily,
through a call to some function, typically called \texttt{widthdraw()}.
This leads to the \emph{withdrawal pattern}, widely used for writing Solidity contracts.

We have not used the withdrawal pattern in \texttt{GradualPonzi.java}. In general,
there is no need for such pattern in Takamaka, at least not for simple
contracts like \texttt{GradualPonzi.java}. The reason is that the
\texttt{receive()}\index{receive()@{\texttt{receive()}}}
method of a payable contract (corresponding to the
fallback function of Solidity) are \texttt{final} in Takamaka and very cheap
in terms of gas. In particular, inter-contract calls are not
especially expensive in Takamaka, since they are just a method
invocation in Java bytecode (one bytecode instruction). They are \emph{not} inner transactions.
They are actually cheaper than
updating a map of balances. Moreover, avoiding the \texttt{withdraw()} transactions
reduces the overall number of transactions;
without using the map supporting the withdrawal pattern, Takamaka contracts
consume less gas and less storage.
Hence, the withdrawal pattern is both
useless in Takamaka and more expensive than paying back previous contracts immediately.
