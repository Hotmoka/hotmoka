\chapter{A first Takamaka program}\label{ch:a_first_takamaka_program}

Takamaka\index{Takamaka} is the language that can be used to write
smart contracts for Hotmoka nodes. Hotmoka
nodes and Takamaka code have exactly the same
relation as Ethereum nodes and Solidity code.

Let us start from a simple example of Takamaka code. Since we are
writing Java code, there is nothing special to learn or install
before starting writing programs in Takamaka. Just use your
preferred integrated development environment (IDE) for Java. Or even
do everything from command-line, if you prefer. Our examples below will be
shown for the Eclipse IDE, using Java 21 or later, but you can perfectly well
use the IntelliJ IDE instead.

Our goal will be to create a Java class that we will instantiate
and use in blockchain. Namely, we will learn how to create an object
of that class, that will be persisted in blockchain, and how we can later
call the \texttt{toString()} method on that instance in blockchain.

\section{Creation of the Eclipse project}\label{sec:creation_first_eclipse_project}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-family} project in \texttt{\hotmokaRepo{}})
\end{center}

Let us create a Maven project \texttt{io-hotmoka-tutorial-examples-family} inside Eclipse,
in the \texttt{\hotmokaTutorialDir} directory.
For that, in the Eclipse's Maven wizard
(\emph{New}$\rightarrow$\emph{Maven project}) specify the options
\emph{Create a simple project (skip archetype selection)}
and deselect the \emph{Use default Workspace directory} option,
specifying a subdirectory \texttt{io-hotmoka-tutorial-examples-family}
of the \texttt{\hotmokaTutorialDir{}} directory as \emph{Location} instead.
Hence, \emph{Location} should be something that ends
with \texttt{\ldots/\hotmokaTutorialDir{}/io-hotmoka-tutorial-examples-family}.
Do not add the project to any working set. Use \texttt{io.hotmoka}
as \emph{Group Id} and use the directory name
\texttt{io-hotmoka-tutorial-examples-family} as \emph{Artifact Id}.

\begin{commentbox}
The \emph{Group Id} can be changed as you prefer, but we will stick
to \texttt{io.hotmoka} to show the exact files that you will see in the provided code.
\end{commentbox}

By clicking \emph{Finish} in the Eclipse's Maven wizard, you should see
a new Maven project in the Eclipse's explorer.
Currently, Eclipse creates a default \texttt{pom.xml} file that uses Java 5
and has no dependencies. Replace hence
the content of the \texttt{pom.xml} file that has been created in the
\texttt{io-hotmoka-tutorial-examples-family} project with the following code:
%
\begin{codebox}\begin{xmllst}
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <groupId>io.hotmoka</groupId>
  <artifactId>io-hotmoka-tutorial-examples-family</artifactId>
  <version>|\hotmokaVersion{}|</version>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.release>21</maven.compiler.release>
  </properties>

  <dependencies>
    <dependency>
      <groupId>io.hotmoka</groupId>
      <artifactId>io-takamaka-code</artifactId>
      <version>|\takamakaVersion{}|</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.11.0</version>
      </plugin>
    </plugins>
  </build>

</project>
\end{xmllst}\end{codebox}
%
It specifies to use Java 21 and provides the dependency
to \texttt{io-takamaka-code}, that is, the run-time classes of the Takamaka smart contracts.

\begin{commentbox}
We are using \texttt{\takamakaVersion{}} here, as version of the Takamaka runtime
project. You can replace that, if needed, with the latest version of the project.
\end{commentbox}

Since the \texttt{pom.xml} file has changed, Eclipse will normally show an error
in the project. To solve it,
you need to update the Maven dependencies of the project:
right-click on the project then \emph{Maven}$\rightarrow$\emph{Update Project}.
The imported dependency \texttt{io-takamaka-code},
that contains the Takamaka runtime, should be downloaded
and everything should compile without errors.
The result in Eclipse should look similar to what is
shown in Fig.~\ref{fig:family}.
%
\begin{figure}[t]
  \begin{center}
    \includegraphics[width=5cm]{pics/family}
  \end{center}
  \caption{The family Eclipse project.}
  \label{fig:family}
\end{figure}

Create a \texttt{module-info.java} file inside \texttt{src/main/java}
(right-click on the project, then \emph{Configure}$\rightarrow$\emph{Create module-info.java}$\rightarrow$\emph{Create}),
to state that this project depends on the module containing the runtime of Takamaka:
%
\begin{codebox}\begin{javalst}
module family {
  requires io.takamaka.code;
}
\end{javalst}\end{codebox}

Create a package \texttt{io.hotmoka.tutorial.examples.family}
inside \texttt{src/main/java}. Inside that package,
create a Java source \texttt{Person.java}, by copying and pasting the following code:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.family;

import io.takamaka.code.lang.StringSupport;

public class Person {
  private final String name;
  private final int day;
  private final int month;
  private final int year;
  public final Person parent1;
  public final Person parent2;

  public Person(String name, int day, int month, int year, Person parent1, Person parent2) {
    this.name = name;
    this.day = day;
    this.month = month;
    this.year = year;
    this.parent1 = parent1;
    this.parent2 = parent2;
  }

  public Person(String name, int day, int month, int year) {
    this(name, day, month, year, null, null);
  }

  @Override
  public String toString() {
    return StringSupport.concat(name, " (", day, "/", month, "/", year, ")");
  }
}
\end{javalst}\end{codebox}

This is a plain old Java class and should not need any comment.
The only observation is that we concat strings
with the support class \texttt{StringSupport}\index{StringSupport@{\texttt{StringSupport}}},
since the standard string concatenation
of Java would end up
calling methods whose computational cost is not foreseeable in advance. In general,
a very small portion of the
Java library can be used directly in Takamaka,
and support classes\index{support class} are used to replace some common functionalities,
such as string concatenation.

Package the project into a jar and install it in the local Maven repository,
by running the Maven command \texttt{mvn install} inside
the directory of the project (that is, inside the subdirectory
\texttt{\hotmokaTutorialDir{}/io-hotmoka-tutorial-examples-family}).
This should generate a file named
\texttt{io-hotmoka-tutorial-examples-family-\hotmokaVersion{}.jar},
inside the \texttt{target} directory. Only the compiled
class files will be relevant: Hotmoka nodes will ignore source files, manifest
and any resources in the jar; the same compiled
\texttt{module-info.class} is irrelevant for Hotmoka.
All such files can be removed from the jar, to reduce the gas cost of their
installation in the store of a node, but we do not care about this optimization here.
The result should look as in Fig.~\ref{fig:family_jar}.
%
\begin{figure}[t]
  \begin{center}
    \includegraphics[width=5cm]{pics/family_jar}
  \end{center}
  \caption{The family Eclipse project, exported in jar.}
  \label{fig:family_jar}
\end{figure}

\section{Installation of a jar in a Hotmoka node}\label{sec:jar_installation}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-runs} project in \texttt{\hotmokaRepo{}})
\end{center}

We have generated the jar containing our code and we want to send it now to a Hotmoka node,
where it will be installed. This means that it will become available to programmers
who want to use its classes, directly or as dependencies of their programs.
In order to install a jar in the Hotmoka node that we have used in the previous chapter,
we can use the moka command-line tool, specifying which account will pay for the
installation of the jar. The cost of the installation depends on the size of the
jar and on the number of its dependencies. The moka tool uses a heuristics to
foresee this cost, that can be overridden if needed.

Move inside the \texttt{\hotmokaTutorialDir{}} directory, if you are not
there already, so that
moka will find your saved key pair there, and run the \texttt{moka jars install} command:
%
\input{moka_jars_install_command}\index{jar!install}
\input{moka_jars_install_output}
%
As you can see above, the jar has been installed at a reference
\texttt{\familyAddressShort{}}, that can be used
later to refer to that jar. This has costed some gas, paid by our account.
You can verify that the balance of the account has been decreased, through the
\texttt{moka objects show} command.

The state of the Hotmoka nodes of the network is now as in Fig.~\ref{fig:jar_installed}.
As shown there, a dependency has been automatically created\index{jar!dependency}
from \texttt{io-hotmoka-tutorial-examples-family-\hotmokaVersion{}.jar} to
\texttt{io-takamaka-code-\takamakaVersion{}.jar}. This is because all Takamaka code
will use the run-time classes of the Takamaka language,
hence the \texttt{moka jars install} command adds them, by default.
That command allows to explicitly specify other dependencies, for more complicated uses.
Note that a dependency must already be installed in the node
before it can be used as dependency of other jars.
%
\begin{figure}[t]
  \begin{center}
    \begin{tikzpicture}[scale=0.45,>=Stealth]
      \draw[rounded corners] (0,-13.5) rectangle (21,19.3) [fill=statebackgroundcolor];

      \draw[rounded corners] (0.5,16) rectangle +(20,2.8) [fill=jarbackgroundcolor];
      \draw (1,18) node[right] {jar: classes of the Takamaka runtime, such as};
      \draw (1,17) node[right] {\texttt{Contract}, \texttt{Storage}, \texttt{@View}, \texttt{@FromContract}\ldots};
      \draw (-2,18.2) node[left] {Takamaka code};
      \draw (-2,17.1) node[left] {at \texttt{\takamakaCodeShort{}}};
      \draw[->,thick] (-2,17.5) -- +(2.5,0);

      \draw[->,thick] (6,13.3) -- +(0,2.7);
      \draw (6,14.8) node[left] {classpath};
      \draw (-2,12.8) node[left] {manifest};
      \draw (-2,11.7) node[left] {at \texttt{\manifestShort{}}};
      \draw[->,thick] (-2,12.3) -- +(2.5,0);

      \draw[rounded corners] (0.5,10.8) rectangle +(11,2.8) [fill=objectbackgroundcolor];
      \draw (1,12.7) node[right] {chainId: \chainId{}};
      \draw (1,11.7) node[right] {signature: ed25519};

      \draw[<-,thick] (4,8.1) -- +(0,2.7);
      \draw (4,9.5) node[right] {gamete};
      \draw[->,thick] (2,10.8) .. controls (2,5) .. node[very near start,sloped,above] {\small gas station} (3,3.8);
      \draw[->,thick] (1,10.8) .. controls (1,2) .. node[near end,sloped,below] {\small validators} (1.5,-1.2);

      \draw[rounded corners] (3,5.3) rectangle +(8,2.8) [fill=objectbackgroundcolor];
      \draw (3.5,6.7) node[right] {balance: 9999\ldots};
      \draw (-2,7.2) node[left] {gamete};
      \draw (-2,6.1) node[left] {at \texttt{\gameteShort{}}};
      \draw[->,thick] (-2,6.7) -- +(5,0);
      \draw[->,thick] (10,8.1) .. controls (12,11) .. node[near end,sloped,below] {classpath} (12,16.1);

      \draw[rounded corners] (2,1) rectangle +(8,2.8) [fill=objectbackgroundcolor];
      \draw (2.5,2.5) node[right] {gasPrice: 1};
      \draw (-2,3) node[left] {gas station};
      \draw (-2,2) node[left] {at \texttt{\gasStationShort{}}};
      \draw[->,thick] (-2,2.5) -- +(4,0);
      \draw[->,thick] (9,3.8) .. controls (13,6) .. node[near end,sloped,below] {classpath} (13,16.1);

      \draw[rounded corners] (0.5,-4) rectangle +(10.5,2.8) [fill=objectbackgroundcolor];
      \draw (1,-2) node[right] {number of validators: 0};
      \draw (1,-3.1) node[right] {current supply: 1209\ldots};
      \draw (-2,-2) node[left] {validators};
      \draw (-2,-3) node[left] {at \texttt{\validatorsShort{}}};
      \draw[->,thick] (-2,-2.5) -- +(2.5,0);
      \draw[->,thick] (9.5,-1.2) .. controls (14,5) .. node[near end,sloped,below] {classpath} (14,16.1);

      \draw[rounded corners] (3,-8.5) rectangle +(11,2.8) [fill=objectbackgroundcolor];
      \draw (3.5,-7) node[right] {balance: \accountOneBalance};
      \draw (-2,-6.6) node[left] {account1};
      \draw (-2,-7.7) node[left] {at \texttt{\accountOneShort{}}};
      \draw[->,thick] (-2,-7) -- +(5,0);
      \draw[->,thick] (10,-5.7) .. controls (15,0) .. node[near end,sloped,below] {classpath} (15,16.1);

      \draw[rounded corners] (0.5,-13) rectangle +(20,2.8) [fill=jarbackgroundcolor];
      \draw (1,-11.1) node[right] {file \texttt{io-hotmoka-\ldots-family-\hotmokaVersion{}.jar},};
      \draw (1,-12.1) node[right] {that defines some classes, such as \texttt{Person}};
      \draw (-2,-11.1) node[left] {jar file};
      \draw (-2,-12.1) node[left] {at \texttt{\familyAddressShort{}}};
      \draw[->,thick] (-2,-11.6) -- +(2.5,0);
      \draw[->,thick] (15,-10.2) .. controls (16,-5) .. node[near end,sloped,below] {dependency} (16,16.1);
    \end{tikzpicture}
  \end{center}
  \caption{The state of the network nodes after the installation of our jar.}
  \label{fig:jar_installed}
\end{figure}

What we have done above is probably enough for most users, but sometimes you need
to perform the same operation in code, for instance in order to implement a software
application that connects to a Hotmoka node and runs some transactions.
Therefore, we describe below how you can write a Java program that installs the
same jar in the Hotmoka node, without using the \texttt{moka jars install} command.
A similar translation in code can be performed for all examples in this tutorial,
but we will report it only for a few of them.

Let us hence create another Eclipse Maven project
\texttt{io-hotmoka-tutorial-examples-runs}, inside
the directory \texttt{\hotmokaTutorialDir{}},
exactly as we did in the previous section for the \texttt{family} project.
Specify Java 21 (or later) in its build configuration.
Use \texttt{io.hotmoka} as \emph{Group Id} and
\texttt{io-hotmoka-tutorial-examples-runs} as \emph{Artifact Id}.
This is specified in the following \texttt{pom.xml}, that you should copy inside
the \texttt{io-hotmoka-tutorial-examples-runs} project, replacing that generated by Eclipse:
%
\begin{codebox}\begin{xmllst}
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <groupId>io.hotmoka</groupId>
  <artifactId>io-hotmoka-tutorial-examples-runs</artifactId>
  <version>|\hotmokaVersion{}|</version>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.release>21</maven.compiler.release>
  </properties>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.11.0</version>
      </plugin>
    </plugins>
  </build>

  <dependencies>
    <dependency>
      <groupId>io.hotmoka</groupId>
      <artifactId>io-hotmoka-node-remote</artifactId>
      <version>|\hotmokaVersion{}|</version>
    </dependency>
    <dependency>
      <groupId>io.hotmoka</groupId>
      <artifactId>io-hotmoka-helpers</artifactId>
      <version>|\hotmokaVersion{}|</version>
    </dependency>
    <dependency>
      <groupId>io.hotmoka</groupId>
      <artifactId>io-hotmoka-node-tendermint</artifactId>
      <version>|\hotmokaVersion{}|</version>
    </dependency>
    <dependency>
      <groupId>io.hotmoka</groupId>
      <artifactId>io-hotmoka-node-disk</artifactId>
      <version>|\hotmokaVersion{}|</version>
    </dependency>
    <dependency>
      <groupId>io.hotmoka</groupId>
      <artifactId>io-hotmoka-node-service</artifactId>
      <version>|\hotmokaVersion{}|</version>
    </dependency>
    <dependency>
      <groupId>io.hotmoka</groupId>
      <artifactId>io-hotmoka-constants</artifactId>
      <version>|\hotmokaVersion{}|</version>
    </dependency>
    <dependency>
      <groupId>io.hotmoka</groupId>
      <artifactId>io-takamaka-code-constants</artifactId>
      <version>|\takamakaVersion{}|</version>
    </dependency>
  </dependencies>

</project>
\end{xmllst}\end{codebox}
%
This \texttt{pom.xml} specifies a few dependencies. We do not need all of them now,
but we will need them along the next sections, hence let us insert them all already.
These dependencies get automatically downloaded from the Maven repository.

Since we have just modified the file \texttt{pom.xml}, Eclipse could show an error
for the project \texttt{io-hotmoka-tutorial-examples-runs}. To fix it,
you need to update the Maven dependencies of the project:
right-click on the \texttt{io-hotmoka-tutorial-examples-runs} project
and then select the menu \emph{Maven}$\rightarrow$\emph{Update Project\ldots}

Create a \texttt{module-info.java} inside \texttt{src/main/java}, containing:
%
\begin{codebox}\begin{javalst}
module io.hotmoka.tutorial.examples.runs {
  requires io.hotmoka.helpers;
  requires io.hotmoka.node.remote;
  requires io.hotmoka.node.disk;
  requires io.hotmoka.node.tendermint;
  requires io.hotmoka.node.service;
  requires io.hotmoka.constants;
  requires io.takamaka.code.constants;
}
\end{javalst}\end{codebox}
%
Again, we do not need all such dependencies already, but we will need them later.

Create a package \texttt{io.hotmoka.tutorial.examples.runs} inside
\texttt{src/main/java} and add the following class \texttt{Family.java} inside it:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.runs;

import static java.math.BigInteger.ONE;

import java.math.BigInteger;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.KeyPair;

import io.hotmoka.constants.Constants;
import io.hotmoka.crypto.api.Signer;
import io.hotmoka.helpers.GasHelpers;
import io.hotmoka.helpers.SignatureHelpers;
import io.hotmoka.node.Accounts;
import io.hotmoka.node.MethodSignatures;
import io.hotmoka.node.StorageValues;
import io.hotmoka.node.TransactionRequests;
import io.hotmoka.node.api.Node;
import io.hotmoka.node.api.requests.SignedTransactionRequest;
import io.hotmoka.node.api.transactions.TransactionReference;
import io.hotmoka.node.api.values.StorageReference;
import io.hotmoka.node.remote.RemoteNodes;

public class Family {

  public static void main(String[] args) throws Exception {

    // the path of the user jar to install
    var familyPath = Paths.get(System.getProperty("user.home")
      + "/.m2/repository/io/hotmoka/io-hotmoka-tutorial-examples-family/"
      + Constants.HOTMOKA_VERSION
      + "/io-hotmoka-tutorial-examples-family-" + Constants.HOTMOKA_VERSION + ".jar");

    var dir = Paths.get(args[1]);
    var payer = StorageValues.reference(args[2]);
    var password = args[3];

    try (var node = RemoteNodes.of(new URI(args[0]), 150000)) {
      // we get a reference to where io-takamaka-code-X.Y.Z.jar has been stored
      TransactionReference takamakaCode = node.getTakamakaCode();

      // we get the signing algorithm to use for requests
      var signature = node.getConfig().getSignatureForRequests();

      KeyPair keys = loadKeys(node, dir, payer, password);

      // we create a signer that signs with the private key of our account
      Signer<SignedTransactionRequest<?>> signer = signature.getSigner
      (keys.getPrivate(), SignedTransactionRequest::toByteArrayWithoutSignature);

      // we get the nonce of our account: we use the account itself as caller and
      // an arbitrary nonce (ZERO in the code) since we are running
      // a @View method of the account
      BigInteger nonce = node
      .runInstanceMethodCallTransaction(TransactionRequests.instanceViewMethodCall
      (payer, // payer
      BigInteger.valueOf(100_000), // gas limit
      takamakaCode, // class path for the execution of the transaction
      MethodSignatures.NONCE, // method
      payer)).get() // receiver of the method call
      .asBigInteger(__ -> new ClassCastException());

      // we get the chain identifier of the network
      String chainId = node.getConfig().getChainId();
      var gasHelper = GasHelpers.of(node);

      // we install the family jar in the node: our account will pay
      TransactionReference family = node
      .addJarStoreTransaction(TransactionRequests.jarStore
      (signer, // an object that signs with the payer's private key
      payer, // payer
      nonce, // payer's nonce: relevant since this is not a call to a @View method!
      chainId, // chain identifier: relevant since this is not a call to a @View method!
      BigInteger.valueOf(1_000_000), // gas limit: enough for this small jar
      gasHelper.getSafeGasPrice(), // gas price: at least the current gas price of the network
      takamakaCode, // class path for the execution of the transaction
      Files.readAllBytes(familyPath), // bytes of the jar to install
      takamakaCode)); // dependencies of the jar that is being installed

      // we increase our copy of the nonce, ready for further
      // transactions having the account as payer
      nonce = nonce.add(ONE);

      System.out.println("jar installed at " + family);
    }
  }

  private static KeyPair loadKeys(Node node, Path dir, StorageReference account, String password) throws Exception {
    return Accounts.of(account, dir)
    .keys(password, SignatureHelpers.of(node).signatureAlgorithmFor(account));
  }
}
\end{javalst}\end{codebox}
%
As you can see, the above \texttt{main} method requires four values to be provided from the caller:
the server to contact,
the directory \texttt{dir} where the key pair of the payer account can be found,
the storage reference of that payer account, and the password of the key pair.

The code above creates an instance of a \texttt{RemoteNode}\index{RemoteNode@{\texttt{RemoteNode}}},
that represents a Hotmoka
node installed in a remote host. By specifying the URI of the host, the \texttt{RemoteNode} object
exposes all methods of a Hotmoka node. It is an \texttt{AutoCloseable} object,
hence it is placed inside
a try-with-resource statement that guarantees its release at the end of the \texttt{try} block.
By using that remote node, our code collects
some information about the node: the reference to the \texttt{io-takamaka-code} jar already
installed inside it (\texttt{takamakaCode}) and the \texttt{signature} algorithm used
by the node,
that it uses to construct a \texttt{signer} object that signs with the private key of our account,
loaded from disk.

The \texttt{loadKeys} method accesses the \texttt{.pem} file that we have previously created
with moka, that should be inside a directory \texttt{dir}.

Like every Hotmoka node, the observable state of the remote node can only evolve through
\emph{transactions}, that modify its state in an atomic way.
Namely, the code above performs two transactions:
%
\begin{enumerate}
\item A call to the \texttt{nonce()} method of our account\index{nonce()@{\texttt{nonce()}}}:
  this is a progressive counter of the number
  of transactions already performed with our account. It starts from zero, but our account has been
  already used for other transactions (through the moka tool). Hence we better ask the
  node about it. As we will see later, this transaction calls a \texttt{@View} method. All calls
  to \texttt{@View} methods have the nice feature of being \emph{for free}:
  nobody will pay for them.
  Because of that, we do not need to sign this transaction, or to provide a correct nonce,
  or specify a gas price. The limitation of such calls is that their transactions are not
  checked by consensus, hence we have to trust the node we ask. Moreover, they can only
  read, never write the data in the store of the node.
\item The addition of our jar in the node. This time the transaction has a cost and our
  account is specified as payer. The signer of our account signs the transaction.
  The nonce of our account and the chain identifier of the network are relevant, as well as the
  gas price, that must at least match that of the network.
  The code uses the \texttt{addJarStoreTransaction()} method, that executes a new transaction
  on the node, whose goal is to install a jar inside it. The jar is provided as a sequence of bytes
  (\texttt{Files.readAllBytes(familyPath)}, where
  \texttt{familyPath} looks inside the local Maven repository
  of the machine, where the jar to install in the node should already be present).
  The request passed to \texttt{addJarStoreTransaction()}
  specifies that the transaction can cost up
  to $300000$ units of gas, that can be bought at the price returned by the
  \texttt{gasHelper} object. The request
  specifies that its class path is \texttt{node.getTakamakaCode()}: this is the reference to the
  \texttt{io-takamaka-code} jar already installed in the node.
  Finally, the request specifies that
  \texttt{io-hotmoka-tutorial-examples-family-\hotmokaVersion{}.jar} has only
  a single dependency: \texttt{io-takamaka-code}. This means that when, later, we will refer to
  \texttt{io-hotmoka-tutorial-examples-family-\hotmokaVersion{}.jar}
  in a class path, this class path will indirectly include its dependency
  \texttt{io-takamaka-code} as well (see Fig.~\ref{fig:jar_installed}).
\end{enumerate}

\begin{commentbox}
As in Ethereum, transactions in Hotmoka are paid
in terms of gas\index{gas} consumed for their execution.
Calls to \texttt{@View}\index{View@{\texttt{View}}}
methods do not actually modify the state of the node
and are executed locally, on the
node that receives the request of the transaction. Hence, they can be considered
as run \emph{for free}. Instead, we have used an actual gas price for the last
transaction that installs the jar in blockchain. This could be computed with
a sequence of calls to \texttt{@View} methods (get the manifest, then the gas station
inside the manifest, then the gas price inside the gas station). In order to
simplify the code, we have used the \texttt{GasHelper} class, that does exactly that for us.
\end{commentbox}

You can run the program with Maven, specifying the server to contact,
the directory where the key pairs can be found, the payer account and its password:
%
\input{mvn_exec_family_1_command}
\input{mvn_exec_family_1_output}
%
The exact address where the jar gets installed
will change in your machine. In any case, note that this reference
to the jar is functionally equivalent to that
obtained before with the \texttt{moka jars install} command: they point to equivalent jars.

\section{Creation of an object of our class}\label{sec:creation_object}

\begin{center}
  (See the \texttt{io-hotmoka-tutorial-examples-family-storage} and the
  \texttt{io-hotmoka-tutorial-examples-runs} projects in \texttt{\hotmokaRepo{}})
\end{center}

The jar of our program is in the store of the node now: the \texttt{moka jars install} command
has installed it at \texttt{\familyAddressShort{}} and our code at
\texttt{\codeFamilyAddressShort{}}.
We can use either of them, interchangeably, as class path for the execution of a transaction that
tries to run the constructor of our class \texttt{Person} and add a brand
new \texttt{Person} object into the store of the node. We can perform this through the moka tool:
%
\input{moka_objects_create_person_failed_command}
\input{moka_objects_create_person_failed_output}
%
The \texttt{moka objects create}\index{object!creation}
command requires to specify who pays for the object creation
(our account \texttt{\accountOneShort{}}),
then the fully-qualified name of the class that we want to instantiate
(\texttt{io.hotmoka.tutorial.examples.Person})
followed by the actual arguments passed to its constructor.
The classpath refers to the jar that we have installed previously.
The \texttt{moka objects create} command
asks for the password of the payer account and
checks if we really want to proceed (and pay). But then it ends up in failure
(\texttt{SerializationException}). Note that all offered gas has been spent.
This is a sort of \emph{penalty}\index{gas!penalty} for running a transaction that fails.
The rationale is that this penalty should discourage
potential denial-of-service attacks, when a huge number of failing transactions are thrown at a
node. At least, that attack will cost a lot. Moreover, note that the transaction, although
failed, does exist. Indeed, the nonce of the caller has been increased, as you can check
with \texttt{moka objects show} on our account.

But we still have not understood why the transaction failed. The reason is in the exception
message: \texttt{An object of class ...Person cannot be serialized into a storage value since it does not implement io.takamaka.code.lang.Storage}\index{Storage@{\texttt{Storage}}}.
Takamaka requires
that all objects stored in a node extend the \texttt{io.takamaka.code.lang.Storage} class.
That superclass
provides all the machinery needed in order to keep track of updates to such objects and persist
them in the store of the node, automatically.

\begin{commentbox}
Do not get confused here. Takamaka does \emph{not} require all objects to extend
the class \texttt{io.takamaka.code.lang.Storage}.
You can use objects that do not extend that superclass in your
Takamaka code, both instances of your classes and instances of library classes
from the \texttt{java.*} hierarchy, for instance.
What Takamaka does require, instead, is that objects
\emph{that must be kept in the store of a node} do extend
\texttt{io.takamaka.code.lang.Storage}. This
must be the case, for instance, for objects created by the constructor invoked through the
\texttt{moka objects create} command.
\end{commentbox}

Let us then modify the \texttt{io.hotmoka.tutorial.examples.Person.java}
source code, inside the \texttt{io-hotmoka-tutorial-examples-family} project:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.family;

import io.takamaka.code.lang.Storage;

public class Person extends Storage {
  ... unchanged code ...
}
\end{javalst}\end{codebox}
%
\begin{commentbox}
  Extending \texttt{io.takamaka.code.lang.Storage}
  is all a programmer needs to do in order to let instances
  of a class be stored in the store of a node. There is no explicit method to call to keep track
  of updates to such objects and persist them in the store of the node:
  Hotmoka nodes will automatically deal with them.
\end{commentbox}
%
\begin{commentbox}
  We can use the \texttt{io.takamaka.code.lang.Storage} class
  and we can run the resulting compiled code
  since that class is inside \texttt{io-takamaka-code}, that has been included in the
  class path as a dependency of \texttt{io-hotmoka-tutorial-examples-family-\hotmokaVersion{}.jar}
  (Fig.~\ref{fig:jar_installed}).
\end{commentbox}

Since class \texttt{Person} has been modified, you need to regenerate the previousley generated
jar file
\texttt{io-hotmoka-tutorial-examples-family-\hotmokaVersion{}.jar},
by running \texttt{mvn install} again
inside the \texttt{io-hotmoka-tutorial-examples-family} project.
Install this new version in blockchain:
%
\input{moka_jars_install_2_command}
\input{moka_jars_install_2_output}
%
then run the \texttt{moka objects create} command again. This time, the execution should
complete without exception:
%
\input{moka_objects_create_person_command}
\input{moka_objects_create_person_output}
%
The new object has been allocated at a storage reference \texttt{\personObjectShort{}}
that can be used to refer to it, also in the future.
You can verify that it is actually there and that its fields are correctly initialized,
by using the \texttt{moka objects show} command:
%
\input{moka_objects_show_person_command}
\input{moka_objects_show_person_output}
%
\begin{commentbox}
  Compared with Solidity, where contracts and accounts are just untyped \emph{addresses},
  objects (and hence accounts) are strongly-typed in Takamaka.
  This means that they are tagged with their run-time type (see the output
  of \texttt{moka objects show} above), in a boxed representation,
  so that it is possible to check that they are used correctly, \ie{}, in accordance
  with the declared type of variables, or to check their run-time type with checked casts
  and the \texttt{instanceof} operator. Moreover, Takamaka has information to check
  that such objects have been created by using the same
  jar that stays in the class path later, every time an object gets used
  (see the information \texttt{from jar installed at} in the output of
  \texttt{moka objects show} above).
\end{commentbox}

We can perform the same object creation in code, instead of using the
\texttt{moka objects create} command.
Namely, the following code builds on the previous example and installs a jar by adding
a further transaction that calls the constructor of \texttt{Person}:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.runs;

import static io.hotmoka.helpers.Coin.panarea;
import static io.hotmoka.node.StorageTypes.INT;
import static java.math.BigInteger.ONE;

import java.math.BigInteger;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.KeyPair;

import io.hotmoka.constants.Constants;
import io.hotmoka.crypto.api.Signer;
import io.hotmoka.helpers.GasHelpers;
import io.hotmoka.helpers.SignatureHelpers;
import io.hotmoka.node.Accounts;
import io.hotmoka.node.ConstructorSignatures;
import io.hotmoka.node.MethodSignatures;
import io.hotmoka.node.StorageTypes;
import io.hotmoka.node.StorageValues;
import io.hotmoka.node.TransactionRequests;
import io.hotmoka.node.api.Node;
import io.hotmoka.node.api.requests.SignedTransactionRequest;
import io.hotmoka.node.api.transactions.TransactionReference;
import io.hotmoka.node.api.types.ClassType;
import io.hotmoka.node.api.values.StorageReference;
import io.hotmoka.node.remote.RemoteNodes;

public class FamilyStorage {

  private final static ClassType PERSON = StorageTypes.classNamed("io.hotmoka.tutorial.examples.family.Person");

  public static void main(String[] args) throws Exception {
    // the path of the user jar to install
    var familyPath = Paths.get(System.getProperty("user.home")
    + "/.m2/repository/io/hotmoka/io-hotmoka-tutorial-examples-family/"
    + Constants.HOTMOKA_VERSION
    + "/io-hotmoka-tutorial-examples-family-" + Constants.HOTMOKA_VERSION + ".jar");

    var dir = Paths.get(args[1]);
    var payer = StorageValues.reference(args[2]);
    var password = args[3];

    try (var node = RemoteNodes.of(new URI(args[0]), 150000)) {
      // we get a reference to where io-takamaka-code-X.Y.Z.jar has been stored
      TransactionReference takamakaCode = node.getTakamakaCode();

      // we get the signing algorithm to use for requests
      var signature = node.getConfig().getSignatureForRequests();

      KeyPair keys = loadKeys(node, dir, payer, password);

      // we create a signer that signs with the private key of our account
      Signer<SignedTransactionRequest<?>> signer = signature.getSigner
      (keys.getPrivate(), SignedTransactionRequest::toByteArrayWithoutSignature);

      // we get the nonce of our account: we use the account itself as caller and
      // an arbitrary nonce (ZERO in the code) since we are running
      // a @View method of the account
      BigInteger nonce = node
      .runInstanceMethodCallTransaction(TransactionRequests.instanceViewMethodCall
      (payer, // payer
      BigInteger.valueOf(100_000), // gas limit
      takamakaCode, // class path for the execution of the transaction
      MethodSignatures.NONCE, // method
      payer)).get() // receiver of the method call
      .asBigInteger(__ -> new ClassCastException());

      // we get the chain identifier of the network
      String chainId = node.getConfig().getChainId();

      var gasHelper = GasHelpers.of(node);

      // we install the family jar in the node: our account will pay
      TransactionReference family = node
      .addJarStoreTransaction(TransactionRequests.jarStore
      (signer, // an object that signs with the payer's private key
      payer, // payer
      nonce, // payer's nonce: relevant since this is not a call to a @View method!
      chainId, // chain identifier: relevant since this is not a call to a @View method!
      BigInteger.valueOf(1_000_000), // gas limit: enough for this small jar
      gasHelper.getSafeGasPrice(), // gas price: at least the current gas price of the network
      takamakaCode, // class path for the execution of the transaction
      Files.readAllBytes(familyPath), // bytes of the jar to install
      takamakaCode)); // dependencies of the jar that is being installed
      
      // we increase our copy of the nonce, ready for further
      // transactions having the account as payer
      nonce = nonce.add(ONE);

      // call the constructor of Person and store in einstein the new object in blockchain
      StorageReference einstein = node.addConstructorCallTransaction
      (TransactionRequests.constructorCall
      (signer, // an object that signs with the payer's private key
      payer, // payer
      nonce, // payer's nonce: relevant since this is not a call to a @View method!
      chainId, // chain identifier: relevant since this is not a call to a @View method!
      BigInteger.valueOf(300_000), // gas limit: enough for a small object
      panarea(gasHelper.getSafeGasPrice()), // gas price, in panareas
      family, // class path for the execution of the transaction
      
      // constructor Person(String,int,int,int)
      ConstructorSignatures.of(PERSON, StorageTypes.STRING, INT, INT, INT),

      // actual arguments
      StorageValues.stringOf("Einstein"), StorageValues.intOf(14),
      StorageValues.intOf(4), StorageValues.intOf(1879)
      ));

      System.out.println("new object allocated at " + einstein);

      // we increase our copy of the nonce, ready for further
      // transactions having the account as payer
      nonce = nonce.add(ONE);
    }
  }

  private static KeyPair loadKeys(Node node, Path dir, StorageReference account, String password) throws Exception {
    return Accounts.of(account, dir)
    .keys(password, SignatureHelpers.of(node).signatureAlgorithmFor(account));
  }
}
\end{javalst}\end{codebox}
%
The new transaction is triggered by the
\texttt{addConstructorCallTransaction()} call,
that expands the node with a new transaction that calls
a constructor. We use our account as payer for the transaction, hence we sign
the request with its private key.
The class path includes path jars
\texttt{io-hotmoka-tutorial-examples-family-\hotmokaVersion{}.jar}
and its dependency \texttt{io-takamaka-code}.
The signature of the constructor specifies that we are referring to the second
constructor of \texttt{Person}, the one that assumes \texttt{null} as parents.
The actual parameters
are provided; they must be instances of the \texttt{io.hotmoka.node.api.values.StorageValue}
interface.
We provide $300000$ units of gas, which should be enough for a constructor
that just initializes a few fields.
We are ready to pay \texttt{panarea(gasHelper.getSafeGasPrice())}
units of coin for each unit of gas.
This price could have been specified simply as \texttt{gasHelper.getSafeGasPrice()},
but we used the static method \texttt{io.hotmoka.helpers.Coin.panarea()}
to generate a \texttt{BigInteger} corresponding to the smallest coin unit of Hotmoka nodes,
a \emph{panarea}.
Namely, Hotmoka uses the units of coin shown in Fig.~\ref{fig:units}.
%
\begin{figure}[t]
  \begin{center}
    \begin{tabular}{|c||c|c|c|}
      \hline
        value (in panas) & exponent & name & short name\\\hline\hline
        $1$ & $1$ & panarea & pana\\\hline
        $1000$ & $10^3$ & alicudi & ali\\\hline
        $1000000$ & $10^6$ & filicudi & fili\\\hline
        $1000000000$ & $10^9$ & stromboli & strom\\\hline
        $1000000000000$ & $10^{12}$ & vulcano & vul\\\hline
        $1000000000000000$ & $10^{15}$ & salina & sali\\\hline
        $1000000000000000000$ & $10^{18}$ & lipari & lipa\\\hline
        $1000000000000000000000$ & $10^{21}$ & moka & moka\\\hline
    \end{tabular}
  \end{center}
  \caption{The coin units of Hotmoka.}\label{fig:units}
\end{figure}
%
with corresponding static methods in \texttt{io.hotmoka.helpers.Coin}.

You can run \texttt{FamilyStorage} now, and see that, this time,
the object of class \texttt{Person} gets created in blockchain:
%
\input{mvn_exec_family_storage_command}
\input{mvn_exec_family_storage_output}
%
The exact address where the \texttt{Person} object gets allocated will change at each run.

\section{Calling a method on an object in a Hotmoka node}\label{sec:calling_method}

\begin{center}
  (See the \texttt{io-hotmoka-tutorial-examples-family-exported} and the
  \texttt{io-hotmoka-tutorial-examples-runs} projects in \texttt{\hotmokaRepo{}})
\end{center}

In the previous section, we have created an object of class \texttt{Person} in the store
of the node. Let us invoke the
\texttt{toString()} method on that object now. For that, we can use the
\texttt{moka objects call} command, specifying our `Person` object as \emph{receiver}.

\begin{commentbox}
In object-oriented languages, the \emph{receiver}\index{receiver} of a call to a non-\texttt{static}
method is the object over which the method is executed, that is accessible
as \texttt{this} inside the code of the method. In our case, we want to invoke
\texttt{einstein.toString()}, where \texttt{einstein} is the object that we have created
previously, hence the receiver of the call.
The receiver can be seen as an implicit actual argument passed to a (non-\texttt{static}) method.
\end{commentbox}
%
\input{moka_objects_call_toString_command}
\input{moka_objects_call_toString_output}
%
Command \texttt{moka objects call} requires to specify, as its first arguments,
the payer of the call, that is, our account, followed by the name of the class whose
method is called and the name of that method. The receiver of the call is specified through
\texttt{-{}-receiver}.

As you can see above, the result is deceiving.

This exception occurs when we try to pass the \texttt{Person} object
as receiver of \texttt{toString()} (the receiver is a particular case of an actual
argument). That object has been created in store, has escaped the node
and is available through its storage reference \texttt{\personObjectTwoShort}.
However, it cannot be passed back
into the node as argument of a call since it is not \emph{exported}. This is a security feature of
Hotmoka. Its reason is that the store of a node is public and can be read freely.
Everybody can see the objects created in the store of a Hotmoka node
and their storage references can be used to invoke their methods and modify their state.
This is true also for objects meant to be private state components of other objects and that
are not expected to be freely modifiable from outside the node. Because of this,
Hotmoka requires that classes, whose instances can be passed into the node as
arguments to methods or constructors,
must be annotated as \texttt{@Exported}\index{Exported@{\texttt{Exported}}}.
This means that the programmer acknowledges the
use of these instances from outside the node.
%
\begin{commentbox}
Note that all objects can be passed, from \emph{inside} the blockchain, as arguments to methods
of code in the node. The above limitation applies to objects passed from \emph{outside}
the node only.
\end{commentbox}

Let us modify the \texttt{Person} class again:
%
\begin{codebox}\begin{javalst}
...
import io.takamaka.code.lang.Exported;
...

@Exported
public class Person extends Storage {
  ...
}
\end{javalst}\end{codebox}
%
Package the project \texttt{io-hotmoka-tutorial-examples-family}:
%
\input{moka_jars_install_3_command}
\input{moka_jars_install_3_output}
%
then create a new \texttt{Person} object:
%
\input{moka_objects_create_person_exported_command}
\input{moka_objects_create_person_exported_output}
%
and finally call \texttt{toString()} on that new object:
%
\input{moka_objects_call_toString_exported_command}
\input{moka_objects_call_toString_exported_output}
%
This time, the correct answer \texttt{Einstein (14/4/1879)} appears on the screen.
%
\begin{commentbox}
In Ethereum, the only objects that can be passed, from outside the blockchain,
as argument to method calls into blockchain are contracts. Namely, in Solidity
it is possible to pass such objects as their untyped \emph{address} that can only
be cast to contract classes. Takamaka allows more, since \emph{any} object can be passed as
argument, not only contracts, as long as its class is annotated as \texttt{@Exported}.
This includes all contracts since the class
\texttt{io.takamaka.code.lang.Contract}\index{Contract@{\texttt{Contract}}}, that
we will present later, is annotated as \texttt{@Exported} and \texttt{@Exported} is an
inherited Java annotation.
\end{commentbox}

We can do the same in code, instead of using the \texttt{moka objects call} command.
Namely, we can expand
the \texttt{FamilyStorage} class seen before in order to run a further transaction,
that calls \texttt{toString()}.
For that, copy then the following \texttt{FamilyExported} class inside
the package \texttt{io.hotmoka.tutorial.examples.runs}
of the \texttt{io-hotmoka-tutorial-examples-runs} project:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.runs;

import static io.hotmoka.helpers.Coin.panarea;
import static io.hotmoka.node.StorageTypes.INT;
import static java.math.BigInteger.ONE;

import java.math.BigInteger;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.KeyPair;

import io.hotmoka.constants.Constants;
import io.hotmoka.crypto.api.Signer;
import io.hotmoka.helpers.GasHelpers;
import io.hotmoka.helpers.SignatureHelpers;
import io.hotmoka.node.Accounts;
import io.hotmoka.node.ConstructorSignatures;
import io.hotmoka.node.MethodSignatures;
import io.hotmoka.node.StorageTypes;
import io.hotmoka.node.StorageValues;
import io.hotmoka.node.TransactionRequests;
import io.hotmoka.node.api.Node;
import io.hotmoka.node.api.requests.SignedTransactionRequest;
import io.hotmoka.node.api.transactions.TransactionReference;
import io.hotmoka.node.api.types.ClassType;
import io.hotmoka.node.api.values.StorageReference;
import io.hotmoka.node.api.values.StorageValue;
import io.hotmoka.node.remote.RemoteNodes;

public class FamilyExported {

  private final static ClassType PERSON = StorageTypes.classNamed
    ("io.hotmoka.tutorial.examples.family.Person");

  public static void main(String[] args) throws Exception {

    // the path of the user jar to install
    var familyPath = Paths.get(System.getProperty("user.home")
    + "/.m2/repository/io/hotmoka/io-hotmoka-tutorial-examples-family/"
    + Constants.HOTMOKA_VERSION
    + "/io-hotmoka-tutorial-examples-family-" + Constants.HOTMOKA_VERSION + ".jar");

    var dir = Paths.get(args[1]);
    var payer = StorageValues.reference(args[2]);
    var password = args[3];

    try (var node = RemoteNodes.of(new URI(args[0]), 150000)) {
      // we get a reference to where io-takamaka-code-X.Y.Z.jar has been stored
      TransactionReference takamakaCode = node.getTakamakaCode();

      // we get the signing algorithm to use for requests
      var signature = node.getConfig().getSignatureForRequests();

      KeyPair keys = loadKeys(node, dir, payer, password);

      // we create a signer that signs with the private key of our account
      Signer<SignedTransactionRequest<?>> signer = signature.getSigner
      (keys.getPrivate(), SignedTransactionRequest::toByteArrayWithoutSignature);

      // we get the nonce of our account: we use the account itself as caller and
      // an arbitrary nonce (ZERO in the code) since we are running
      // a @View method of the account
      BigInteger nonce = node
      .runInstanceMethodCallTransaction(TransactionRequests.instanceViewMethodCall
      (payer, // payer
      BigInteger.valueOf(100_000), // gas limit
      takamakaCode, // class path for the execution of the transaction
      MethodSignatures.NONCE, // method
      payer)).get() // receiver of the method call
      .asBigInteger(__ -> new ClassCastException());

      // we get the chain identifier of the network
      String chainId = node.getConfig().getChainId();

      var gasHelper = GasHelpers.of(node);

      // we install the family jar in the node: our account will pay
      TransactionReference family = node
      .addJarStoreTransaction(TransactionRequests.jarStore
      (signer, // an object that signs with the payer's private key
      payer, // payer
      nonce, // payer's nonce: relevant since this is not a call to a @View method!
      chainId, // chain identifier: relevant since this is not a call to a @View method!
      BigInteger.valueOf(1_000_000), // gas limit: enough for this small jar
      gasHelper.getSafeGasPrice(), // gas price: at least the current gas price of the network
      takamakaCode, // class path for the execution of the transaction
      Files.readAllBytes(familyPath), // bytes of the jar to install
      takamakaCode)); // dependencies of the jar that is being installed

      // we increase our copy of the nonce, ready for further
      // transactions having the account as payer
      nonce = nonce.add(ONE);

      // call the constructor of Person and store in einstein the new object in blockchain
      StorageReference einstein = node.addConstructorCallTransaction
      (TransactionRequests.constructorCall
      (signer, // an object that signs with the payer's private key
      payer, // payer
      nonce, // payer's nonce: relevant since this is not a call to a @View method!
      chainId, // chain identifier: relevant since this is not a call to a @View method!
      BigInteger.valueOf(300_000), // gas limit: enough for a small object
      panarea(gasHelper.getSafeGasPrice()), // gas price, in panareas
      family, // class path for the execution of the transaction

      // constructor Person(String,int,int,int)
      ConstructorSignatures.of(PERSON, StorageTypes.STRING, INT, INT, INT),

      // actual arguments
      StorageValues.stringOf("Einstein"), StorageValues.intOf(14),
      StorageValues.intOf(4), StorageValues.intOf(1879)
      ));

      // we increase our copy of the nonce, ready for further
      // transactions having the account as payer
      nonce = nonce.add(ONE);

      StorageValue s = node.addInstanceMethodCallTransaction
      (TransactionRequests.instanceMethodCall
      (signer, // an object that signs with the payer's private key
      payer, // payer
      nonce, // payer's nonce: relevant since this is not a call to a @View method!
      chainId, // chain identifier: relevant since this is not a call to a @View method!
      BigInteger.valueOf(100_000), // gas limit: enough for a simple call
      panarea(gasHelper.getSafeGasPrice()), // gas price, in panareas
      family, // class path for the execution of the transaction

      // method to call: String Person.toString()
      MethodSignatures.ofNonVoid(PERSON, "toString", StorageTypes.STRING),

      // receiver of the method to call
      einstein
      )).get();

      // we increase our copy of the nonce, ready for further
      // transactions having the account as payer
      nonce = nonce.add(ONE);

      // print the result of the call
      System.out.println(s);
    }
  }

  private static KeyPair loadKeys(Node node, Path dir, StorageReference account, String password) throws Exception {
    return Accounts.of(account, dir)
    .keys(password, SignatureHelpers.of(node).signatureAlgorithmFor(account));
  }
}
\end{javalst}\end{codebox}
%
The interesting part is the call to \texttt{addInstanceMethodCallTransaction()}
at the end of the previous listing.
It requires to resolve method \texttt{Person.toString()} by using \texttt{einstein} as receiver
(the type \texttt{StorageTypes.STRING} is the return type of the method) and
to run the resolved method. It stores the result in
\texttt{s}, that subsequently prints on the standard output.
You can run class \texttt{FamilyExported}. You will obtain the same result as
with \texttt{moka objects call}:
%
\input{mvn_exec_family_exported_command}
\input{mvn_exec_family_exported_output}

As we have shown, method \texttt{addInstanceMethodCallTransaction()} can be used to
invoke an instance method on an object in the store of the node. This requires some
clarification. First of all, note that the signature of the method to
call is resolved and the resolved method is then invoked. If
such resolved method is not found (for instance, if we tried to call \texttt{tostring()} instead
of \texttt{toString()}), then \texttt{addInstanceMethodCallTransaction()} would end up in
a failed transaction. Moreover, the usual resolution mechanism of Java methods applies.
If, for instance, we invoked
\texttt{MethodSignatures.ofNonVoid(StorageTypes.OBJECT, "toString", StorageTypes.STRING)}
instead of
\texttt{MethodSignatures.ofNonVoid(PERSON, "toString", StorageTypes.STRING)},
then method \texttt{toString()} would have be resolved from the run-time class of
\texttt{einstein}, looking for the most specific implementation of \texttt{toString()},
up to the \texttt{java.lang.Object} class, which would anyway end up in
running \texttt{Person.toString()}.

Method \texttt{addInstanceMethodCallTransaction()} can be used to invoke instance
methods with parameters. If a \texttt{toString(int)} method existed in class \texttt{Person},
then we could call it and pass 2019 as its argument, by writing:
%
\begin{codebox}\begin{javalst}
StorageValue s = node.addInstanceMethodCallTransaction
(TransactionRequests.instanceMethodCall(
...

// method to call: String Person.toString(int)
MethodSignatures.ofNonVoid(PERSON, "toString", StorageTypes.STRING, StorageTypes.INT),

// receiver of the method to call
einstein,
  
// actual argument(s)
StorageValues.intOf(2019)
)).get();
\end{javalst}\end{codebox}
%
where we have added the formal parameter \texttt{StorageTypes.INT}
and the corresponding
actual argument \texttt{StorageValues.intOf(2019)}. Note that method calls yields
an optional value in Hotmoka, since methods returning \texttt{void} actually return non value.
Consequently, we need the final call to \texttt{get()} above to get the actual
value returned by the method.

Method \texttt{addInstanceMethodCallTransaction()} cannot be used to call a \texttt{static}
method. For that, use \texttt{addStaticMethodCallTransaction()} instead, that accepts
a request similar to that for \texttt{addInstanceMethodCallTransaction()}, but without a receiver.

\section{Storage types and constraints on storage classes}\label{sec:storage}

We have seen how to invoke a constructor of a class to build an object in
the store of a node or to invoke a method on an object in the store of a node.
Both constructors and
methods can receive arguments. Constructors yield a reference to a new
object, freshly allocated; methods might yield a returned value, if they are
not declared as \texttt{void}. This means that there is a bidirectional
exchange of data from outside the node to inside it, and back. But not any
kind of data can be exchanged:
%
\begin{enumerate}
\item The values that can be exchanged from inside the node to
  outside the node are called \emph{storage values}\index{storage value}.
\item The values that can be exchanged from outside the node to
  inside the node are the same storage values as above, with the extra constraint
  that objects must belong to an \texttt{@Exported} class.\index{Exported@{\texttt{Exported}}}
\end{enumerate}

The set of storage value is the union of
%
\begin{enumerate}
\item primitive values of Java (characters, bytes, shorts, integers, longs, floats,
  doubles and booleans);
\item reference values whose class extends \texttt{io.takamaka.code.lang.Storage}
  (that is, \emph{storage objects})\index{storage object};
\item \texttt{null};
\item a few special reference values: \texttt{java.math.BigInteger}s and
  \texttt{java.lang.String}s.
\end{enumerate}

Storage values cross the
node's boundary inside wrapper objects. For instance the integer 2019
is first wrapped into \texttt{StorageValues.intOf(2019)} and then passed
as a parameter to a method or constructor. In our previous example,
when we called \texttt{Person.toString()}, the result \texttt{s} was actually a wrapper
of a \texttt{java.lang.String} object. Boxing and unboxing into/from wrapper objects
is automatic in Takamaka: our class \texttt{Person} does not show that machinery.

What should be retained of the above discussion is that constructors and
methods of Takamaka classes, if we want them to be called from outside the
node, must receive storage values as parameters and must return storage
values (if they are not \texttt{void} methods). A method that expects a parameter of
type \texttt{java.util.HashSet}, for instance, can be defined and called
from Takamaka code, inside the node, but cannot be called from outside the node,
such as, for instance, from the moka tool or from our \texttt{Family} class. The same
occurs if the method returns a \texttt{java.util.HashSet}.

We conclude this section with a formal definition of storage objects.
We have already said that storage objects can be kept in the store of a node
and that their class must extend the library class
\texttt{io.takamaka.code.lang.Storage}. But there are extra constraints. Namely,
fields of a storage objects are part of the representation of such
objects and must, themselves, be kept in store. Hence, a storage object:
%
\begin{enumerate}
\item has a class that extends (directly or indirectly) \texttt{io.takamaka.code.lang.Storage}, and
\item all its fields hold storage values (primitives, storage objects,
  \texttt{null}, a \texttt{java.math.BigInteger} or a \texttt{java.lang.String}).
\end{enumerate}
%
Note that the above conditions hold for the class \texttt{Person} defined above. Instead,
the following are examples of what is \emph{not} allowed in a field of a storage object:
%
\begin{enumerate}
\item arrays
\item collections from \texttt{java.util.*}
\end{enumerate}
%
We will see later how to overcome these limitations.

\begin{commentbox}
Again, we stress that such limitations only apply to storage objects.
Other objects, that needn't be kept in the store of a node but are useful for
the implementation of Takamaka code, can be defined in a completely free way
and used in code that runs in the node.
\end{commentbox}

\section{Transactions can be added, posted and run}\label{sec:add_post_run}

We have executed transactions on a Hotmoka node with methods
\texttt{addJarStoreTransaction()}, \texttt{addConstructorCallTransaction()}
and \texttt{addInstanceMethodCallTransaction()}. These methods, whose name
starts with \texttt{add}\index{transaction!add},
are \emph{synchronous}, meaning that they block until the transaction is
executed (or fails). If they are invoked on a node with a notion of
commit, such as a blockchain, they guarantee to block until
the transaction is actually committed.
In many cases, when we immediately need the result of a transaction
before continuing with the execution of the
subsequent statements,
these methods are the right choice. In many other cases, however,
it is unnecessary to wait until the transaction has completed
its execution and has been committed. In those cases, it can
be faster to execute a transaction through a method whose name
starts with \texttt{post}\index{transaction!post}, such as
\texttt{postJarStoreTransaction()}, \texttt{postConstructorCallTransaction()}
or \texttt{postInstanceMethodCallTransaction()}. These methods are called
\emph{asynchronous}, since they terminate
immediately, without waiting for the outcome of the transaction
they trigger. Hence they cannot return their outcome immediately
and return a \emph{future}
instead, whose \texttt{get()} value, if and when invoked, will block
until the outcome of the transaction is finally available.

For instance, instead of the inefficient:
%
\begin{codebox}\begin{javalst}
StorageValue s = node.addInstanceMethodCallTransaction
  (TransactionRequests.instanceMethodCall(
    signer,
    payer,
    nonce,
    chainId,
    BigInteger.valueOf(100_000),
    panarea(gasHelper.getSafeGasPrice()),
    family,
    MethodSignatures.ofNonVoid(PERSON, "toString", StorageTypes.STRING),
    einstein
  )).get();

// code that does not use s
// .....
\end{javalst}\end{codebox}
%
one can write the more efficient:
%
\begin{codebox}\begin{javalst}
MethodFuture future = node.postInstanceMethodCallTransaction
  (TransactionRequests.instanceMethodCall(
    signer,
    payer,
    nonce,
    chainId,
    BigInteger.valueOf(100_000),
    panarea(gasHelper.getSafeGasPrice()),
    family,
    MethodSignatures.ofNonVoid(PERSON, "toString", StorageTypes.STRING),
    einstein
  ));

// code that does not use s
// .....

// the following will be needed only if s is used later
StorageValue s = future.get().get();
\end{javalst}\end{codebox}
%
where the first \texttt{get()} belongs to the future and is a blocking call
that suspends until the method has been executed, and the second
\texttt{get()} extracts the value from the optional returned by Hotmoka's
API for calling methods.

There is a third way to execute a transaction. Namely, calls to methods
annotated as \texttt{@View}\index{View@{\texttt{View}}} can be performed through the
\texttt{runInstanceMethodCallTransaction()} (for instance methods) and
\texttt{runStaticMethodCallTransaction()} (for static methods)\index{transaction!run}.
As we have hinted before, these executions are performed
locally, on the node they are addressed to, and do not add a transaction
that must be replicated in each node of the network, for consensus, and
that costs gas for storage.
These executions are free and do not require a correct nonce, signature,
or chain identifier, which is a great simplification.
