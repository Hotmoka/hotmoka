\chapter{Code verification}\label{ch:code_verification}

Code verification\index{code verification} checks that code complies with some constraints, that should
guarantee that its execution does not run into errors. Modern programming
languages apply more or less extensive code verification, since this helps
programmers write reliable code. This can both occur at run time and at compile
time. Run-time (\emph{dynamic}) code verification is typically stronger, since it can exploit
exact information about the actual run-time values flowing through the code. However,
compile-time (\emph{static}) code verification has the advantage that it runs only
once, at compilation time or at jar installation time, and can prove, once and for all,
that some errors will never occur, regardless of the execution path that will
be followed at run time.

Hotmoka nodes apply a combination of static and dynamic verification to the
Takamaka code that is installed inside their store.
Static verification runs only once, when a node installs
a jar in its store, or when classes are loaded for the first time at run time.
Dynamic verification runs every time some piece of code gets executed.

\section{JVM bytecode verification}\label{subsec:jvm_bytecode_verification}

Takamaka code is written in Java, compiled into Java bytecode\index{Java bytecode}, instrumented
and run inside the Java Virtual Machine (\emph{JVM}). Hence, all code verifications
executed by the JVM apply to Takamaka code as well. In particular, the JVM verifies
some structural and dynamic constraints of class files, including their
type correctness.
Moreover, the JVM executes run-time checks as well: for instance, class casts
are checked at run time, as well as pointer dereferences and
array stores. Violations result in exceptions. For a thorough discussion,
we refer the interested
reader to the official documentation about Java bytecode class
verification (see \website{https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.9}).

\section{Takamaka bytecode verification}\label{subsec:takamaka_bytecode_verification}

Hotmoka nodes verify extra constraints, that are not checked as part of the
standard JVM bytecode verification. Such extra constraints are mainly related to
the correct use of Takamaka annotations and contracts, and are
in part static and in part dynamic. Static constraints are checked when a
jar is installed into the store of a node, hence only once for each node of a network.
If a static constraint
is violated, the transaction that tries to install the jar fails with
an exception. Dynamic constraints, instead,
are checked every time a piece of code is run. If a dynamic constraint is
violated, the transaction that runs the code fails with an exception.

Below, remember that \texttt{@FromContract} is shorthand for \texttt{@FromContract(Contract.class)}.
Moreover, note that the constraints related
to overridden methods follow by Liskov's principle~\cite{LiskovW94}.

Hotmoka nodes verify the following static constraints:
%
\begin{enumerate}
\item The \texttt{@FromContract(C.class)}\index{FromContract@{\texttt{FromContract}}}
   	annotation is only applied to constructors of a
	(non-strict) subclass of \texttt{io.takamaka.code.lang.Storage}\index{Storage@{\texttt{Storage}}}
	or to instance methods of a
 	(non-strict) subclass of \texttt{io.takamaka.code.lang.Storage} or of an interface.
\item In every use of the \texttt{@FromContract(C.class)}\index{FromContract@{\texttt{FromContract}}}
	annotation, class \texttt{C} is a subclass
	of the abstract class \texttt{io.takamaka.code.lang.Contract}\index{Contract@{\texttt{Contract}}}.
\item If a method is annotated as \texttt{@FromContract(C.class)}\index{FromContract@{\texttt{FromContract}}}
	and overrides another method,
	then the latter is annotated as \texttt{@FromContract(D.class)} as well, and \texttt{D} is a
	(non-strict) subclass of \texttt{C}.
\item If a method is annotated as \texttt{@FromContract(D.class)}\index{FromContract@{\texttt{FromContract}}}
	and is overridden by another method,
	then the latter is annotated as \texttt{@FromContract(C.class)} as well, and \texttt{D} is a
	(non-strict) subclass of \texttt{C}.
\item If a method is annotated as \texttt{@Payable}\index{Payable@{\texttt{Payable}}}, then it is also annotated as
	\texttt{@FromContract(C.class)}\index{FromContract@{\texttt{FromContract}}} for some \texttt{C}.
\item If a method is annotated as \texttt{@Payable}\index{Payable@{\texttt{Payable}}}, then it has a first formal argument
	(the paid amount) of type \texttt{int}, \texttt{long} or \texttt{BigInteger}.
\item If a method is annotated as \texttt{@Payable}\index{Payable@{\texttt{Payable}}} and overrides another method,
	then the latter is annotated as \texttt{@Payable} as well.
\item If a method is annotated as \texttt{@Payable}\index{Payable@{\texttt{Payable}}} and is overridden by another method,
	then the latter is annotated as \texttt{@Payable} as well.
\item The \texttt{@Payable}\index{Payable@{\texttt{Payable}}} annotation is only applied to constructors of a (non-strict) subclass of
	the library class \texttt{io.takamaka.code.lang.Contract}\index{Contract@{\texttt{Contract}}}
	or to instance methods of a (non-strict) subclass of
	\texttt{io.takamaka.code.lang.Contract} or of an interface.
\item Classes that extend \texttt{io.takamaka.code.lang.Storage}\index{Storage@{\texttt{Storage}}}
	have instance non-transient
    fields whose type is primitive (\texttt{char}, \texttt{byte}, \texttt{short}, \texttt{int},
	\texttt{long}, \texttt{float},
    \texttt{double} or \texttt{boolean}), or is a class that extends \texttt{io.takamaka.code.lang.Storage},
    or is any of
    \texttt{java.math.BigInteger}, \texttt{java.lang.String}, \texttt{java.lang.Object} or is an interface
    (see Sec.~\ref{sec:storage}).
%
\begin{commentbox}
The choice of allowing, inside a storage type, fields of type
\texttt{java.lang.Object} can be surprising. After all, any reference value can be
stored in such a field, which requires to verify, at run time, if the field
actually contains a storage value or not (see the dynamic check number~\ref{check:object_or_interface_fields}, below).
The reason for this choice is to allow generic storage types, such as
\texttt{StorageTreeMap<K,V>}, whose values are storage values as long as \texttt{K} and \texttt{V}
are replaced with storage types. Since Java implements generics by erasure,
the bytecode of such a class ends up having fields of type \texttt{java.lang.Object}. An alternative
solution would be to bound \texttt{K} and \texttt{V} from above
(\texttt{StorageTreeMap<K extends Storage, V extends Storage>}). This second choice
would be erased by using \texttt{Storage} as static type of the erased fields of the
class. However, not all storage reference values extend \texttt{Storage}. For instance,
this solution would not allow one to write \texttt{StorageTreeMap<String, BigInteger>}, where
both \texttt{String} and \texttt{BigInteger} are storage types, but neither extends \texttt{Storage}.
The fact that fields of type \texttt{java.lang.Object} or interface actually hold a
storage value at the end of a transaction is checked dynamically (see the dynamic checks below).
\end{commentbox}
%
\item There are no static initializer methods.
%
\begin{commentbox}
Java runs static initializer methods the first time their defining class is loaded. They
are either coded explicitly, inside a \texttt{static \{\ldots\}} block, or are
implicitly generated by the compiler in order to initialize the static fields
of the class. The reason for forbidding such static initializers is that,
inside Takamaka, they would end up being run many times, at each transaction
that uses the class, and reset the static state of a class,
since static fields are not kept in blockchain.
This is a significant divergence from the expected
semantics of Java, that requires static initialization of a class to
occur only once during the lifetime of that class. Note that the absence of
static initializers still allows a class to have static fields, as long as
they are bound to constant primitive or \texttt{String} values.
\end{commentbox}
%
\item There are no finalizers.
%
\begin{commentbox}
A finalizer is a method declared exactly as
\texttt{public void finalize() \{\ldots\}}. It might be called
when the JVM garbage collects an object from RAM.
The reason for forbidding such finalizers is that
their execution is not guaranteed (they might never be called)
or might occur at a non-deterministic moment,
while code in blockchain must be deterministic.
\end{commentbox}
%
\item\label{check:caller_correct_usage} Calls to \texttt{caller()}\index{caller()@{\texttt{caller()}}}
	occur only inside \texttt{@FromContract}\index{FromContract@{\texttt{FromContract}}} constructors or methods
	and always on \texttt{this}.
\item Calls to constructors or methods annotated as \texttt{@FromContract}\index{FromContract@{\texttt{FromContract}}} occur
	only in constructors or instance methods of an
	\texttt{io.takamaka.code.lang.Contract}\index{Contract@{\texttt{Contract}}}; moreover, if they occur, syntactically,
	on \texttt{this}, then they occur in a method or constructor that is itself
	annotated as \texttt{@FromContract} (since the \texttt{caller()} is preserved in that case).
\item Bytecodes \texttt{jsr}, \texttt{ret} and \texttt{putstatic} are not used; inside constructors and instance
	methods, bytecodes \texttt{astore 0}, \texttt{istore 0}, \texttt{lstore 0}, \texttt{dstore 0} and
	\texttt{fstore 0} are not used.
%
\begin{commentbox}
Local variable 0 is used to hold the \texttt{this} reference. Forbidding its modification
is important to guarantee that \texttt{this} is not reassigned in code, which is impossible
in Java but perfectly legal in (unexpected) Java bytecode.
The guarantee that \texttt{this} is not reassigned is needed, in turn, for
checking properties such as point~\ref{check:caller_correct_usage} above.
\end{commentbox}
%
\item\label{check:no_unchecked_exception_handlers}
	There are no exception handlers that may catch unchecked exceptions (that is,
 	instances of \texttt{java.lang.RuntimeException} or of \texttt{java.lang.Error}).
%
\begin{commentbox}
By forbidding exception handlers for unchecked exceptions, it follows that
unchecked exceptions will always make a transaction fail: all object
updates up to the exception will be discarded. In practice,
transactions failed because of an unchecked exception leave no trace on
the store of the node, but for the gas of the caller being consumed. The reason for
forbidding exception handlers for unchecked exceptions is that they could
occur in unexpected places and leave a contract in an inconsistent state.
Consider for instance the following (illegal) code:
%
\begin{codebox}\begin{javalst}
try {
  this.list.add(x);
  x.flagAsInList();
  this.counter++;
}
catch (Exception e) { // illegal in Takamaka
}
\end{javalst}\end{codebox}
%
Here, the programmer might expect that
the size of \texttt{this.list} is \texttt{this.counter} and the correctness of his code might
be based on that invariant. However, if \texttt{x} holds
\texttt{null}, then an unchecked \texttt{NullPointerException} is raised just before
\texttt{this.counter} could be incremented, and that exception would be caught and ignored.
The expected invariant would be lost.
The contract will remain in blockchain in an inconsistent state,
for ever. The situation would be worse if an
\texttt{OutOfGasException}\index{OutOfGasException@{\texttt{OutOfGasException}}} would
be caught: the caller might provide exactly the amount of gas needed to
reach the \texttt{flagAsInList()} call, and leave the contract in an inconsistent
state. Checked exceptions, instead, are explicitly checked by the
compiler, which should ring a bell in the head of the programmer.

For a more dangerous example, consider the following Java bytecode:
%
\begin{codebox}\begin{javalst}
10: goto 10
exception handler for java.lang.Exception: 10 11 10 // illegal in Takamaka
\end{javalst}\end{codebox}
%
This Java bytecode exception handler entails that any \texttt{OutOfGasException}
thrown by an instruction from line~10 (included) to line~11 (excluded)
redirects control to line~10. Hence, this code will exhaust the gas by looping at line~10.
Once all gas is consumed, an \texttt{OutOfGasException} is thrown, that is redirected
to line~10. Hence another \texttt{OutOfGasException} will occur, that redirects the
executor to line~10 again. And so on, for ever. That is, this code
disables the guarantee that Takamaka transactions always terminate,
possibly with an \texttt{OutOfGasException}. This code could be used for
a DOS attack to a Hotmoka node. Although this code cannot be written in Java,
it is well possible to write it directly, with a bytecode editor,
and submit it to a Hotmoka node, that will reject it, thanks to point~\ref{check:no_unchecked_exception_handlers}.
\end{commentbox}
%
\item If a method or constructor is annotated as \texttt{@ThrowsExceptions}\index{ThrowsExceptions@{\texttt{ThrowsExceptions}}}, then it is public.
\item If a method is annotated as \texttt{@ThrowsExceptions}\index{ThrowsExceptions@{\texttt{ThrowsExceptions}}} and overrides another method,
    then the latter is annotated as \texttt{@ThrowsExceptions} as well.
\item If a method is annotated as \texttt{@ThrowsExceptions}\index{ThrowsExceptions@{\texttt{ThrowsExceptions}}} and is overridden by another method,
    then the latter is annotated as \texttt{@ThrowsExceptions} as well.
\item Classes installed in a node are not in packages \texttt{java.*}, \texttt{javax.*}
    or \texttt{io.takamaka.code.*}; packages starting with \texttt{io.takamaka.code.*} are
    however allowed if the node is not initialized yet.
%
\begin{commentbox}
The goal of the previous constraint is to make it impossible to change
the semantics of the Java or Takamaka runtime. For instance, it is not
possible to replace class \texttt{io.takamaka.code.lang.Contract}, which could thoroughly
revolutionize the execution of the contracts. During the initialization of a node,
that occurs once at its start-up, it is however permitted to install the
runtime of Takamaka (the \texttt{io-takamaka-code-\takamakaVersion{}.jar} archive used in the examples
in the previous chapters).
\end{commentbox}
%
\item\label{check:only_white_listed} All referenced classes, constructors, methods and fields must be
	white-listed\index{white-listing}.
    Those from classes installed in the store of the node are always white-listed by
    default. Other classes loaded from the Java class path must have been explicitly
    marked as white-listed in the \texttt{io-hotmoka-whitelisting-\hotmokaVersion{}.jar} archive.
%
\begin{commentbox}
Hence, for instance, both the support classes \texttt{io.takamaka.code.lang.Storage}
and \texttt{io.takamaka.code.lang.Takamaka} are white-listed, since they
are defined inside \texttt{io-takamaka-code-\takamakaVersion{}.jar}, that is typically installed in the store of a
node during its initialization. Classes from user
jars installed in the node are similarly white-listed.
Method \texttt{java.lang.System.currentTimeMillis()} is not white-listed,
since it is loaded from the Java class path and is not annotated as white-listed
in \texttt{io-takamaka-whitelisting-\hotmokaVersion{}.jar}.
\end{commentbox}
%
\item\label{check:only_standard_call_sites}
	Bootstrap methods for the \texttt{invokedynamic} bytecode use only standard call-site
    resolvers, namely, instances of the resolvers \texttt{java.lang.invoke.LambdaMetafactory.metafactory}
    or \texttt{java.lang.invoke.StringConcatFactory.makeConcatWithConstants}.
%
\begin{commentbox}
This condition is needed since other call-site resolvers could call any
method, depending on their algorithmic implementation, actually
side-stepping the white-listing constraints imposed by point~\ref{check:only_white_listed}.
Java compilers currently do not generate other call-site resolvers.
\end{commentbox}
%
\item There are no native methods.
\item There are no \texttt{synchronized} methods, nor \texttt{synchronized} blocks.
%
\begin{commentbox}
Takamaka code is single-threaded, to enforce its determinism and avoid deadlock.
Hence, there is no need to use the \texttt{synchronized} keyword.
\end{commentbox}
%
\item\label{check:no_special_prefix} Field and method names do not start with a special prefix used
    for instrumentation, namely they do not start with \texttt{ยง}.
%
\begin{commentbox}
This condition avoids name clashes after instrumentation.
That prefix is not legal in Java, hence this constraint
does not interfere with programmers. However, it could be used
in (unexpected) Java bytecode, that would be rejected thanks to point~\ref{check:no_special_prefix}.
\end{commentbox}
%
\item Packages are not split across different jars in the classpath.
%
\begin{commentbox}
This condition makes it impossible to call \texttt{protected} methods
outside of subclasses and of the same jar where they are defined.
Split packages allow an attacker to define a new jar
with the same package name as classes in another jar and
call the \texttt{protected} methods of objects of those classes.
This is dangerous since such methods
often access or modify sensitive fields of the objects.
\end{commentbox}
%
\end{enumerate}

Takamaka verifies the following dynamic constraints:
%
\begin{enumerate}
\item Every \texttt{@Payable}\index{Payable@{\texttt{Payable}}}  constructor or method is passed a non-\texttt{null} and
   non-negative amount of funds.
\item A call to a \texttt{@Payable}\index{Payable@{\texttt{Payable}}} constructor or method succeeds only if the caller
   has enough funds to pay for the call (\ie, the amount first parameter of
   the method or constructor).
\item A call to a \texttt{@FromContract(C.class)}\index{FromContract@{\texttt{FromContract}}} constructor or method succeeds only if
   the caller is an instance of \texttt{C}.
\item A bytecode instruction is executed only if there is enough gas for
   its execution, otherwise an \texttt{OutOfGasException}\index{OutOfGasException@{\texttt{OutOfGasException}}} is thrown.
\item Non-transient fields of type \texttt{java.lang.Object} or of type interface,
   belonging to some storage object reachable from the actual parameters of a transaction
   at the end of the transaction, contain \texttt{null} or a storage object.
\end{enumerate}

\section{Command-line verification and instrumentation}

\begin{center}
(See the \texttt{io-hotmoka-tutorial-examples-family\_errors} project in \texttt{\hotmokaRepo{}})
\end{center}

If a jar being installed in a Hotmoka node does not satisfy the static
constraints in Sec.~\ref{subsec:takamaka_bytecode_verification}, the installation transaction fails with
a verification exception, no jar is actually installed but the gas of the
caller gets consumed. Hence it is not practical to realize that a
static constraint does not hold only by trying to install a jar in a node.
Instead, it is desirable to verify all constraints off-line, fix all
violations (if any) and only then install the jar in the node. This is
possible by using the moka command-line interface of Hotmoka.
Namely, it provides a subcommand that performs the same identical jar
verification that would be executed when a jar is
installed in a Hotmoka node.

Create a jar file containing
a wrong version of the \texttt{io-hotmoka-tutorial-examples-family} project.
For that, copy the \texttt{io-hotmoka-tutorial-examples-family}
project into a new project \texttt{io-hotmoka-tutorial-examples-family\_errors} project,
change the artifact name in its \texttt{pom.xml} into
\texttt{io-hotmoka-tutorial-examples-family\_errors} and modify
its \texttt{Person} class so that it contains a few errors, as follows:
%
\begin{codebox}\begin{javalst}
package io.hotmoka.tutorial.examples.family;

import io.takamaka.code.lang.Exported;
import io.takamaka.code.lang.Payable;
import io.takamaka.code.lang.Storage;
import io.takamaka.code.lang.StringSupport;

@Exported
public class Person extends Storage {
  private final String name;
  private final int day;
  private final int month;
  private final int year;

  // error: arrays are not allowed in storage
  public final Person[] parents = new Person[2];

  public static int toStringCounter;

  public Person(String name, int day, int month, int year, Person parent1, Person parent2) {
    this.name = name;
    this.day = day;
    this.month = month;
    this.year = year;
    this.parents[0] = parent1;
    this.parents[1] = parent2;
  }

  // error: @Payable without @FromContract,
  // missing amount and @Payable method not in a Contract
  public @Payable Person(String name, int day, int month, int year) {
    this(name, day, month, year, null, null);
  }

  @Override
  public String toString() {
    toStringCounter++; // error: static update (putstatic) is not allowed
    return StringSupport.concat(name, " (", day, "/", month, "/", year, ")");
  }
}
\end{javalst}\end{codebox}
%
Then generate the \texttt{io-hotmoka-tutorial-examples-family\_errors-\hotmokaVersion{}.jar} file and
store it in the cache of Maven:
%
\begin{shellcommandbox}\begin{ttlst}
cd io-hotmoka-tutorial-examples-family_errors
mvn install
\end{ttlst}\end{shellcommandbox}

Let us start with the verification of \texttt{io-takamaka-code-\takamakaVersion{}.jar},
that we should find in the cache of Maven:\index{moka!jars verify@{\texttt{jars verify}}}
%
\input{moka_jars_verify_takamaka_command}
\input{moka_jars_verify_takamaka_output}
%
No error has been issued, since the code does not violate any static constraint.
Note that we used the \texttt{-{}-init} switch, since otherwise we would get many errors
related to the use of the forbidden \texttt{io.takamaka.code.*} package. With that
switch, we verify the jar as it would be verified before node initialization,
that is, by considering such package as legal.

We can generate the instrumented jar, exactly as it would be generated during
installation in a Hotmoka node. For that, we run:\index{moka!jars instrument@{\texttt{jars instrument}}}
%
\input{moka_jars_instrument_takamaka_command}
\input{moka_jars_instrument_takamaka_output}
%
The \texttt{moka jars instrument} command verifies and instruments the jar, and then stores
its instrumented version inside the \texttt{instrumented} directory.

Let us verify and instrument \texttt{io-hotmoka-tutorial-examples-family-\hotmokaVersion{}.jar} now
(the correct version of the project).
As all Takamaka programs, it uses classes from the \texttt{io-takamaka-code} jar,
hence it depends on it. We specify this with the \texttt{-{}-libs} option, that must
refer to an already instrumented jar:\index{moka!jars instrument@{\texttt{jars instrument}}}
%
\input{moka_jars_instrument_family_command}
\input{moka_jars_instrument_family_output}
%
As you can see, verification succeeds this time as well and an instrumented jar file named
\texttt{io-hotmoka-tutorial-examples-family-\hotmokaVersion{}.jar} appears in the
\texttt{instrumented} directory. Note that we have not used the \texttt{-{}-init}
switch this time, since we wanted to simulate the verification
as it would occur after the node has been already initialized,
when users add their jars to the store of the node.

Let us verify the \texttt{io-hotmoka-tutorial-examples-family\_errors-\hotmokaVersion{}.jar} archive now, that
(we know) contains a few errors. This time, verification will fail and the errors will
be printed on the screen:\index{moka!jars verify@{\texttt{jars verify}}}
%
\input{moka_jars_verify_family_errors_command}
\input{moka_jars_verify_family_errors_output}
%
The same failure occurs with the \texttt{moka jars instrument} command,
that will not generate the instrumented jar. It only
reports the first encountered error before failure:\index{moka!jars instrument@{\texttt{jars instrument}}}
%
\input{moka_jars_instrument_family_errors_command}
\input{moka_jars_instrument_family_errors_output}