\chapter{Tokens}\label{ch:tokens}

A popular class of smart contracts
implement a dynamic ledger of coin transfers between accounts. These
coins are not native tokens, but rather new, derived tokens.
In some sense, tokens are programmed money, whose rules are specified
by a smart contract and enforced by the underlying blockchain.

\begin{commentbox}
In this context, the term \emph{token}\index{token} is used
for the smart contract that tracks coin transfers, for the single coin units and for the category
of similar coins. This is sometimes confusing.
\end{commentbox}

Native and derived tokens can be categorized in many
ways~\cite{OliveiraZBS18,FreniFM20,Tapscott20}.
The most popular classification
is between \emph{fungible}\index{token!fungible} and \emph{non-fungible}\index{token!non-fungible} tokens.
Fungible tokens are interchangeable with each other, since they have an identical
nominal value that does not depend on each specific token instance.
Native tokens and traditional (\emph{fiat}) currencies are both examples of fungible tokens.
Their main application is in the area of crowdfunding and initial coin offers
to support startups.
On the contrary, non-fungible tokens have a value that depends on their specific instance.
Hence, in general, they are not interchangeable.
Their main application is currently in the art market, where they represent
a written declaration of author's rights concession to the holder.

A few standards have emerged for such tokens,
that should guarantee correctness,
accessibility, interoperability, management and security
of the smart contracts that run the tokens.
Among them, the Ethereum Requests for Comment \#20
(ERC-20~\cite{VogelstellerB15}\index{ERC20}) and \#721 (ERC-721~\cite{EntrikenSES18}\index{ERC721})
are the most popular, also outside Ethereum. They provide developers with
a list of rules required for the correct integration of tokens
with other smart contracts and with applications external to the blockchain,
such as wallets, block explorers, decentralized finance protocols and games.

The most popular implementations of the ERC-20 and ERC-721 standards are in Solidity,
by OpenZeppelin~\cite{OpenZeppelinERC20,OpenZeppelinERC721}\index{OpenZeppelin},
a team of programmers in the Ethereum community
who deliver useful and secure smart contracts and libraries, and by
ConsenSys, later deprecated in favor of OpenZeppelin's.
OpenZeppelin extends ERC-20 with snapshots, that is,
immutable views of the state of a token contract, that show
its ledger at a specific instant of time.
They are useful to investigate the consequences of an attack, to create forks of the token
and to implement mechanisms based on token balances such as weighted voting.

\section{Fungible tokens (ERC20)}\label{sec:erc20}

A fungible token ledger is a ledger that binds owners (contracts) to
the numerical amount of tokens they own. With this very high-level description,
it is an instance of the \texttt{IERC20View}\index{IERC20View@{\texttt{IERC20View}}} interface in Fig.~\ref{fig:erc20_hierarchy}.
The \texttt{balanceOf()} method tells how many tokens an \texttt{account} holds and the method
\texttt{totalSupply()} provides the total number of tokens in circulation.
The \texttt{UnsignedBigInteger}\index{UnsignedBigInteger@{\texttt{UnsignedBigInteger}}}
class is a Takamaka library class that wraps a \texttt{BigInteger}
and guarantees that its value is never negative. For instance, the subtraction of two
\texttt{UnsignedBigInteger}s throws an exception when the second is larger than the first.

\begin{figure}[th]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{pics/erc20}
  \end{center}
  \caption{The hierarchy of the ERC20 token implementations.}
  \label{fig:erc20_hierarchy}
\end{figure}

The \texttt{snapshot()}\index{snapshot()@{\texttt{snapshot()}}} method,
as already seen for collection classes, yields a read-only,
frozen view of the latest state of the token ledger.
Since it is defined in the topmost interface, all token classes
can be snapshotted. Snapshots are computable in constant time.
%
\begin{commentbox}
In the original ERC20 standard and implementation in Ethereum,
only specific subclasses allow snapshots, since their creation adds gas costs to all
operations, also for token owners that never performed any snapshot.
See the discussion and comparison in~\cite{CrosaraOST23}.
\end{commentbox}

An ERC20 ledger is typically modifiable. Namely, owners
can sell tokens to other owners
and can delegate trusted contracts to transfer tokens on their behalf.
Of course, these operations must be legal, in the sense that an owner cannot sell
more tokens than it owns and delegated contracts cannot transfer more tokens than the
cap to their delegation.
These modification operations are defined in the
\texttt{IERC20}\index{IERC20@{\texttt{IERC20}}} interface in Fig.~\ref{fig:erc20_hierarchy}. They are identical to the same
operations in the ERC20 standard for Ethereum, hence we refer to that standard for further detail.
The \texttt{view()}\index{view()@{\texttt{view()}}} method is used to yield a \emph{view} of the ledger, that is, an object
that reflects the current state of the original ledger, but without any modification operation.

The \texttt{ERC20}\index{ERC20@{\texttt{ERC20}}} implementation provides a standard implementation for the functions defined
in the \texttt{IERC20View} and \texttt{IERC20} interfaces. Moreover, it provides metadata information
such as name, symbol and number of decimals for the specific token implementation.
There are protected implementations for methods that allow one to mint or burn an amount
of tokens for a given owner (\texttt{account}). These are protected since one does not
want to allow everybody to print or burn money. Instead, subclasses can call into these
methods in their constructor, to implement an initial distribution of tokens,
and can also allow subsequent, controlled mint or burns.
For instance, the \texttt{ERC20Burnable}\index{ERC20Burnable@{\texttt{ERC20Burnable}}}
class is an \texttt{ERC20} implementation that
allows a token owner to burn its tokens only, or those it has been
delegated to transfer, but never those of another owner.

The \texttt{ERC20Capped}\index{ERC20Capped@{\texttt{ERC20Capped}}} implementation
allows the specification of a maximal cap to the
number of tokens in circulation. When new tokens get minted, it checks that the cap
is not exceeded and throws an exception otherwise.
