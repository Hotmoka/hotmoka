/*
Copyright 2021 Fausto Spoto

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package io.hotmoka.node.local.internal.builders;

import static io.hotmoka.node.local.internal.runtime.Runtime.responseCreators;

import java.math.BigInteger;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.logging.Level;
import java.util.logging.Logger;

import io.hotmoka.node.StorageValues;
import io.hotmoka.node.TransactionReferences;
import io.hotmoka.node.api.ClassLoaderCreationException;
import io.hotmoka.node.api.DeserializationException;
import io.hotmoka.node.api.OutOfGasException;
import io.hotmoka.node.api.TransactionRejectedException;
import io.hotmoka.node.api.UnknownReferenceException;
import io.hotmoka.node.api.nodes.ConsensusConfig;
import io.hotmoka.node.api.requests.SystemTransactionRequest;
import io.hotmoka.node.api.requests.TransactionRequest;
import io.hotmoka.node.api.responses.TransactionResponse;
import io.hotmoka.node.api.signatures.FieldSignature;
import io.hotmoka.node.api.transactions.TransactionReference;
import io.hotmoka.node.api.values.StorageReference;
import io.hotmoka.node.local.LocalNodeException;
import io.hotmoka.node.local.api.EngineClassLoader;
import io.hotmoka.node.local.api.FieldNotFoundException;
import io.hotmoka.node.local.api.ResponseBuilder;

/**
 * A generic implementation of the creator of a response.
 *
 * @param <Request> the type of the request of the transaction
 * @param <Response> the type of the response of the transaction
 */
public abstract class AbstractResponseBuilder<Request extends TransactionRequest<Response>, Response extends TransactionResponse> implements ResponseBuilder<Request, Response> {

	/**
	 * The reference used to refer to the transaction generated by the request.
	 */
	private final TransactionReference reference;

	/**
	 * The execution environment where the response is built.
	 */
	protected final ExecutionEnvironment environment;

	/**
	 * The request of the transaction.
	 */
	protected final Request request;

	/**
	 * The consensus parameters when this builder was created.
	 */
	protected final ConsensusConfig<?,?> consensus;

	private final static Logger LOGGER = Logger.getLogger(AbstractResponseBuilder.class.getName());

	/**
	 * Creates the builder of a response.
	 * 
	 * @param reference the reference to the transaction that is building the response
	 * @param request the request for which the response is being built
	 * @param environment the execution environment where the response is built
	 */
	protected AbstractResponseBuilder(TransactionReference reference, Request request, ExecutionEnvironment environment) {
		this.environment = environment;
		this.request = request;
		this.reference = reference;
		this.consensus = environment.getConfig();
	}

	@Override
	public final Request getRequest() {
		return request;
	}

	/**
	 * Creates the class loader for computing the response.
	 * 
	 * @return the class loader
	 * @throws ClassLoaderCreationException if the request contains wrong information and the class loader cannot be created
	 */
	protected abstract EngineClassLoader mkClassLoader() throws ClassLoaderCreationException;

	/**
	 * The creator of a response. Its body runs in a thread, so that the
	 * {@linkplain io.hotmoka.node.local.internal.runtime.Runtime} class
	 * can recover it from its thread-local table.
	 */
	public abstract class ResponseCreator { // TODO: this should be merged into the response builder

		/**
		 * The object that deserializes storage objects into RAM values.
		 */
		protected final Deserializer deserializer;

		/**
		 * The object that can be used to extract the updates to a set of storage objects,
		 * induced by the run of the transaction.
		 */
		protected final UpdatesExtractor updatesExtractor;

		/**
		 * The class loader used for the transaction.
		 */
		protected final EngineClassLoader classLoader;

		/**
		 * The counter for the next storage object created during the transaction.
		 */
		private BigInteger nextProgressive = BigInteger.ZERO;

		protected ResponseCreator() throws TransactionRejectedException {
			try {
				this.classLoader = mkClassLoader();
			}
			catch (ClassLoaderCreationException e) {
				throw new TransactionRejectedException(e, consensus);
			}

			this.deserializer = new Deserializer(environment, classLoader);
			this.updatesExtractor = new UpdatesExtractor(classLoader, environment, request);
		}

		public final ResponseCreation<Response> create() throws TransactionRejectedException, InterruptedException {
			try {
				Response response = environment.submit(new TakamakaCallable(this::body)).get();

				return new ResponseCreation<Response>() {

					@Override
					public Response getResponse() {
						return response;
					}

					@Override
					public final EngineClassLoader getClassLoader() {
						return classLoader;
					}

					@Override
					public final void replaceReverifiedResponses() {
						classLoader.replaceReverifiedResponses();
					}
				};
			}
			catch (ExecutionException e) {
				Throwable cause = e.getCause();

				// body can only throw TransactionRejectedException or unchecked exception (local node bugs);
				// any other checked exception is a bug in the local node
				if (cause instanceof TransactionRejectedException tre)
					throw tre;
				else if (cause instanceof RuntimeException se)
					throw se;
				else if (cause instanceof Error error)
					throw error;
				else
					throw new LocalNodeException("Unexpected exception", cause);
			}
		}

		/**
		 * The body of the creation of the response.
		 * 
		 * @return the response
		 */
		protected abstract Response body() throws TransactionRejectedException;

		/**
		 * Yields the UTC time when the transaction is being run.
		 * This might be for instance the time of creation of a block where the transaction
		 * will be stored, but the detail is left to the implementation.
		 * 
		 * @return the UTC time, as returned by {@link java.lang.System#currentTimeMillis()}
		 */
		public final long now() {
			return environment.getNow();
		}

		/**
		 * Determines if the execution was started by the node itself.
		 * This is always false if the node has no notion of commit.
		 * If the execution has been started by a user request, this will
		 * always be false.
		 * 
		 * @return true if and only if that condition occurs
		 */
		public final boolean isSystemCall() {
			return request instanceof SystemTransactionRequest;
		}

		/**
		 * Takes note of the given event, emitted during this execution.
		 * 
		 * @param event the event
		 */
		public abstract void event(Object event);

		/**
		 * Decreases the available gas by the given amount, for CPU execution.
		 * 
		 * @param amount the amount of gas to consume
		 * @throws OutOfGasException 
		 */
		public abstract void chargeGasForCPU(BigInteger amount) throws OutOfGasException;

		/**
		 * Decreases the available gas by the given amount, for RAM execution.
		 * 
		 * @param amount the amount of gas to consume
		 */
		public abstract void chargeGasForRAM(BigInteger amount) throws OutOfGasException;

		/**
		 * Yields the latest value for the given field of the object with the given storage reference.
		 * The field is not {@code final}. Conceptually, this method looks for the value of the field
		 * in the history of the object.
		 * 
		 * @param object the storage reference; this is assumed to be in store
		 * @param field the field
		 * @return the value of the field
		 */
		public final Object deserializeLastUpdateFor(StorageReference object, FieldSignature field) throws DeserializationException {
			try {
				return deserializer.deserialize(environment.getLastUpdateToField(object, field).getValue());
			}
			catch (UnknownReferenceException e) {
				throw new DeserializationException("Cannot deserialize " + object + ": it is not in store");
			}
			catch (FieldNotFoundException e) {
				throw new DeserializationException("Cannot find the last value of field " + field + " of " + object);
			}
		}

		/**
		 * Yields the latest value for the given field of the object with the given storage reference.
		 * The field is {@code final}. Conceptually, this method looks for the value of the field
		 * in the transaction where the object was created.
		 * 
		 * @param object the storage reference; this is assumed to be in store
		 * @param field the field
		 * @return the value of the field
		 */
		public final Object deserializeLastUpdateForFinal(StorageReference object, FieldSignature field) throws DeserializationException {
			try {
				return deserializer.deserialize(environment.getLastUpdateToFinalField(object, field).getValue());
			}
			catch (UnknownReferenceException e) {
				throw new DeserializationException("Cannot deserialize " + object + ": it is not in store");
			}
			catch (FieldNotFoundException e) {
				throw new DeserializationException("Cannot find the last value of field " + field + " of " + object);
			}
		}

		/**
		 * Yields the next storage reference for the current transaction.
		 * This can be used to associate a storage reference to each new
		 * storage object created during a transaction.
		 * 
		 * @return the next storage reference
		 */
		public final StorageReference getNextStorageReference() {
			BigInteger result = nextProgressive;
			nextProgressive = nextProgressive.add(BigInteger.ONE);
			// nextProgressive is never negative 
			return StorageValues.reference(reference, result);
		}

		/**
		 * Yields the class loader used for the transaction being created.
		 * 
		 * @return the class loader
		 */
		public final EngineClassLoader getClassLoader() {
			return classLoader;
		}

		/**
		 * Logs the message of the given exception, in a way that can be safely reported in the logs.
		 * The idea is that the message is truncated if it is too long, so that there is no risk
		 * of log flooding for exceptions whose message is, for instance, generated programmatically
		 * in order to be too long.
		 * 
		 * @param level the level of the log
		 * @param throwable the exception
		 */
		protected final void logFailure(Level level, Throwable throwable) {
			String message = throwable.getMessage();
			if (message == null)
				message = "<no message>";
			else
				message = message.substring(0, Math.min(message.length(), 200));

			var reference = TransactionReferences.of(environment.getHasher().hash(getRequest()));
			LOGGER.log(level, reference + ": failed with message: \"" + message + "\"");
		}

		/**
		 * A task that executes Takamaka code as part of this transaction.
		 * It sets the response creator in the thread-local of the runtime.
		 */
		private final class TakamakaCallable implements Callable<Response> {
			private final Callable<Response> body;

			private TakamakaCallable(Callable<Response> body) {
				this.body = body;
			}

			@Override
			public Response call() throws Exception {
				try {
					responseCreators.set(ResponseCreator.this);
					return body.call();
				}
				finally {
					responseCreators.remove();
				}
			}
		}
	}
}