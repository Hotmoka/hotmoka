/*
Copyright 2021 Fausto Spoto

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package io.hotmoka.node.local.internal.builders;

import static io.hotmoka.node.local.internal.runtime.Runtime.responseCreators;

import java.math.BigInteger;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;

import io.hotmoka.node.StorageValues;
import io.hotmoka.node.api.TransactionRejectedException;
import io.hotmoka.node.api.UnknownReferenceException;
import io.hotmoka.node.api.nodes.ConsensusConfig;
import io.hotmoka.node.api.requests.SystemTransactionRequest;
import io.hotmoka.node.api.requests.TransactionRequest;
import io.hotmoka.node.api.responses.TransactionResponse;
import io.hotmoka.node.api.signatures.FieldSignature;
import io.hotmoka.node.api.transactions.TransactionReference;
import io.hotmoka.node.api.values.StorageReference;
import io.hotmoka.node.local.DeserializationException;
import io.hotmoka.node.local.api.EngineClassLoader;
import io.hotmoka.node.local.api.FieldNotFoundException;
import io.hotmoka.node.local.api.ResponseBuilder;
import io.hotmoka.node.local.api.StoreException;
import io.hotmoka.verification.VerificationException;
import io.hotmoka.whitelisting.api.UnsupportedVerificationVersionException;

/**
 * A generic implementation of the creator of a response.
 *
 * @param <Request> the type of the request of the transaction
 * @param <Response> the type of the response of the transaction
 */
public abstract class AbstractResponseBuilder<Request extends TransactionRequest<Response>, Response extends TransactionResponse> implements ResponseBuilder<Request, Response> {

	/**
	 * The reference used to refer to the transaction generated by the request.
	 */
	private final TransactionReference reference;

	/**
	 * The execution environment where the response is built.
	 */
	protected final ExecutionEnvironment environment;

	/**
	 * The request of the transaction.
	 */
	protected final Request request;

	/**
	 * The consensus parameters when this builder was created.
	 */
	protected final ConsensusConfig<?,?> consensus;

	/**
	 * Creates the builder of a response.
	 * 
	 * @param reference the reference to the transaction that is building the response
	 * @param request the request for which the response is being built
	 * @param environment the execution environment where the response is built
	 */
	protected AbstractResponseBuilder(TransactionReference reference, Request request, ExecutionEnvironment environment) {
		this.environment = environment;
		this.request = request;
		this.reference = reference;
		this.consensus = environment.getConfig();
	}

	@Override
	public final Request getRequest() {
		return request;
	}

	/**
	 * Creates the class loader for computing the response.
	 * 
	 * @return the class loader
	 * @throws TransactionRejectedException if the request contains wrong information and the class loader cannot be created
	 * @throws StoreException if the store of the node is misbehaving
	 */
	protected abstract EngineClassLoader mkClassLoader() throws StoreException, TransactionRejectedException;

	/**
	 * The creator of a response. Its body runs in a thread, so that the
	 * {@linkplain io.hotmoka.node.local.internal.runtime.Runtime} class
	 * can recover it from its thread-local table.
	 */
	public abstract class ResponseCreator {

		/**
		 * The object that deserializes storage objects into RAM values.
		 */
		protected final Deserializer deserializer;

		/**
		 * The object that can be used to extract the updates to a set of storage objects,
		 * induced by the run of the transaction.
		 */
		protected final UpdatesExtractor updatesExtractor;

		/**
		 * The class loader used for the transaction.
		 */
		protected final EngineClassLoader classLoader;

		/**
		 * The counter for the next storage object created during the transaction.
		 */
		private BigInteger nextProgressive = BigInteger.ZERO;

		protected ResponseCreator() throws StoreException, TransactionRejectedException {
			this.classLoader = mkClassLoader();
			this.deserializer = new Deserializer(environment, classLoader);
			this.updatesExtractor = new UpdatesExtractor(classLoader);
		}

		public final ResponseCreation<Response> create() throws TransactionRejectedException, StoreException, InterruptedException {
			try {
				Response response = environment.submit(new TakamakaCallable(this::body)).get();

				return new ResponseCreation<Response>() {

					@Override
					public Response getResponse() {
						return response;
					}

					@Override
					public final EngineClassLoader getClassLoader() {
						return classLoader;
					}

					@Override
					public final void replaceReverifiedResponses() throws StoreException {
						((EngineClassLoaderImpl) classLoader).replaceReverifiedResponses();
					}
				};
			}
			catch (ExecutionException e) {
				Throwable cause = e.getCause();

				if (cause instanceof TransactionRejectedException tre)
					throw tre;
				else
					throw new StoreException(cause);
			}
		}

		/**
		 * The body of the creation of the response.
		 * 
		 * @return the response
		 * @throws ClassNotFoundException if some class of the Takamaka program cannot be found
		 * @throws UnsupportedVerificationVersionException if the verification version is not available
		 * @throws VerificationException if the verification of a jar failed, before being installed in the node
		 */
		protected abstract Response body() throws TransactionRejectedException, ClassNotFoundException, UnsupportedVerificationVersionException, VerificationException;

		/**
		 * Yields the UTC time when the transaction is being run.
		 * This might be for instance the time of creation of a block where the transaction
		 * will be stored, but the detail is left to the implementation.
		 * 
		 * @return the UTC time, as returned by {@link java.lang.System#currentTimeMillis()}
		 */
		public final long now() {
			return environment.getNow();
		}

		/**
		 * Determines if the execution was started by the node itself.
		 * This is always false if the node has no notion of commit.
		 * If the execution has been started by a user request, this will
		 * always be false.
		 * 
		 * @return true if and only if that condition occurs
		 */
		public final boolean isSystemCall() {
			return request instanceof SystemTransactionRequest;
		}

		/**
		 * Takes note of the given event, emitted during this execution.
		 * 
		 * @param event the event
		 */
		public abstract void event(Object event);

		/**
		 * Decreases the available gas by the given amount, for CPU execution.
		 * 
		 * @param amount the amount of gas to consume
		 */
		public abstract void chargeGasForCPU(BigInteger amount);

		/**
		 * Decreases the available gas by the given amount, for RAM execution.
		 * 
		 * @param amount the amount of gas to consume
		 */
		public abstract void chargeGasForRAM(BigInteger amount);

		/**
		 * Yields the latest value for the given field of the object with the given storage reference.
		 * The field is not {@code final}. Conceptually, this method looks for the value of the field
		 * in the last transaction where the reference was updated.
		 * 
		 * @param object the storage reference
		 * @param field the field
		 * @return the value of the field
		 */
		public final Object deserializeLastUpdateFor(StorageReference object, FieldSignature field) throws DeserializationException, StoreException {
			try {
				return deserializer.deserialize(environment.getLastUpdateToField(object, field).getValue());
			}
			catch (UnknownReferenceException | FieldNotFoundException e) {
				throw new DeserializationException(e);
			}
		}

		/**
		 * Yields the latest value for the given field of the object with the given storage reference.
		 * The field is {@code final}. Conceptually, this method looks for the value of the field
		 * in the transaction where the reference was created.
		 * 
		 * @param object the storage reference
		 * @param field the field
		 * @return the value of the field
		 */
		public final Object deserializeLastUpdateForFinal(StorageReference object, FieldSignature field) throws DeserializationException, StoreException {
			try {
				return deserializer.deserialize(environment.getLastUpdateToFinalField(object, field).getValue());
			}
			catch (UnknownReferenceException | FieldNotFoundException e) {
				throw new DeserializationException(e);
			}
		}

		/**
		 * Yields the next storage reference for the current transaction.
		 * This can be used to associate a storage reference to each new
		 * storage object created during a transaction.
		 * 
		 * @return the next storage reference
		 */
		public final StorageReference getNextStorageReference() {
			BigInteger result = nextProgressive;
			nextProgressive = nextProgressive.add(BigInteger.ONE);
			// nextProgressive is never negative 
			return StorageValues.reference(reference, result);
		}

		/**
		 * Yields the class loader used for the transaction being created.
		 * 
		 * @return the class loader
		 */
		public final EngineClassLoaderImpl getClassLoader() {
			return (EngineClassLoaderImpl) classLoader;
		}

		/**
		 * A task that executes Takamaka code as part of this transaction.
		 * It sets the response creator in the thread-local of the runtime.
		 */
		private final class TakamakaCallable implements Callable<Response> {
			private final Callable<Response> body;

			private TakamakaCallable(Callable<Response> body) {
				this.body = body;
			}

			@Override
			public Response call() throws Exception {
				try {
					responseCreators.set(ResponseCreator.this);
					return body.call();
				}
				finally {
					responseCreators.remove();
				}
			}
		}
	}
}